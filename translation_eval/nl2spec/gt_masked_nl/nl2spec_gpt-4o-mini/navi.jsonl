{"id": 5390, "sentence": ["travel", "to", "waste", "bin", "or", "drop", "orange"], "tl": ["travel_to(waste_bin)", "or", "drop(orange)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "drop", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 5999, "sentence": ["at", "any", "time", "scoop", "up", "apple", "until", "when", "possible", "move", "past", "trash", "can"], "tl": ["finally", "(", "scoop_up(apple)", ")", "until", "finally", "(", "move_past(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "until", "when", "possible", "move", "past", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "move_past", "action_ref": "move past", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(prop_1 U prop_2)"}
{"id": 3757, "sentence": ["at", "any", "time", "touch", "house", "or", "capture", "orange"], "tl": ["finally", "(", "touch(house)", ")", "or", "capture(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "capture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 5730, "sentence": ["at", "some", "time", "present", "at", "flag", "or", "whenever", "bring", "pear"], "tl": ["finally", "(", "present_at(flag)", ")", "or", "finally", "(", "bring(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "whenever", "bring", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_1) or whenever a pear is brought (prop_2), the condition holds. This can be expressed using the \"finally\" operator for the present condition and the \"globally\" operator for the condition that follows whenever the pear is brought.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at some time present at flag\": \"F prop_1\",\n  \"or whenever bring pear\": \"G (prop_2 \u2192 prop_2)\"\n}\n\n3. *FINAL:* F prop_1 or G (prop_2 \u2192 prop_2)"}
{"id": 6450, "sentence": ["move", "to", "house", "and", "put", "in", "bucket"], "tl": ["move_to(house)", "and", "put_in(bucket)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "put", "in", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}}, "prediction": "(and)"}
{"id": 6506, "sentence": ["at", "any", "time", "pick", "up", "peach", "and", "drop", "orange"], "tl": ["finally", "(", "pick_up(peach)", ")", "and", "drop(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "drop", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["peach)"], "args_ref": ["peach)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"and\": \"and\","}
{"id": 1893, "sentence": ["never", "drop", "orange", "or", "at", "some", "time", "move", "forward", "trash", "can"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "or", "finally", "(", "move_forward(trash_can)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "some", "time", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "move_forward", "action_ref": "move forward", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* G not (prop_1 or prop_2) FINISH"}
{"id": 6221, "sentence": ["at", "any", "time", "visit", "trash", "bin", "or", "when", "possible", "journey", "by", "flag"], "tl": ["finally", "(", "visit(trash_bin)", ")", "or", "finally", "(", "journey_by(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "journey", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 5253, "sentence": ["hold", "pear", "and", "at", "any", "time", "venture", "to", "waste", "basket"], "tl": ["hold(pear)", "and", "finally", "(", "venture_to(waste_basket)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "any", "time", "venture", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "  \"and\": \"and\""}
{"id": 4059, "sentence": ["at", "some", "time", "get", "close", "flag", "or", "at", "some", "time", "walk", "to", "flag"], "tl": ["finally", "(", "get_close(flag)", ")", "or", "finally", "(", "walk_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "walk", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(F)"}
{"id": 4803, "sentence": ["at", "some", "time", "proceed", "to", "house", "and", "whenever", "go", "to", "tree"], "tl": ["finally", "(", "proceed_to(house)", ")", "and", "finally", "(", "go_to(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "whenever", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(which we can represent as `prop_1`). Additionally, it states that whenever the system goes to the tree (represented as `prop_2`)"}
{"id": 5583, "sentence": ["whenever", "withhold", "apple", "until", "venture", "towards", "house"], "tl": ["finally", "(", "withhold(apple)", ")", "until", "venture_towards(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "until", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(prop_1 U prop_2)\"\n}\n```\n\n3. *FINAL:* G (prop_1 U prop_2)"}
{"id": 1035, "sentence": ["whenever", "secure", "pear", "and", "whenever", "travel", "to", "house"], "tl": ["finally", "(", "secure(pear)", ")", "and", "finally", "(", "travel_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "whenever", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* G (prop_1 and prop_2) and G (prop_3) FINISH"}
{"id": 968, "sentence": ["hold", "pear", "until", "when", "possible", "get", "apple"], "tl": ["hold(pear)", "until", "finally", "(", "get(apple)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "when", "possible", "get", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "get", "action_ref": "get", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1), and \"get apple\" can be represented as another proposition (prop_2)"}
{"id": 1439, "sentence": ["at", "some", "time", "snatch", "pear", "means", "that", "go", "visit", "flag"], "tl": ["finally", "(", "snatch(pear)", ")", "imply", "go_visit(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "means", "that", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch", "action_ref": "snatch", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1) will eventually lead to the action of going to visit the flag (prop_2)"}
{"id": 2835, "sentence": ["take", "orange", "and", "at", "any", "time", "go", "near", "pear"], "tl": ["take(orange)", "and", "finally", "(", "go_near(pear)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take", "action_ref": "take", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_1), then eventually (F) we will go near the pear (prop_2)"}
{"id": 501, "sentence": ["when", "possible", "journey", "by", "house", "or", "when", "possible", "stand", "by", "tree"], "tl": ["finally", "(", "journey_by(house)", ")", "or", "finally", "(", "stand_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "stand", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "stand_by", "action_ref": "stand by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 5202, "sentence": ["at", "some", "time", "pass", "by", "house", "or", "move", "to", "trash", "can"], "tl": ["finally", "(", "pass_by(house)", ")", "or", "move_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 52, "sentence": ["secure", "apple", "until", "secure", "apple"], "tl": ["secure(apple)", "until", "secure(apple)"], "masked_tl": ["prop_2", "until", "prop_2"], "grounded_sentence": ["prop_1", "until", "secure", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* prop_1 U prop_1 FINISH"}
{"id": 7171, "sentence": ["travel", "to", "waste", "bin", "or", "pick", "up", "orange"], "tl": ["travel_to(waste_bin)", "or", "pick_up(orange)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "pick", "up", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* prop_1 or prop_2 FINISH"}
{"id": 5547, "sentence": ["put", "in", "bucket", "until", "at", "some", "time", "obtain", "orange"], "tl": ["put_in(bucket)", "until", "finally", "(", "obtain(orange)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "some", "time", "obtain", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_2)"}
{"id": 1429, "sentence": ["at", "some", "time", "get", "orange", "means", "that", "at", "any", "time", "proceed", "to", "house"], "tl": ["finally", "(", "get(orange)", ")", "imply", "finally", "(", "proceed_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "means", "that", "at", "any", "time", "proceed", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* F prop_1 \u2192 G prop_2 FINISH"}
{"id": 1408, "sentence": ["pick", "up", "fruit", "until", "at", "any", "time", "go", "past", "flag"], "tl": ["pick_up(fruit)", "until", "finally", "(", "go_past(flag)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "any", "time", "go", "past", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["fruit)"], "args_ref": ["fruit)"]}, "prop_2": {"action_canon": "go_past", "action_ref": "go past", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_2)"}
{"id": 431, "sentence": ["whenever", "spend", "time", "at", "tree", "and", "never", "drop", "orange"], "tl": ["finally", "(", "spend_time_at(tree)", ")", "and", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "never", "drop", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1 \u2192 not prop_2)\",\n  \"and never drop orange\" : \"not prop_2\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 not prop_2)"}
{"id": 1430, "sentence": ["at", "any", "time", "be", "near", "tree", "and", "at", "some", "time", "getting", "pear"], "tl": ["finally", "(", "be_near(tree)", ")", "and", "finally", "(", "getting(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "getting", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "getting", "action_ref": "getting", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(represented by prop_1) holds. The phrase \"at some time getting pear\" indicates that there exists a point in time where the condition of getting a pear (represented by prop_2) holds. Therefore, we can express this as: globally (always) being near the tree and finally (eventually)"}
{"id": 5678, "sentence": ["put", "in", "bin", "or", "seize", "apple"], "tl": ["put_in(bin)", "or", "seize(apple)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "seize", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* prop_1 or prop_2 FINISH"}
{"id": 3015, "sentence": ["if", "at", "any", "time", "present", "at", "flag", ",", "never", "drop", "apple"], "tl": ["finally", "(", "present_at(flag)", ")", "imply", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["if", "at", "any", "time", "prop_1", ",", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(representing \"drop apple\") should not be true at any time. Therefore, we can express this as a globally quantified condition that if we are at the flag, we should never drop the apple.\n\n2. *Explanation dictionary* \u2013\n{\n  \"if at any time present at flag\" : \"G (prop_2 \u2192 F (not prop_1))\",\n  \"never drop apple\" : \"not prop_1\"\n}\n\n3. *FINAL:* G (prop_2 \u2192 F (not prop_1))"}
{"id": 1949, "sentence": ["at", "some", "time", "arrive", "at", "tree", "or", "at", "any", "time", "journey", "to", "house"], "tl": ["finally", "(", "arrive_at(tree)", ")", "or", "finally", "(", "journey_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "any", "time", "journey", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "arrive_at", "action_ref": "arrive at", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 3250, "sentence": ["when", "secure", "apple", ",", "at", "some", "time", "present", "at", "flag"], "tl": ["secure(apple)", "imply", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "prop_1", ",", "at", "some", "time", "present", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1) that must be true at some point in the future (F). The phrase \"at some time present at flag\" indicates that this condition should hold true until a certain point (prop_2) is reached. Therefore, we can express this as: \"when prop_1 is true, prop_2 will eventually be true.\"\n\n2. *Explanation dictionary* \u2013\n{\n  \"when secure apple\" : \"prop_1\",\n  \"at some time present at flag\" : \"prop_2\"\n}\n\n3. *FINAL:* prop_1 \u2192 F(prop_2)"}
{"id": 5502, "sentence": ["whenever", "stop", "by", "house", "and", "move", "to", "trashcan"], "tl": ["finally", "(", "stop_by(house)", ")", "and", "move_to(trashcan)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "(globally). The phrase \"stop by house\" can be represented as a proposition (prop_1), and \"move to trashcan\" can be represented as another proposition (prop_2). Therefore, the overall structure will be that whenever prop_1 is true, prop_2 should eventually be true.\n\n2. *Explanation dictionary* \u2013\n{\n    \"whenever stop by house\" : \"prop_1\",\n    \"move to trashcan\" : \"prop_2\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 F prop_2)"}
{"id": 3955, "sentence": ["when", "possible", "stop", "by", "house", "and", "whenever", "venture", "flag"], "tl": ["finally", "(", "stop_by(house)", ")", "and", "finally", "(", "venture(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "whenever", "venture", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* F(prop_1) and G(prop_2 \u2192 prop_1) FINISH"}
{"id": 2188, "sentence": ["never", "drop", "apple", "and", "never", "drop", "apple"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "and", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_2", ")", ")", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["never", "prop_1", "and", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* G not prop_1 FINISH"}
{"id": 725, "sentence": ["at", "some", "time", "grab", "apple", "and", "when", "possible", "capture", "pear"], "tl": ["finally", "(", "grab(apple)", ")", "and", "finally", "(", "capture(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "when", "possible", "capture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* F prop_1 and (prop_2 \u2192 prop_3) FINISH"}
{"id": 46, "sentence": ["when", "possible", "lay", "hold", "of", "apple", "and", "drop", "pear"], "tl": ["finally", "(", "lay_hold_of(apple)", ")", "and", "drop(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "drop", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "lay_hold_of", "action_ref": "lay hold of", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"and\" : \"and\","}
{"id": 3574, "sentence": ["at", "some", "time", "tax", "apple", "can", "infer", "that", "whenever", "advance", "to", "house"], "tl": ["finally", "(", "tax(apple)", ")", "imply", "finally", "(", "advance_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "can", "infer", "that", "whenever", "advance", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(tax apple) that can lead to an inference (that whenever advance to house). This can be interpreted as saying that eventually, if we advance to the house, then we can infer the condition related to tax apple. The structure can be broken down as follows:\n   - \"at some time\" translates to \"finally\" (F).\n   - \"tax apple\" can be represented as a proposition placeholder (prop_1).\n   - \"whenever advance to house\" indicates a condition that can be expressed as \"if advance to house\" (prop_2) leading to the inference (prop_1).\n\n2. *Explanation dictionary* \u2013\n```json\n{\n  \"at some time\": \"F\",\n  \"tax apple\": \"prop_1\",\n  \"whenever advance to house\": \"prop_2\"\n}\n```\n\n3. *FINAL:* F(prop_2 \u2192 prop_1)"}
{"id": 2585, "sentence": ["never", "drop", "pear", "until", "at", "any", "time", "collect", "apple"], "tl": ["globally", "(", "negation", "(", "drop(pear)", ")", ")", "until", "finally", "(", "collect(apple)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "until", "at", "any", "time", "collect", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* not prop_1 U prop_2 FINISH"}
{"id": 4452, "sentence": ["at", "any", "time", "get", "close", "flag", "or", "at", "any", "time", "capture", "pear"], "tl": ["finally", "(", "get_close(flag)", ")", "or", "finally", "(", "capture(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "any", "time", "capture", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_1 or prop_2)"}
{"id": 4906, "sentence": ["hold", "orange", "or", "pick", "up", "pear"], "tl": ["hold(orange)", "or", "pick_up(pear)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "pick", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"or\": or"}
{"id": 3746, "sentence": ["when", "possible", "arrive", "at", "tree", "and", "pick", "up", "orange"], "tl": ["finally", "(", "arrive_at(tree)", ")", "and", "pick_up(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "arrive_at", "action_ref": "arrive at", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1 \u2192 F prop_2)\",\n  \"arrive at tree\" : \"prop_1\",\n  \"pick up orange\" : \"prop_2\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 F prop_2)"}
{"id": 4932, "sentence": ["when", "possible", "pass", "by", "waste", "receptacle", "and", "when", "possible", "take", "possession", "of", "bear"], "tl": ["finally", "(", "pass_by(waste_receptacle)", ")", "and", "finally", "(", "take_possession_of(bear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "take", "possession", "of", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["waste_receptacle)"], "args_ref": ["waste receptacle)"]}, "prop_2": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}}, "prediction": "(prop_1 \u2192 X prop_2)\", meaning that eventually, if it is possible (prop_1), then in the next step, the action of passing by the waste receptacle (prop_2) should occur. The second condition is \"when possible, take possession of bear\", which can be expressed similarly as \"F (prop_3 \u2192 X prop_4)\", where prop_3 indicates the possibility and prop_4 indicates taking possession of the bear. The overall command can be combined using the \"and\" operator.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible pass by waste receptacle\": \"F (prop_1 \u2192 X prop_2)\",\n  \"when possible take possession of bear\": \"F (prop_3 \u2192 X prop_4)\"\n}\n\n3. *FINAL:* F (prop_1 \u2192 X prop_2) and F (prop_3 \u2192 X prop_4)"}
{"id": 7345, "sentence": ["when", "possible", "obtain", "orange", "or", "take", "to", "tree"], "tl": ["finally", "(", "obtain(orange)", ")", "or", "take_to(tree)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "or", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* G (prop_1 \u2192 (prop_2 or prop_3)) FINISH"}
{"id": 473, "sentence": ["drop", "by", "and", "never", "let", "go", "orange"], "tl": ["drop_by", "and", "globally", "(", "negation", "(", "let_go(orange)", ")", ")"], "masked_tl": ["prop_1", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "never", "let", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop_by", "action_ref": "drop by", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* prop_1 and G (prop_2 \u2192 not prop_2) FINISH"}
{"id": 2877, "sentence": ["come", "to", "tree", "or", "at", "some", "time", "stop", "by", "house"], "tl": ["come_to(tree)", "or", "finally", "(", "stop_by(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "stop", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "come_to", "action_ref": "come to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 3313, "sentence": ["at", "some", "time", "make", "contact", "with", "house", "and", "travel", "to", "waste", "bin"], "tl": ["finally", "(", "make_contact_with(house)", ")", "and", "travel_to(waste_bin)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "travel", "to", "waste", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "(F). The actions can be represented as propositions, where \"make contact with house\" is represented by prop_1 and \"travel to waste bin\" is represented by prop_2. Since both actions need to occur, we can combine them using the \"and\" operator.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at some time\": \"F\",\n  \"make contact with house\": \"prop_1\",\n  \"travel to waste bin\": \"prop_2\"\n}\n\n3. *FINAL:* F(prop_1 and prop_2)"}
{"id": 5898, "sentence": ["at", "any", "time", "venture", "to", "house", "or", "never", "drop", "apple"], "tl": ["finally", "(", "venture_to(house)", ")", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* G (prop_1 or not prop_2) FINISH"}
{"id": 515, "sentence": ["at", "some", "time", "pass", "by", "house", "or", "whenever", "stand", "by", "tree"], "tl": ["finally", "(", "pass_by(house)", ")", "or", "finally", "(", "stand_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "whenever", "stand", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "stand_by", "action_ref": "stand by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 4616, "sentence": ["at", "some", "time", "go", "to", "tree", "or", "at", "some", "time", "grasp", "apple"], "tl": ["finally", "(", "go_to(tree)", ")", "or", "finally", "(", "grasp(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "grasp", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 1713, "sentence": ["never", "drop", "apple", "or", "at", "any", "time", "reach", "flag"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "or", "finally", "(", "reach(flag)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "any", "time", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* G not (prop_1 or prop_2) FINISH"}
{"id": 3627, "sentence": ["when", "possible", "contact", "house", "or", "when", "possible", "pass", "by", "house"], "tl": ["finally", "(", "contact(house)", ")", "or", "finally", "(", "pass_by(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "pass", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 6960, "sentence": ["at", "some", "time", "go", "near", "house", "or", "move", "to", "trashcan"], "tl": ["finally", "(", "go_near(house)", ")", "or", "move_to(trashcan)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 7050, "sentence": ["at", "some", "time", "make", "contact", "flag", "or", "venture", "to", "trash", "can"], "tl": ["finally", "(", "make_contact(flag)", ")", "or", "venture_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact", "action_ref": "make contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 7289, "sentence": ["at", "some", "time", "move", "past", "trash", "can", "and", "at", "any", "time", "procure", "pear"], "tl": ["finally", "(", "move_past(trash_can)", ")", "and", "finally", "(", "procure(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "any", "time", "procure", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_past", "action_ref": "move past", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* F prop_1 \u2192 G prop_2 FINISH"}
{"id": 4923, "sentence": ["drop", "orange", "or", "when", "possible", "collect", "apple"], "tl": ["drop(orange)", "or", "finally", "(", "collect(apple)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "collect", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(when possible, collect apple).\" The \"when possible\" can be interpreted as a condition that allows the collection of the apple to happen at some point in the future.\n\n2. *Explanation dictionary* \u2013\n{\n  \"drop orange\" : prop_1,\n  \"collect apple\" : prop_2,\n  \"when possible\" : F\n}\n\n3. *FINAL:* prop_1 or (F prop_2)"}
{"id": 2894, "sentence": ["acquire", "orange", "or", "never", "drop", "apple"], "tl": ["acquire(orange)", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* prop_1 or G(not prop_2) FINISH"}
{"id": 1873, "sentence": ["snatch", "up", "pear", "and", "when", "possible", "move", "near", "tree"], "tl": ["snatch_up(pear)", "and", "finally", "(", "move_near(tree)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "move", "near", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch_up", "action_ref": "snatch up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "move_near", "action_ref": "move near", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(moving near the tree) should occur after the first action (snatching up the pear) is completed, but only if the condition allows for it. Therefore, we can express this as: first, we want to snatch the pear (prop_1), and then, if possible (prop_2), we want to move near the tree (prop_3).\n\n2. *Explanation dictionary* \u2013\n{\n  \"snatch up pear\": \"prop_1\",\n  \"when possible\": \"prop_2\",\n  \"move near tree\": \"prop_3\"\n}\n\n3. *FINAL:* prop_1 \u2192 (prop_2 U prop_3)"}
{"id": 3481, "sentence": ["when", "secure", "apple", ",", "go", "by", "waste", "bin"], "tl": ["secure(apple)", "imply", "go_by(waste_bin)"], "masked_tl": ["prop_1", "imply", "prop_2"], "grounded_sentence": ["when", "prop_1", ",", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "(prop_2)"}
{"id": 4698, "sentence": ["at", "some", "time", "visit", "waste", "basket", "until", "at", "any", "time", "venture", "to", "flag"], "tl": ["finally", "(", "visit(waste_basket)", ")", "until", "finally", "(", "venture_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "at", "any", "time", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* F prop_1 U prop_2 FINISH"}
{"id": 2263, "sentence": ["go", "visit", "flag", "and", "when", "possible", "go", "home"], "tl": ["go_visit(flag)", "and", "finally", "(", "go(home)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "go", "home", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "3. *FINAL:* prop_1 and (prop_2 \u2192 prop_3) FINISH"}
{"id": 6535, "sentence": ["when", "possible", "touch", "tree", "or", "never", "drop", "apple"], "tl": ["finally", "(", "touch(tree)", ")", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 \u2192 F(prop_1)) and (not prop_1 \u2192 not prop_2) FINISH"}
{"id": 6595, "sentence": ["go", "to", "bucket", "and", "when", "possible", "obtain", "orange"], "tl": ["go_to(bucket)", "and", "finally", "(", "obtain(orange)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "obtain", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1) indicating that we go to the bucket. The second part indicates that at some point in the future (eventually), we should obtain the orange (prop_2)"}
{"id": 167, "sentence": ["put", "in", "bin", "until", "whenever", "scoop", "up", "pear"], "tl": ["put_in(bin)", "until", "finally", "(", "scoop_up(pear)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "whenever", "scoop", "up", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}, "prop_2": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* prop_1 U prop_2 FINISH"}
{"id": 4769, "sentence": ["at", "any", "time", "snatch", "pear", "and", "at", "some", "time", "pass", "by", "house"], "tl": ["finally", "(", "snatch(pear)", ")", "and", "finally", "(", "pass_by(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "pass", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch", "action_ref": "snatch", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(represented by prop_1) can occur, and at some point in the future, the action of passing by the house (represented by prop_2)"}
{"id": 2378, "sentence": ["drop", "orange", "or", "when", "possible", "go", "to", "trash", "bin"], "tl": ["drop(orange)", "or", "finally", "(", "go_to(trash_bin)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "  \"or when possible\" : \"prop_1 or prop_2\""}
{"id": 7440, "sentence": ["move", "towards", "trash", "can", "or", "approach", "tree"], "tl": ["move_towards(trash_can)", "or", "approach(tree)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "approach", "tree", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_towards", "action_ref": "move towards", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 4225, "sentence": ["hold", "apple", "and", "repeatedly", "go", "to", "pear"], "tl": ["hold(apple)", "and", "globally", "(", "finally", "(", "go_to(pear)", ")", ")"], "masked_tl": ["prop_1", "and", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "repeatedly", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"and\": \"and\","}
{"id": 1529, "sentence": ["when", "possible", "take", "possession", "of", "bear", "or", "when", "possible", "go", "home"], "tl": ["finally", "(", "take_possession_of(bear)", ")", "or", "finally", "(", "go(home)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "go", "home", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}, "prop_2": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "(F)"}
{"id": 5085, "sentence": ["at", "some", "time", "migrate", "to", "tree", "until", "travel", "to", "apple"], "tl": ["finally", "(", "migrate_to(tree)", ")", "until", "travel_to(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "migrate_to", "action_ref": "migrate to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* F prop_1 U prop_2 FINISH"}
{"id": 3188, "sentence": ["visit", "tree", "or", "whenever", "touch", "house"], "tl": ["visit(tree)", "or", "finally", "(", "touch(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "touch", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 1591, "sentence": ["travel", "to", "apple", "and", "when", "possible", "visit", "trash", "bin"], "tl": ["travel_to(apple)", "and", "finally", "(", "visit(trash_bin)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "visit", "trash", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "(prop_1) indicating the action of traveling to apple. The second part indicates that at some point in the future (eventually), we want to visit the trash bin (prop_2) when the condition of being possible is met. This can be expressed using the \"finally\" operator (F) combined with the \"implies\" operator (\u2192) to indicate that visiting the trash bin is contingent upon the possibility of doing so.\n\n2. *Explanation dictionary* \u2013\n{\n  \"travel to apple\": \"prop_1\",\n  \"when possible visit trash bin\": \"F (prop_2)\"\n}\n\n3. *FINAL:* prop_1 and F (prop_2)"}
{"id": 5488, "sentence": ["when", "possible", "make", "contact", "with", "house", "or", "never", "let", "go", "orange"], "tl": ["finally", "(", "make_contact_with(house)", ")", "or", "globally", "(", "negation", "(", "let_go(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "never", "let", "go", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (F(prop_1) \u2192 G(prop_2)) or G(prop_3) FINISH"}
{"id": 335, "sentence": ["take", "pear", "and", "whenever", "grab", "apple"], "tl": ["take(pear)", "and", "finally", "(", "grab(apple)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "grab", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take", "action_ref": "take", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1), while the second part \"whenever grab apple\" indicates that whenever the action of grabbing an apple occurs (represented as prop_2), the action of taking a pear should also hold true. This can be expressed using the globally operator (G) to indicate that this condition must always be satisfied.\n\n2. *Explanation dictionary* \u2013\n{\n  \"take pear\": \"prop_1\",\n  \"grab apple\": \"prop_2\",\n  \"whenever\": \"G\"\n}\n\n3. *FINAL:* G(prop_2 \u2192 prop_1)"}
{"id": 6869, "sentence": ["whenever", "visit", "trash", "bin", "and", "move", "to", "trashcan"], "tl": ["finally", "(", "visit(trash_bin)", ")", "and", "move_to(trashcan)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "(prop_1 \u2192 X prop_2)"}
{"id": 3376, "sentence": ["at", "some", "time", "withhold", "apple", "and", "secure", "apple"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "secure(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "secure", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(F) to indicate that these actions will eventually happen. We can use placeholders to represent these actions as prop_1 for \"withhold apple\" and prop_2 for \"secure apple\". The conjunction of these two actions can be expressed using the \"and\" operator.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at some time withhold apple\": \"F prop_1\",\n  \"and secure apple\": \"and F prop_2\"\n}\n\n3. *FINAL:* F (prop_1 and prop_2)"}
{"id": 5586, "sentence": ["don't", "let", "go", "pear", "or", "when", "possible", "snag", "orange"], "tl": ["negation", "(", "let_go(pear)", ")", "or", "finally", "(", "snag(orange)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["don't", "prop_1", "or", "when", "possible", "snag", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* not prop_1 and (prop_2 \u2192 prop_3) FINISH"}
{"id": 5396, "sentence": ["at", "some", "time", "make", "contact", "flag", "and", "at", "any", "time", "seize", "pear"], "tl": ["finally", "(", "make_contact(flag)", ")", "and", "finally", "(", "seize(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "any", "time", "seize", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact", "action_ref": "make contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(represented by prop_1) occurs. The phrase \"and at any time seize pear\" indicates that at any point in time, the action of seizing a pear (represented by prop_2) can occur. Therefore, we can express this as a conjunction of two temporal statements: one that states that eventually (F) we will make contact and one that states that globally (G)"}
{"id": 3187, "sentence": ["whenever", "travel", "to", "trash", "can", "can", "infer", "that", "whenever", "approach", "house"], "tl": ["finally", "(", "travel_to(trash_can)", ")", "imply", "finally", "(", "approach(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "can", "can", "infer", "that", "whenever", "approach", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(prop_1 \u2192 F prop_2)\",\n  \"whenever approach house\": \"G (prop_2)\"\n}\n```\n\n3. *FINAL:* G (prop_1 \u2192 F prop_2)"}
{"id": 2058, "sentence": ["going", "to", "tree", "or", "at", "some", "time", "go", "near", "pear"], "tl": ["going_to(tree)", "or", "finally", "(", "go_near(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "go", "near", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(or) and eventuality (finally).\n\n2. *Explanation dictionary* \u2013\n{\n  \"going to tree\" : prop_1,\n  \"at some time go near pear\" : F(prop_2)\n}\n\n3. *FINAL:* prop_1 or F(prop_2)"}
{"id": 2505, "sentence": ["venture", "towards", "house", "and", "go", "by", "waste", "bin"], "tl": ["venture_towards(house)", "and", "go_by(waste_bin)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "  \"and\": \"and\""}
{"id": 5018, "sentence": ["at", "some", "time", "move", "past", "trash", "can", "or", "repeatedly", "go", "to", "pear"], "tl": ["finally", "(", "move_past(trash_can)", ")", "or", "globally", "(", "finally", "(", "go_to(pear)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "repeatedly", "go", "to", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_past", "action_ref": "move past", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 1645, "sentence": ["if", "whenever", "go", "home", ",", "at", "some", "time", "travel", "by", "tree"], "tl": ["finally", "(", "go(home)", ")", "imply", "finally", "(", "travel_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "whenever", "prop_1", ",", "at", "some", "time", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "travel_by", "action_ref": "travel by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* prop_1 \u2192 F prop_2 FINISH"}
{"id": 1762, "sentence": ["hold", "apple", "or", "hold", "orange"], "tl": ["hold(apple)", "or", "hold(orange)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "hold", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 1758, "sentence": ["at", "any", "time", "secure", "pear", "or", "whenever", "set", "out", "to", "house"], "tl": ["finally", "(", "secure(pear)", ")", "or", "finally", "(", "set_out_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "whenever", "set", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "set_out_to", "action_ref": "set out to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 1383, "sentence": ["whenever", "go", "by", "waste", "basket", "or", "at", "some", "time", "venture", "to", "house"], "tl": ["finally", "(", "go_by(waste_basket)", ")", "or", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "some", "time", "venture", "to", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(prop_1)\",\n    \"or at some time venture to house\": \"F (prop_2)\"\n}\n```\n\n3. *FINAL:* G (prop_1) or F (prop_2)"}
{"id": 1701, "sentence": ["move", "towards", "trash", "can", "or", "whenever", "go", "home"], "tl": ["move_towards(trash_can)", "or", "finally", "(", "go(home)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "go", "home", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_towards", "action_ref": "move towards", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "  \"or whenever\": \"prop_1 or prop_2\""}
{"id": 6789, "sentence": ["at", "some", "time", "travel", "to", "trash", "can", "and", "at", "any", "time", "go", "near", "flag"], "tl": ["finally", "(", "travel_to(trash_can)", ")", "and", "finally", "(", "go_near(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "any", "time", "go", "near", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* F prop_1 and G prop_2 FINISH"}
{"id": 4240, "sentence": ["approach", "trash", "can", "and", "whenever", "get", "to", "flag"], "tl": ["approach(trash_can)", "and", "finally", "(", "get_to(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "get", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1) and the condition that this should happen whenever getting to the flag (prop_2)"}
{"id": 5862, "sentence": ["when", "possible", "get", "close", "flag", "and", "go", "visit", "flag"], "tl": ["finally", "(", "get_close(flag)", ")", "and", "go_visit(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "go", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"and\": \"and\","}
{"id": 559, "sentence": ["never", "drop", "orange", "until", "put", "in", "bin"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "until", "put_in(bin)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "until", "prop_2"], "grounded_sentence": ["never", "prop_1", "until", "put", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}}, "prediction": "(represented by a placeholder) should not happen until the action of putting it in the bin (also represented by a placeholder)"}
{"id": 1216, "sentence": ["at", "any", "time", "be", "near", "tree", "or", "whenever", "going", "to", "house"], "tl": ["finally", "(", "be_near(tree)", ")", "or", "finally", "(", "going_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "whenever", "going", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 2050, "sentence": ["whenever", "secure", "pear", "and", "when", "possible", "scoop", "up", "pear"], "tl": ["finally", "(", "secure(pear)", ")", "and", "finally", "(", "scoop_up(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "when", "possible", "scoop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_1)\",\n  \"and when possible scoop up pear\" : \"F (prop_2)\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 F (prop_2))"}
{"id": 6976, "sentence": ["at", "some", "time", "journey", "by", "flag", "until", "grab", "hold", "pear"], "tl": ["finally", "(", "journey_by(flag)", ")", "until", "grab_hold(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "grab", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "grab_hold", "action_ref": "grab hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_1)\",\n  \"until grab hold pear\": \"U (prop_2)\"\n}\n\n3. *FINAL:* F(prop_1)"}
{"id": 2388, "sentence": ["whenever", "travel", "to", "house", "or", "at", "some", "time", "go", "by", "tree"], "tl": ["finally", "(", "travel_to(house)", ")", "or", "finally", "(", "go_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "some", "time", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"whenever ... holds\" : \"G (prop_1 or prop_2)\""}
{"id": 6457, "sentence": ["at", "some", "time", "reach", "flag", "means", "that", "at", "some", "time", "venture", "to", "house"], "tl": ["finally", "(", "reach(flag)", ")", "imply", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "means", "that", "at", "some", "time", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F) to denote the eventual occurrence of both reaching the flag and venturing to the house. The structure can be broken down as follows: \"at some time reach flag\" translates to F(prop_1) and \"means that at some time venture to house\" translates to F(prop_2). The implication can be expressed as prop_1 \u2192 F(prop_2).\n\n2. *Explanation dictionary* \u2013\n{\n  \"at some time reach flag\": \"F(prop_1)\",\n  \"means that at some time venture to house\": \"F(prop_2)\"\n}\n\n3. *FINAL:* F(prop_1) \u2192 F(prop_2)"}
{"id": 6361, "sentence": ["at", "some", "time", "make", "to", "flag", "until", "forever", "have", "in", "orange"], "tl": ["finally", "(", "make_to(flag)", ")", "until", "globally", "(", "have_in(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "globally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "forever", "have", "in", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_to", "action_ref": "make to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(making a flag) should occur, and this action should continue indefinitely (forever). The phrase \"at some time\" suggests the use of the \"finally\" operator (F), indicating that the action will eventually happen. The phrase \"until forever\" implies that once the action occurs, it will continue to hold true globally (G). Therefore, we can express this as: eventually make the flag (F prop_1) and then globally have it in orange (G prop_2)"}
{"id": 5064, "sentence": ["repeatedly", "grab", "tree", "or", "forever", "hold", "on", "pear"], "tl": ["globally", "(", "finally", "(", "grab(tree)", ")", ")", "or", "globally", "(", "hold_on(pear)", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "forever", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "hold_on", "action_ref": "hold on", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 410, "sentence": ["hold", "orange", "or", "at", "some", "time", "go", "to", "trash", "can"], "tl": ["hold(orange)", "or", "finally", "(", "go_to(trash_can)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(F) to indicate that at least one of these actions will happen at some time in the future.\n\n2. *Explanation dictionary* \u2013\n{\n  \"hold orange\" : prop_1,\n  \"go to trash can\" : prop_2,\n  \"at some time\" : F\n}\n\n3. *FINAL:* F(prop_1 or prop_2)"}
{"id": 2642, "sentence": ["at", "some", "time", "bring", "pear", "until", "when", "possible", "reach", "flag"], "tl": ["finally", "(", "bring(pear)", ")", "until", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "when", "possible", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* F prop_1 U prop_2 FINISH"}
{"id": 3419, "sentence": ["when", "possible", "make", "your", "way", "flag", "or", "always", "have", "apple"], "tl": ["finally", "(", "make_your_way(flag)", ")", "or", "globally", "(", "have(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "always", "have", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(F), indicating that at some point in the future, the action should occur. The phrase \"or always have apple\" indicates that having an apple should be a continuous condition, which can be expressed using the \"globally\" operator (G)"}
{"id": 5250, "sentence": ["acquire", "orange", "or", "whenever", "make", "your", "way", "flag"], "tl": ["acquire(orange)", "or", "finally", "(", "make_your_way(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "make", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1) indicating the action of acquiring an orange. The second part indicates a condition that whenever the action of making your way to the flag occurs (prop_2)"}
{"id": 6740, "sentence": ["at", "some", "time", "travel", "house", "or", "never", "drop", "orange"], "tl": ["finally", "(", "travel(house)", ")", "or", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel", "action_ref": "travel", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(or)"}
{"id": 2017, "sentence": ["move", "to", "house", "or", "when", "possible", "get", "to", "cup"], "tl": ["move_to(house)", "or", "finally", "(", "get_to(cup)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "get", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["cup)"], "args_ref": ["cup)"]}}, "prediction": "(F). Therefore, the overall structure can be expressed as either moving to the house or eventually getting to the cup.\n\n2. *Explanation dictionary* \u2013\n{\n  \"move to house\": \"prop_1\",\n  \"get to cup\": \"prop_2\",\n  \"when possible\": \"F\"\n}\n\n3. *FINAL:* prop_1 or F(prop_2)"}
{"id": 1300, "sentence": ["at", "any", "time", "scoop", "up", "apple", "and", "capture", "orange"], "tl": ["finally", "(", "scoop_up(apple)", ")", "and", "capture(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "capture", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(at any time). We can represent \"scoop up apple\" with `prop_1` and \"capture orange\" with `prop_2`.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time scoop up apple\" : G prop_1,\n  \"at any time capture orange\" : G prop_2\n}\n\n3. *FINAL:* G (prop_1 and prop_2)"}
{"id": 3815, "sentence": ["at", "any", "time", "get", "to", "cup", "or", "at", "any", "time", "grasp", "pear"], "tl": ["finally", "(", "get_to(cup)", ")", "or", "finally", "(", "grasp(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "any", "time", "grasp", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["cup)"], "args_ref": ["cup)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_1) or the action of grasping the pear (prop_2) should occur. This can be expressed using the globally operator (G) to indicate that this condition holds at all times, and the binary connective \"or\" to combine the two actions.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time get to cup\": \"prop_1\",\n  \"at any time grasp pear\": \"prop_2\",\n  \"at any time get to cup or at any time grasp pear\": \"prop_1 or prop_2\"\n}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 954, "sentence": ["venture", "towards", "house", "or", "when", "possible", "bring", "pear"], "tl": ["venture_towards(house)", "or", "finally", "(", "bring(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "bring", "pear", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(bringing the pear) is contingent on the possibility of doing so. Therefore, we can express this as a disjunction where \"venture towards house\" can happen globally, and \"bring pear\" can happen eventually (when possible).\n\n2. *Explanation dictionary* \u2013\n{\n  \"venture towards house\": \"prop_1\",\n  \"bring pear\": \"prop_2\",\n  \"or when possible\": \"F(prop_2)\"\n}\n\n3. *FINAL:* G(prop_1) or F(prop_2)"}
{"id": 4757, "sentence": ["whenever", "venture", "to", "house", "and", "at", "some", "time", "go", "by", "waste", "basket"], "tl": ["finally", "(", "venture_to(house)", ")", "and", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "some", "time", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(prop_1 \u2192 F prop_2)\",\n  \"at some time go by waste basket\" : \"F prop_2\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 F prop_2)"}
{"id": 3152, "sentence": ["always", "touch", "flag", "or", "when", "possible", "approach", "house"], "tl": ["globally", "(", "touch(flag)", ")", "or", "finally", "(", "approach(house)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "or", "when", "possible", "approach", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 6491, "sentence": ["always", "moving", "until", "take", "to", "trashcan"], "tl": ["globally", "(", "moving", ")", "until", "take_to(trashcan)"], "masked_tl": ["globally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["always", "prop_1", "until", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "moving", "action_ref": "moving", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "(always)"}
{"id": 196, "sentence": ["whenever", "travel", "to", "house", "means", "that", "when", "possible", "move", "forward", "trash", "can"], "tl": ["finally", "(", "travel_to(house)", ")", "imply", "finally", "(", "move_forward(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "means", "that", "when", "possible", "move", "forward", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_forward", "action_ref": "move forward", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(prop_1 \u2192 F prop_2)"}
{"id": 3118, "sentence": ["repeatedly", "go", "to", "waste", "basket", "or", "whenever", "venture", "house"], "tl": ["globally", "(", "finally", "(", "go_to(waste_basket)", ")", ")", "or", "finally", "(", "venture(house)", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "whenever", "venture", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(prop_1)\",\n  \"whenever venture house\": \"F (prop_2)\"\n}\n\n3. *FINAL:* G (prop_1) or F (prop_2)"}
{"id": 3870, "sentence": ["capture", "orange", "and", "at", "some", "time", "go", "by", "house"], "tl": ["capture(orange)", "and", "finally", "(", "go_by(house)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F)"}
{"id": 6876, "sentence": ["walk", "and", "put", "in", "bin"], "tl": ["walk", "and", "put_in(bin)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "prop_2"], "lifted_sentence_prop_ids": [1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk", "action_ref": "walk", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}}, "prediction": "(and)"}
{"id": 275, "sentence": ["at", "any", "time", "start", "going", "to", "tree", "or", "whenever", "acquire", "pear"], "tl": ["finally", "(", "start_going_to(tree)", ")", "or", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "whenever", "acquire", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* G (prop_1 or (prop_2 \u2192 prop_1)) FINISH"}
{"id": 5248, "sentence": ["drop", "pear", "until", "at", "some", "time", "go", "to", "transh", "can"], "tl": ["drop(pear)", "until", "finally", "(", "go_to(transh_can)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["transh_can)"], "args_ref": ["transh can)"]}}, "prediction": "(represented by a placeholder) continues until the action of going to \"transh\" (also represented by a placeholder)"}
{"id": 5030, "sentence": ["at", "some", "time", "contact", "flag", "or", "at", "some", "time", "go", "past", "flag"], "tl": ["finally", "(", "contact(flag)", ")", "or", "finally", "(", "go_past(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_past", "action_ref": "go past", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 3133, "sentence": ["do", "not", "let", "go", "pear", "or", "at", "some", "time", "spend", "time", "at", "tree"], "tl": ["negation", "(", "let_go(pear)", ")", "or", "finally", "(", "spend_time_at(tree)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["do", "not", "prop_1", "or", "at", "some", "time", "spend", "time", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* not prop_1 or F prop_2 FINISH"}
{"id": 6408, "sentence": ["whenever", "journey", "to", "house", "or", "whenever", "travel", "to", "flag"], "tl": ["finally", "(", "journey_to(house)", ")", "or", "finally", "(", "travel_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 \u2192 G prop_1) or (prop_2 \u2192 G prop_2) FINISH"}
{"id": 1333, "sentence": ["get", "hold", "of", "pear", "and", "hold", "pear"], "tl": ["get_hold_of(pear)", "and", "hold(pear)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "hold", "pear", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold_of", "action_ref": "get hold of", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(for \"get hold of pear\") and the second action as `prop_2` (for \"hold pear\")"}
{"id": 5607, "sentence": ["put", "in", "bin", "or", "at", "some", "time", "journey", "to", "house"], "tl": ["put_in(bin)", "or", "finally", "(", "journey_to(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "journey", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}, "prop_2": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(putting something in a bin) can occur at some point during a journey to a house. The phrase \"at some time\" indicates that this action is not immediate but will happen eventually. Therefore, we can express this as \"finally\" (F) followed by the action of putting something in the bin (prop_1) during the journey to the house (prop_2).\n\n2. *Explanation dictionary* \u2013\n{\n  \"put in bin\" : \"prop_1\",\n  \"at some time\" : \"F\",\n  \"journey to house\" : \"prop_2\"\n}\n\n3. *FINAL:* F(prop_1)"}
{"id": 4827, "sentence": ["at", "any", "time", "clutch", "orange", "or", "repeatedly", "grab", "tree"], "tl": ["finally", "(", "clutch(orange)", ")", "or", "globally", "(", "finally", "(", "grab(tree)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "repeatedly", "grab", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "clutch", "action_ref": "clutch", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 5715, "sentence": ["whenever", "track", "towards", "tree", "and", "at", "some", "time", "get", "near", "flag"], "tl": ["finally", "(", "track_towards(tree)", ")", "and", "finally", "(", "get_near(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "some", "time", "get", "near", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "track_towards", "action_ref": "track towards", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "get_near", "action_ref": "get near", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1), then eventually (F) we will get near a flag (prop_2). The \"whenever\" suggests a globally applicable condition, so we use \"G\" to indicate that this relationship holds at all times.\n\n2. *Explanation dictionary* \u2013\n{\n  \"whenever\" : \"G\",\n  \"track towards tree\" : \"prop_1\",\n  \"at some time\" : \"F\",\n  \"get near flag\" : \"prop_2\"\n}\n\n3. *FINAL:* G(prop_1 \u2192 F(prop_2))"}
{"id": 1999, "sentence": ["secure", "apple", "or", "at", "some", "time", "withhold", "apple"], "tl": ["secure(apple)", "or", "finally", "(", "withhold(apple)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "withhold", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 1465, "sentence": ["at", "some", "time", "make", "contact", "with", "house", "and", "when", "possible", "obtain", "orange"], "tl": ["finally", "(", "make_contact_with(house)", ")", "and", "finally", "(", "obtain(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "when", "possible", "obtain", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(F) we will make contact with the house (prop_1), and once that happens (implies), we will obtain an orange (prop_2).\n\n2. *Explanation dictionary* \u2013\n{\n  \"at some time make contact with house\": \"F prop_1\",\n  \"when possible obtain orange\": \"prop_1 \u2192 prop_2\"\n}\n\n3. *FINAL:* F prop_1 U (prop_1 \u2192 prop_2)"}
{"id": 1183, "sentence": ["whenever", "make", "contact", "with", "house", "or", "when", "possible", "procure", "pear"], "tl": ["finally", "(", "make_contact_with(house)", ")", "or", "finally", "(", "procure(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "procure", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 4713, "sentence": ["when", "forever", "go", "by", "trash", "can", ",", "whenever", "get", "hold", "apple"], "tl": ["globally", "(", "go_by(trash_can)", ")", "imply", "finally", "(", "get_hold(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "forever", "prop_1", ",", "whenever", "get", "hold", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(e.g., prop_1). The phrase \"whenever get hold apple\" indicates that every time the action of getting hold of an apple occurs (represented by another proposition, e.g., prop_2), the previous condition must hold. Thus, we can express this as \"G (prop_1 \u2192 F prop_2)\".\n\n2. *Explanation dictionary* \u2013\n```json\n{\n  \"when forever\": \"G\",\n  \"go by trash can\": \"prop_1\",\n  \"whenever get hold apple\": \"F prop_2\"\n}\n```\n\n3. *FINAL:* G (prop_1 \u2192 F prop_2)"}
{"id": 3479, "sentence": ["when", "possible", "obtain", "orange", "and", "take", "pear"], "tl": ["finally", "(", "obtain(orange)", ")", "and", "take(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"and\" : \"and\""}
{"id": 6390, "sentence": ["pick", "up", "flag", "until", "at", "any", "time", "pick", "up", "apple"], "tl": ["pick_up(flag)", "until", "finally", "(", "pick_up(apple)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "any", "time", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1) holds true until the condition of picking up the apple (prop_2)"}
{"id": 1396, "sentence": ["always", "go", "by", "trash", "can", "or", "at", "any", "time", "go", "to", "peach"], "tl": ["globally", "(", "go_by(trash_can)", ")", "or", "finally", "(", "go_to(peach)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "or", "at", "any", "time", "go", "to", "peach", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["peach)"], "args_ref": ["peach)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 909, "sentence": ["always", "hold", "onto", "orange", "until", "when", "possible", "get", "close", "tree"], "tl": ["globally", "(", "hold_onto(orange)", ")", "until", "finally", "(", "get_close(tree)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "until", "when", "possible", "get", "close", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(always)"}
{"id": 4180, "sentence": ["whenever", "procure", "orange", "until", "when", "possible", "shift", "to", "flag"], "tl": ["finally", "(", "procure(orange)", ")", "until", "finally", "(", "shift_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "until", "when", "possible", "shift", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "shift_to", "action_ref": "shift to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1 \u2192 (prop_2 U prop_2))"}
{"id": 4284, "sentence": ["move", "to", "house", "until", "at", "some", "time", "travel", "to", "trash", "can"], "tl": ["move_to(house)", "until", "finally", "(", "travel_to(trash_can)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "some", "time", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(prop_1) and the second part is the condition of being at the trash can (prop_2)"}
{"id": 7308, "sentence": ["whenever", "reach", "flag", "or", "go", "by", "waste", "bin"], "tl": ["finally", "(", "reach(flag)", ")", "or", "go_by(waste_bin)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 2776, "sentence": ["never", "drop", "apple", "or", "whenever", "go", "by", "waste", "basket"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(prop_1). The phrase \"or whenever go by waste basket\" suggests that the action of going by the waste basket does not affect the condition of dropping the apple, so it does not need to be included in the formula. Therefore, the final formula will simply state that it is globally true that dropping an apple does not happen.\n\n2. *Explanation dictionary* \u2013\n{\n  \"never drop apple\": \"not prop_1\",\n  \"or whenever go by waste basket\": \"\"\n}\n\n3. *FINAL:* G(not prop_1)"}
{"id": 4056, "sentence": ["whenever", "snatch", "pear", "or", "venture", "to", "trash", "can"], "tl": ["finally", "(", "snatch(pear)", ")", "or", "venture_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch", "action_ref": "snatch", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(prop_1 \u2192 F prop_2)"}
{"id": 6444, "sentence": ["acquire", "orange", "or", "when", "possible", "let", "go", "apple"], "tl": ["acquire(orange)", "or", "finally", "(", "let_go(apple)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "let", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(or) to connect the two actions. The phrase \"when possible\" suggests that the action of acquiring the orange is contingent on the possibility of doing so, which can be interpreted as a temporal condition.\n\n2. *Explanation dictionary* \u2013\n{\n  \"acquire orange\" : \"prop_1\",\n  \"let go apple\" : \"prop_2\",\n  \"when possible\" : \"F\"\n}\n\n3. *FINAL:* F(prop_1 or prop_2)"}
{"id": 5599, "sentence": ["do", "not", "let", "go", "pear", "and", "don't", "let", "go", "pear"], "tl": ["negation", "(", "let_go(pear)", ")", "and", "negation", "(", "let_go(pear)", ")"], "masked_tl": ["negation", "(", "prop_2", ")", "and", "negation", "(", "prop_2", ")"], "grounded_sentence": ["do", "not", "prop_1", "and", "don't", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* not prop_1 and not prop_1 FINISH"}
{"id": 6982, "sentence": ["at", "some", "time", "present", "at", "flag", "or", "never", "drop", "apple"], "tl": ["finally", "(", "present_at(flag)", ")", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(which we can assign to \"present at flag\") should hold true. The second part indicates that the condition represented by `prop_2` (which we can assign to \"drop apple\") should never occur. Therefore, we can express this as: \"eventually (prop_1) or (not prop_2)"}
{"id": 896, "sentence": ["at", "some", "time", "present", "at", "flag", "means", "that", "whenever", "venture", "to", "house"], "tl": ["finally", "(", "present_at(flag)", ")", "imply", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "means", "that", "whenever", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* F prop_1 and (prop_2 \u2192 prop_3) FINISH"}
{"id": 6665, "sentence": ["grasp", "orange", "until", "move", "to", "trash", "can"], "tl": ["grasp(orange)", "until", "move_to(trash_can)"], "masked_tl": ["prop_1", "until", "prop_2"], "grounded_sentence": ["prop_1", "until", "move", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(prop_1) and \"moving to the trash can\" is another proposition (prop_2)"}
{"id": 6325, "sentence": ["going", "to", "tree", "and", "when", "possible", "stop", "by", "trash", "can"], "tl": ["going_to(tree)", "and", "finally", "(", "stop_by(trash_can)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "stop", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* prop_1 U F prop_2 FINISH"}
{"id": 2099, "sentence": ["when", "possible", "collect", "orange", "or", "when", "possible", "reach", "tree"], "tl": ["finally", "(", "collect(orange)", ")", "or", "finally", "(", "reach(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(F) to express that either action can eventually occur. The logical structure will be that either collecting an orange (prop_1) or reaching a tree (prop_2) can happen, which can be expressed as a disjunction (or).\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible collect orange\": \"F prop_1\",\n  \"when possible reach tree\": \"F prop_2\",\n  \"collect orange or reach tree\": \"F (prop_1 or prop_2)\"\n}\n\n3. *FINAL:* F (prop_1 or prop_2)"}
{"id": 267, "sentence": ["venture", "towards", "house", "or", "when", "possible", "reach", "flag"], "tl": ["venture_towards(house)", "or", "finally", "(", "reach(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "reach", "flag", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1), indicating that the action of venturing towards the house is to be taken. The second part \"when possible reach flag\" suggests that reaching the flag (prop_2) is contingent upon the possibility of doing so. This can be expressed using the \"finally\" operator (F) to indicate that reaching the flag should eventually happen if possible. Therefore, the overall structure is a disjunction (or) between these two actions.\n\n2. *Explanation dictionary* \u2013\n{\n  \"venture towards house\": \"prop_1\",\n  \"when possible reach flag\": \"F(prop_2)\"\n}\n\n3. *FINAL:* prop_1 or F(prop_2)"}
{"id": 2784, "sentence": ["whenever", "be", "near", "tree", "or", "whenever", "withold", "apple"], "tl": ["finally", "(", "be_near(tree)", ")", "or", "finally", "(", "withold(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "withold", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "withold", "action_ref": "withold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* G prop_1 or G prop_2 FINISH"}
{"id": 3782, "sentence": ["seize", "apple", "or", "put", "in", "apple", "bucket"], "tl": ["seize(apple)", "or", "put_in(apple_bucket)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "put", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["apple_bucket)"], "args_ref": ["apple bucket)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 4142, "sentence": ["take", "to", "trashcan", "or", "take", "to", "trashcan"], "tl": ["take_to(trashcan)", "or", "take_to(trashcan)"], "masked_tl": ["prop_2", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "take", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 364, "sentence": ["at", "any", "time", "track", "towards", "tree", "and", "whenever", "stop", "by", "house"], "tl": ["finally", "(", "track_towards(tree)", ")", "and", "finally", "(", "stop_by(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "whenever", "stop", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "track_towards", "action_ref": "track towards", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(at all times), if the system is tracking towards the tree, it should continue to do so until it stops by the house.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time\" : \"G\",\n  \"track towards tree\" : \"prop_1\",\n  \"whenever\" : \"\u2192\",\n  \"stop by house\" : \"prop_2\"\n}\n\n3. *FINAL:* G (prop_1 U prop_2)"}
{"id": 2589, "sentence": ["whenever", "procure", "pear", "and", "when", "possible", "pick", "up", "apple"], "tl": ["finally", "(", "procure(pear)", ")", "and", "finally", "(", "pick_up(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "when", "possible", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1 \u2192 F prop_2)\",\n    \"when possible pick up apple\": \"F prop_2\"\n}\n```\n\n3. *FINAL:* G (prop_1 \u2192 F prop_2)"}
{"id": 5690, "sentence": ["when", "possible", "venture", "to", "house", "or", "at", "some", "time", "venture", "to", "house"], "tl": ["finally", "(", "venture_to(house)", ")", "or", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["finally", "(", "prop_2", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "some", "time", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(prop_1 \u2192 F prop_1)\",\n  \"or at some time venture to house\" : \"F prop_1\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 F prop_1)"}
{"id": 6689, "sentence": ["when", "going", "to", "tree", ",", "whenever", "travel", "to", "trash", "can"], "tl": ["going_to(tree)", "imply", "finally", "(", "travel_to(trash_can)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "prop_1", ",", "whenever", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(prop_1 \u2192 F prop_2)"}
{"id": 6539, "sentence": ["grip", "apple", "or", "repeatedly", "go", "to", "apple", "trashcan"], "tl": ["grip(apple)", "or", "globally", "(", "finally", "(", "go_to(apple_trashcan)", ")", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "or", "repeatedly", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grip", "action_ref": "grip", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple_trashcan)"], "args_ref": ["apple trashcan)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 6314, "sentence": ["at", "any", "time", "migrate", "to", "tree", "or", "at", "some", "time", "go", "to", "transh", "can"], "tl": ["finally", "(", "migrate_to(tree)", ")", "or", "finally", "(", "go_to(transh_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "some", "time", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "migrate_to", "action_ref": "migrate to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["transh_can)"], "args_ref": ["transh can)"]}}, "prediction": "(G) to indicate that this condition holds at all times. The two actions can be represented as proposition placeholders, prop_1 for migrating to a tree and prop_2 for going to transh. The logical structure will be that at any time, one of these actions can occur.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time migrate to tree\": \"G (prop_1)\",\n  \"at some time go to transh\": \"G (prop_2)\"\n}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 6555, "sentence": ["do", "not", "let", "go", "pear", "or", "at", "some", "time", "clutch", "orange"], "tl": ["negation", "(", "let_go(pear)", ")", "or", "finally", "(", "clutch(orange)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["do", "not", "prop_1", "or", "at", "some", "time", "clutch", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "clutch", "action_ref": "clutch", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(letting go of pear), while the second part introduces an alternative action (clutching orange) that can happen at some point in the future. In temporal logic, \"not let go pear\" can be represented as \"not prop_1\" (where prop_1 represents the action of letting go of pear), and \"at some time clutch orange\" can be represented as \"F prop_2\" (where prop_2 represents the action of clutching orange)"}
{"id": 3578, "sentence": ["drop", "by", "and", "pick", "up", "orange"], "tl": ["drop_by", "and", "pick_up(orange)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "pick", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop_by", "action_ref": "drop by", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"and\": \"and\""}
{"id": 1247, "sentence": ["drop", "by", "and", "hold", "orange"], "tl": ["drop_by", "and", "hold(orange)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "hold", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop_by", "action_ref": "drop by", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* prop_1 and prop_2 FINISH"}
{"id": 1514, "sentence": ["if", "whenever", "go", "by", "house", ",", "at", "any", "time", "steal", "apple"], "tl": ["finally", "(", "go_by(house)", ")", "imply", "finally", "(", "steal(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "whenever", "prop_1", ",", "at", "any", "time", "steal", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "steal", "action_ref": "steal", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(G) whenever the action of going by the house occurs.\n   - \"at any time steal apple\" indicates that if the condition of going by the house is true, then at some point (F) in the future, the action of stealing an apple (prop_2)"}
{"id": 5043, "sentence": ["reach", "trash", "can", "or", "whenever", "journey", "by", "house"], "tl": ["reach(trash_can)", "or", "finally", "(", "journey_by(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "journey", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* prop_1 or (prop_3 \u2192 prop_2) FINISH"}
{"id": 2910, "sentence": ["whenever", "make", "to", "flag", "or", "grip", "apple"], "tl": ["finally", "(", "make_to(flag)", ")", "or", "grip(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "grip", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_to", "action_ref": "make to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "grip", "action_ref": "grip", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1 or prop_2)\"\n}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 1602, "sentence": ["grab", "hold", "pear", "and", "whenever", "track", "towards", "tree"], "tl": ["grab_hold(pear)", "and", "finally", "(", "track_towards(tree)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "track", "towards", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab_hold", "action_ref": "grab hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "track_towards", "action_ref": "track towards", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"whenever\" : \"G (prop_2 \u2192 prop_1)\""}
{"id": 3134, "sentence": ["when", "when", "possible", "make", "contact", "with", "house", ",", "gather", "orange"], "tl": ["finally", "(", "make_contact_with(house)", ")", "imply", "gather(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["when", "when", "possible", "prop_1", ",", "gather", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "gather", "action_ref": "gather", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* G (prop_1 \u2192 (prop_2 and prop_3)) FINISH"}
{"id": 5821, "sentence": ["when", "possible", "visit", "trash", "bin", "means", "that", "reach", "house"], "tl": ["finally", "(", "visit(trash_bin)", ")", "imply", "reach(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "means", "that", "reach", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(i.e., if the condition holds), then visiting the trash bin should lead to reaching the house.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible\" : \"F prop_1\",\n  \"visit trash bin\" : \"prop_2\",\n  \"reach house\" : \"prop_3\"\n}\n\n3. *FINAL:* F prop_1 \u2192 (prop_2 \u2192 prop_3)"}
{"id": 7470, "sentence": ["approach", "trash", "can", "or", "whenever", "got", "to", "house"], "tl": ["approach(trash_can)", "or", "finally", "(", "got_to(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "got", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "got_to", "action_ref": "got to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 6372, "sentence": ["move", "to", "tree", "or", "when", "possible", "set", "out", "to", "house"], "tl": ["move_to(tree)", "or", "finally", "(", "set_out_to(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "set", "out", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "set_out_to", "action_ref": "set out to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* prop_1 or (prop_2 \u2192 prop_3) FINISH"}
{"id": 1222, "sentence": ["gather", "apple", "means", "that", "at", "any", "time", "visit", "house"], "tl": ["gather(apple)", "imply", "finally", "(", "visit(house)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "means", "that", "at", "any", "time", "visit", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "gather", "action_ref": "gather", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(at all times), if we are gathering an apple, then we must also visit the house.\n\n2. *Explanation dictionary* \u2013\n{\n  \"gather apple\" : \"prop_1\",\n  \"visit house\" : \"prop_2\",\n  \"at any time\" : \"G\"\n}\n\n3. *FINAL:* G(prop_1 \u2192 prop_2)"}
{"id": 4035, "sentence": ["whenever", "obtain", "orange", "and", "capture", "orange"], "tl": ["finally", "(", "obtain(orange)", ")", "and", "capture(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "capture", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1), then we should also capture orange (prop_2). This can be represented using the globally operator (G) to indicate that this condition holds at all times.\n\n2. *Explanation dictionary* \u2013\n{\n  \"whenever obtain orange\": \"G (prop_1 \u2192 prop_2)\",\n  \"and capture orange\": \"prop_2\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 prop_2)"}
{"id": 2952, "sentence": ["go", "by", "waste", "bin", "means", "that", "when", "possible", "present", "at", "flag"], "tl": ["go_by(waste_bin)", "imply", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "means", "that", "when", "possible", "present", "at", "flag", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1), then we should go by the waste bin (prop_2) at that time.\n\n2. *Explanation dictionary* \u2013\n{\n  \"go by waste bin\" : \"prop_2\",\n  \"when possible present at flag\" : \"prop_1\"\n}\n\n3. *FINAL:* prop_1 \u2192 F(prop_2)"}
{"id": 4011, "sentence": ["at", "some", "time", "venture", "to", "house", "or", "secure", "apple"], "tl": ["finally", "(", "venture_to(house)", ")", "or", "secure(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "secure", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"or secure apple\": \"or prop_2\""}
{"id": 511, "sentence": ["hold", "pear", "or", "at", "some", "time", "go", "to", "home"], "tl": ["hold(pear)", "or", "finally", "(", "go_to(home)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 6548, "sentence": ["whenever", "make", "contact", "flag", "or", "at", "some", "time", "be", "at", "house"], "tl": ["finally", "(", "make_contact(flag)", ")", "or", "finally", "(", "be_at(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "some", "time", "be", "at", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact", "action_ref": "make contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "be_at", "action_ref": "be at", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(making contact with a flag), another event (being at the house) should eventually happen. The phrase \"whenever\" suggests a globally quantified condition, meaning that for all instances of making contact with the flag, being at the house must eventually follow. This can be expressed as: if we make contact with the flag (prop_1), then at some point in the future (F), we must be at the house (prop_2).\n\n2. *Explanation dictionary* \u2013\n{\n  \"whenever\" : \"G\",\n  \"make contact flag\" : \"prop_1\",\n  \"at some time be at house\" : \"F prop_2\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 F prop_2)"}
{"id": 763, "sentence": ["if", "when", "possible", "go", "visit", "house", ",", "when", "possible", "walk", "to", "flag"], "tl": ["finally", "(", "go_visit(house)", ")", "imply", "finally", "(", "walk_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "when", "possible", "prop_1", ",", "when", "possible", "walk", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 \u2192 F prop_2) and (F prop_3) FINISH"}
{"id": 2293, "sentence": ["whenever", "proceed", "to", "flag", "or", "whenever", "go", "to", "apple"], "tl": ["finally", "(", "proceed_to(flag)", ")", "or", "finally", "(", "go_to(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1 \u2192 F prop_2)\", meaning that globally, if prop_1 (proceed) is true, then eventually prop_2 (flag) should be reached. The second part \"whenever go to apple\" translates similarly to \"G (prop_3 \u2192 F prop_4)\", meaning that globally, if prop_3 (go) is true, then eventually prop_4 (apple) should be reached. The overall formula combines these two conditions with an \"or\".\n\n2. *Explanation dictionary* \u2013\n{\n  \"whenever proceed to flag\": \"G (prop_1 \u2192 F prop_2)\",\n  \"whenever go to apple\": \"G (prop_3 \u2192 F prop_4)\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 F prop_2) or G (prop_3 \u2192 F prop_4)"}
{"id": 516, "sentence": ["forever", "have", "apple", "and", "when", "possible", "travel", "by", "tree"], "tl": ["globally", "(", "have(apple)", ")", "and", "finally", "(", "travel_by(tree)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "and", "when", "possible", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "travel_by", "action_ref": "travel by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* G(prop_1) and (F(prop_2) \u2192 prop_2) FINISH"}
{"id": 1389, "sentence": ["at", "some", "time", "touch", "tree", "or", "whenever", "pass", "by", "waste", "receptacle"], "tl": ["finally", "(", "touch(tree)", ")", "or", "finally", "(", "pass_by(waste_receptacle)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "whenever", "pass", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["waste_receptacle)"], "args_ref": ["waste receptacle)"]}}, "prediction": "(prop_1) should occur, or whenever the action of passing by a waste receptacle (prop_2)"}
{"id": 4587, "sentence": ["whenever", "get", "hold", "orange", "and", "go", "to", "orange"], "tl": ["finally", "(", "get_hold(orange)", ")", "and", "go_to(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"and\" : \"\u2192\""}
{"id": 6224, "sentence": ["gather", "orange", "or", "whenever", "obtain", "orange"], "tl": ["gather(orange)", "or", "finally", "(", "obtain(orange)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "obtain", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "gather", "action_ref": "gather", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 143, "sentence": ["when", "possible", "grab", "orange", "or", "pick", "up", "fruit"], "tl": ["finally", "(", "grab(orange)", ")", "or", "pick_up(fruit)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "or", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["fruit)"], "args_ref": ["fruit)"]}}, "prediction": "3. *FINAL:* G (prop_1 \u2192 (prop_2 or prop_3)) FINISH"}
{"id": 5220, "sentence": ["at", "any", "time", "get", "apple", "and", "at", "any", "time", "get", "orange"], "tl": ["finally", "(", "get(apple)", ")", "and", "finally", "(", "get(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "any", "time", "get", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "get", "action_ref": "get", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(G)"}
{"id": 1409, "sentence": ["whenever", "go", "to", "trash", "bin", "or", "whenever", "venture", "to", "waste", "basket"], "tl": ["finally", "(", "go_to(trash_bin)", ")", "or", "finally", "(", "venture_to(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "venture", "to", "waste", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "3. *FINAL:* (prop_1 \u2192 G prop_1) or (prop_2 \u2192 G prop_2) FINISH"}
{"id": 2548, "sentence": ["move", "to", "trash", "can", "until", "at", "any", "time", "go", "by", "tree"], "tl": ["move_to(trash_can)", "until", "finally", "(", "go_by(tree)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "any", "time", "go", "by", "tree", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(let's say prop_1), and the condition of being at any time by the tree is represented by another proposition (let's say prop_2)"}
{"id": 6461, "sentence": ["when", "possible", "obtain", "pear", "or", "whenever", "venture", "to", "flag"], "tl": ["finally", "(", "obtain(pear)", ")", "or", "finally", "(", "venture_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "whenever", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 4605, "sentence": ["when", "possible", "tax", "apple", "or", "whenever", "reach", "tree"], "tl": ["finally", "(", "tax(apple)", ")", "or", "finally", "(", "reach(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "whenever", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"when possible\" : \"F(prop_1 or prop_2)\","}
{"id": 1490, "sentence": ["whenever", "go", "to", "home", "and", "when", "possible", "be", "near", "tree"], "tl": ["finally", "(", "go_to(home)", ")", "and", "finally", "(", "be_near(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "when", "possible", "be", "near", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(prop_1), we should eventually (F) be near the tree (prop_2).\n\n2. *Explanation dictionary* \u2013\n{\n  \"whenever go to home\" : \"prop_1\",\n  \"when possible be near tree\" : \"F prop_2\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 F prop_2)"}
{"id": 1805, "sentence": ["repeatedly", "go", "to", "waste", "basket", "or", "never", "drop", "orange"], "tl": ["globally", "(", "finally", "(", "go_to(waste_basket)", ")", ")", "or", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "never", "drop", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 6419, "sentence": ["if", "hold", "pear", ",", "whenever", "start", "going", "to", "tree"], "tl": ["hold(pear)", "imply", "finally", "(", "start_going_to(tree)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "prop_1", ",", "whenever", "start", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* prop_1 \u2192 G prop_2 FINISH"}
{"id": 5097, "sentence": ["whenever", "journey", "by", "house", "or", "when", "possible", "get", "to", "cup"], "tl": ["finally", "(", "journey_by(house)", ")", "or", "finally", "(", "get_to(cup)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "get", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["cup)"], "args_ref": ["cup)"]}}, "prediction": "(prop_1)\". The phrase \"or when possible get to cup\" indicates an alternative condition that can occur, represented as \"F (prop_2)\". The overall structure indicates that if the first condition holds, then the second condition should eventually be satisfied. Thus, we can express this as \"G (prop_1 \u2192 F (prop_2))\".\n\n2. *Explanation dictionary* \u2013\n{\n  \"whenever journey by house\": \"G (prop_1)\",\n  \"or when possible get to cup\": \"F (prop_2)\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 F (prop_2))"}
{"id": 1790, "sentence": ["never", "drop", "apple", "or", "approach", "tree"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "or", "approach(tree)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "prop_2"], "grounded_sentence": ["never", "prop_1", "or", "approach", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* G not (prop_1 or prop_2) FINISH"}
{"id": 6973, "sentence": ["when", "whenever", "go", "home", ",", "collect", "pear"], "tl": ["finally", "(", "go(home)", ")", "imply", "collect(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["when", "whenever", "prop_1", ",", "collect", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(globally) \"go home\" is true, \"collect pear\" should also be true.\n\n2. *Explanation dictionary* \u2013\n{\n  \"go home\": \"prop_1\",\n  \"collect pear\": \"prop_2\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 prop_2)"}
{"id": 1982, "sentence": ["when", "possible", "walk", "to", "flag", "until", "when", "possible", "have", "possession", "of", "apple"], "tl": ["finally", "(", "walk_to(flag)", ")", "until", "finally", "(", "have_possession_of(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "until", "when", "possible", "have", "possession", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "have_possession_of", "action_ref": "have possession of", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* prop_1 U prop_2 FINISH"}
{"id": 1487, "sentence": ["at", "some", "time", "bring", "pear", "and", "venture", "towards", "house"], "tl": ["finally", "(", "bring(pear)", ")", "and", "venture_towards(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F) to indicate that these actions will eventually happen. We can use placeholders for the actions: \"bring pear\" can be represented as prop_1 and \"venture towards house\" as prop_2. The conjunction of these two actions can be expressed as prop_1 and prop_2.\n\n2. *Explanation dictionary* \u2013\n{\n  \"bring pear\": \"prop_1\",\n  \"venture towards house\": \"prop_2\"\n}\n\n3. *FINAL:* F (prop_1 and prop_2)"}
{"id": 3053, "sentence": ["never", "drop", "apple", "and", "move", "towards", "trash", "can"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "and", "move_towards(trash_can)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "and", "prop_2"], "grounded_sentence": ["never", "prop_1", "and", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "move_towards", "action_ref": "move towards", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(G not), which means that the specified condition should hold at all times. The phrase \"drop apple\" can be represented as a proposition (prop_1), and \"move towards trash can\" can be represented as another proposition (prop_2). Therefore, the complete formula states that it is always the case that if you are moving towards the trash can, you should not drop the apple.\n\n2. *Explanation dictionary* \u2013\n{\n  \"never drop apple\" : \"G not prop_1\",\n  \"move towards trash can\" : \"prop_2\"\n}\n\n3. *FINAL:* G (prop_2 \u2192 not prop_1)"}
{"id": 4997, "sentence": ["keep", "apple", "or", "when", "possible", "venture", "flag"], "tl": ["keep(apple)", "or", "finally", "(", "venture(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "venture", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "keep", "action_ref": "keep", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* prop_1 or (prop_2 \u2192 prop_3) FINISH"}
{"id": 5415, "sentence": ["when", "possible", "grab", "pear", "and", "whenever", "go", "to", "home"], "tl": ["finally", "(", "grab(pear)", ")", "and", "finally", "(", "go_to(home)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "3. *FINAL:* F prop_1 and G prop_2 FINISH"}
{"id": 5172, "sentence": ["visit", "tree", "and", "at", "some", "time", "haul", "pear"], "tl": ["visit(tree)", "and", "finally", "(", "haul(pear)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "haul", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "haul", "action_ref": "haul", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_1) \u2192 F(prop_2)"}
{"id": 5143, "sentence": ["when", "possible", "lay", "hold", "of", "apple", "or", "forever", "hold", "on", "pear"], "tl": ["finally", "(", "lay_hold_of(apple)", ")", "or", "globally", "(", "hold_on(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "forever", "hold", "on", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "lay_hold_of", "action_ref": "lay hold of", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "hold_on", "action_ref": "hold on", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "    \"or\": \"or\","}
{"id": 5593, "sentence": ["at", "any", "time", "grab", "orange", "means", "that", "at", "any", "time", "seize", "orange"], "tl": ["finally", "(", "grab(orange)", ")", "imply", "finally", "(", "seize(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "means", "that", "at", "any", "time", "seize", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(G) to express that this relationship holds at all times. The phrase \"grab orange\" can be represented by a proposition placeholder (prop_1) and \"seize orange\" by another placeholder (prop_2). Thus, we can express this as: if we grab an orange (prop_1), then we must also seize an orange (prop_2) at any time.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time grab orange\" : \"prop_1\",\n  \"at any time seize orange\" : \"prop_2\",\n  \"means that\" : \"implies\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 prop_2)"}
{"id": 5049, "sentence": ["keep", "apple", "or", "at", "some", "time", "visit", "trash", "bin"], "tl": ["keep(apple)", "or", "finally", "(", "visit(trash_bin)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "visit", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "keep", "action_ref": "keep", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "    \"or\": \"or\""}
{"id": 3739, "sentence": ["grasp", "orange", "and", "travel", "to", "waste", "bin"], "tl": ["grasp(orange)", "and", "travel_to(waste_bin)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "travel", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "  \"and\": \"and\""}
{"id": 6480, "sentence": ["take", "to", "trash", "can", "and", "whenever", "have", "possession", "of", "apple"], "tl": ["take_to(trash_can)", "and", "finally", "(", "have_possession_of(apple)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "have", "possession", "of", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "have_possession_of", "action_ref": "have possession of", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1), we should take it to the trash can (prop_2). The \"whenever\" suggests a globally quantified condition, meaning that the action should hold true at all times when the condition is met.\n\n2. *Explanation dictionary* \u2013\n{\n  \"take to trash can\" : \"prop_2\",\n  \"whenever have possession of apple\" : \"G (prop_1 \u2192 prop_2)\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 prop_2)"}
{"id": 1059, "sentence": ["move", "to", "trashcan", "or", "at", "some", "time", "snag", "orange"], "tl": ["move_to(trashcan)", "or", "finally", "(", "snag(orange)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "snag", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(or) to connect the two actions. The \"move to trashcan\" can be represented as prop_1, and \"snag orange\" can be represented as prop_2. The temporal aspect of \"at some time\" suggests the use of the \"finally\" operator (F)"}
{"id": 5507, "sentence": ["grab", "hold", "pear", "and", "do", "not", "let", "go", "pear"], "tl": ["grab_hold(pear)", "and", "negation", "(", "let_go(pear)", ")"], "masked_tl": ["prop_1", "and", "negation", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "do", "not", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab_hold", "action_ref": "grab hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_1). The second part indicates that we should not let go of the pear, which can be represented as a negation of a proposition (not prop_2)"}
{"id": 4055, "sentence": ["venture", "towards", "house", "and", "never", "drop", "apple"], "tl": ["venture_towards(house)", "and", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["prop_1", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1) that indicates the action of venturing towards the house. The second part indicates that the action of dropping the apple (prop_2)"}
{"id": 197, "sentence": ["at", "some", "time", "withhold", "apple", "or", "at", "some", "time", "venture", "to", "house"], "tl": ["finally", "(", "withhold(apple)", ")", "or", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* F prop_1 or F prop_2 FINISH"}
{"id": 3741, "sentence": ["whenever", "yield", "pear", "or", "always", "hold", "onto", "orange"], "tl": ["finally", "(", "yield(pear)", ")", "or", "globally", "(", "hold_onto(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "always", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "yield", "action_ref": "yield", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1), and \"hold onto orange\" can be represented as another proposition (prop_2). The logical structure indicates that whenever prop_1 is true, prop_2 must also be true globally.\n\n2. *Explanation dictionary* \u2013\n{\n  \"whenever yield pear\": \"G (prop_1 \u2192 prop_2)\",\n  \"always hold onto orange\": \"G prop_2\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 prop_2)"}
{"id": 2715, "sentence": ["hold", "on", "to", "pear", "and", "whenever", "get", "to", "cup"], "tl": ["hold_on_to(pear)", "and", "finally", "(", "get_to(cup)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "get", "to", "cup", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold_on_to", "action_ref": "hold on to", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["cup)"], "args_ref": ["cup)"]}}, "prediction": "(globally), while the second part introduces a condition that must hold whenever the second action occurs. Therefore, we can express this as: globally hold on to pear (prop_1) and whenever we get to cup (prop_2), the first condition must still hold.\n\n2. *Explanation dictionary* \u2013\n{\n  \"hold on to pear\": \"prop_1\",\n  \"whenever get to cup\": \"prop_2\"\n}\n\n3. *FINAL:* G prop_1 and (prop_2 \u2192 G prop_1)"}
{"id": 3824, "sentence": ["grip", "apple", "and", "never", "drop", "orange"], "tl": ["grip(apple)", "and", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["prop_1", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grip", "action_ref": "grip", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1), indicating that the action of gripping the apple is true. The phrase \"never drop orange\" indicates that the action of dropping the orange should never occur, which can be expressed as globally not dropping the orange (not prop_2)"}
{"id": 3786, "sentence": ["drop", "orange", "and", "hold", "pear"], "tl": ["drop(orange)", "and", "hold(pear)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "hold", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* prop_1 and prop_2 FINISH"}
{"id": 4350, "sentence": ["at", "some", "time", "present", "at", "flag", "or", "secure", "apple"], "tl": ["finally", "(", "present_at(flag)", ")", "or", "secure(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "secure", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 5553, "sentence": ["when", "possible", "get", "close", "tree", "until", "at", "some", "time", "tax", "apple"], "tl": ["finally", "(", "get_close(tree)", ")", "until", "finally", "(", "tax(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "until", "at", "some", "time", "tax", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(let's say prop_1), and \"get close to tree\" can be represented as another proposition (let's say prop_2). The phrase \"at some time tax apple\" can be represented as a proposition (let's say prop_3). Therefore, the overall structure can be expressed as: if it is possible (prop_1), then we should get close to the tree (prop_2) until the event of \"tax apple\" occurs (prop_3).\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible\": \"prop_1\",\n  \"get close tree\": \"prop_2\",\n  \"until at some time tax apple\": \"prop_3\"\n}\n\n3. *FINAL:* prop_1 \u2192 (prop_2 U prop_3)"}
{"id": 4014, "sentence": ["stop", "by", "flag", "until", "whenever", "go", "to", "tree"], "tl": ["stop_by(flag)", "until", "finally", "(", "go_to(tree)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "whenever", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(represented by the proposition placeholder `prop_1`) should occur by the time a flag (represented by `prop_2`) is reached, and this stopping should continue until the condition of going to the tree (represented by `prop_3`) is met. The phrase \"by flag\" suggests that the stopping action is contingent upon reaching the flag, while \"until whenever go to tree\" indicates that the stopping action should persist until the condition of going to the tree is satisfied.\n\n2. *Explanation dictionary* \u2013\n```json\n{\n  \"stop\": \"prop_1\",\n  \"by flag\": \"prop_2\",\n  \"until\": \"U\",\n  \"whenever go to tree\": \"prop_3\"\n}\n```\n\n3. *FINAL:* prop_1 U (prop_2 \u2192 prop_3)"}
{"id": 3875, "sentence": ["whenever", "touch", "house", "and", "at", "any", "time", "yield", "pear"], "tl": ["finally", "(", "touch(house)", ")", "and", "finally", "(", "yield(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "any", "time", "yield", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "yield", "action_ref": "yield", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(G) to indicate that the condition holds at all times. The phrase \"and at any time yield pear\" suggests that yielding a pear should occur whenever the condition of touching the house is true. Therefore, the complete formula can be constructed as: G(touch \u2192 yield).\n\n2. *Explanation dictionary* \u2013\n{\n    \"whenever touch house\" : \"G(touch)\",\n    \"at any time yield pear\" : \"yield\"\n}\n\n3. *FINAL:* G(touch \u2192 yield)"}
{"id": 4168, "sentence": ["at", "any", "time", "haul", "pear", "or", "at", "some", "time", "advance", "to", "house"], "tl": ["finally", "(", "haul(pear)", ")", "or", "finally", "(", "advance_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "some", "time", "advance", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "haul", "action_ref": "haul", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 5992, "sentence": ["acquire", "orange", "or", "at", "any", "time", "acquire", "pear"], "tl": ["acquire(orange)", "or", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "any", "time", "acquire", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(G) to indicate that the action can happen at any point in the future. The \"or\" in the command suggests a disjunction between the two actions. Therefore, we can express this as: G (prop_1 or prop_2), where prop_1 represents acquiring an orange and prop_2 represents acquiring a pear.\n\n2. *Explanation dictionary* \u2013\n{\n  \"acquire orange\" : \"prop_1\",\n  \"acquire pear\" : \"prop_2\",\n  \"at any time\" : \"G\"\n}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 6678, "sentence": ["secure", "apple", "or", "whenever", "go", "by", "waste", "basket"], "tl": ["secure(apple)", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 2439, "sentence": ["go", "by", "waste", "bin", "or", "whenever", "go", "by", "waste", "basket"], "tl": ["go_by(waste_bin)", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "go", "by", "waste", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(prop_1 or G(prop_2))"}
{"id": 6978, "sentence": ["whenever", "show", "yourself", "near", "house", "and", "never", "drop", "apple"], "tl": ["finally", "(", "show_yourself_near(house)", ")", "and", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* G (prop_1 and prop_2 \u2192 not prop_3) FINISH"}
{"id": 581, "sentence": ["when", "possible", "get", "orange", "or", "when", "possible", "show", "yourself", "near", "house"], "tl": ["finally", "(", "get(orange)", ")", "or", "finally", "(", "show_yourself_near(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "show", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F) to express that either action can eventually occur. The logical structure will be an \"or\" (or) between the two actions.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible get orange\": \"F prop_1\",\n  \"when possible show yourself near house\": \"F prop_2\"\n}\n\n3. *FINAL:* F (prop_1 or prop_2)"}
{"id": 7055, "sentence": ["never", "drop", "apple", "or", "at", "any", "time", "go", "by", "waste", "basket"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 6807, "sentence": ["never", "let", "go", "orange", "or", "at", "some", "time", "capture", "pear"], "tl": ["globally", "(", "negation", "(", "let_go(orange)", ")", ")", "or", "finally", "(", "capture(pear)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "some", "time", "capture", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* G not prop_1 and F prop_2 FINISH"}
{"id": 300, "sentence": ["approach", "tree", "and", "repeatedly", "go", "to", "waste", "basket"], "tl": ["approach(tree)", "and", "globally", "(", "finally", "(", "go_to(waste_basket)", ")", ")"], "masked_tl": ["prop_1", "and", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "repeatedly", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(prop_1), and the second action, which is repeated, can be represented as a proposition (prop_2). The phrase \"repeatedly go to waste basket\" suggests that the action of going to the waste basket should occur infinitely often, which can be expressed using the globally operator (G) combined with the finally operator (F)"}
{"id": 434, "sentence": ["at", "any", "time", "get", "hold", "of", "orange", "or", "when", "possible", "stand", "by", "tree"], "tl": ["finally", "(", "get_hold_of(orange)", ")", "or", "finally", "(", "stand_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "stand", "by", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold_of", "action_ref": "get hold of", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "stand_by", "action_ref": "stand by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 3833, "sentence": ["at", "some", "time", "scoop", "up", "apple", "and", "at", "some", "time", "journey", "by", "house"], "tl": ["finally", "(", "scoop_up(apple)", ")", "and", "finally", "(", "journey_by(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "some", "time", "journey", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F)"}
{"id": 4032, "sentence": ["whenever", "go", "to", "house", "or", "do", "not", "pick", "up", "anything"], "tl": ["finally", "(", "go_to(house)", ")", "or", "negation", "(", "finally", "(", "pick_up(anything)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "negation", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "do", "not", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["anything)"], "args_ref": ["anything)"]}}, "prediction": "3. *FINAL:* G (prop_1 or not prop_2) FINISH"}
{"id": 2880, "sentence": ["at", "any", "time", "go", "to", "transh", "can", "or", "at", "some", "time", "got", "to", "house"], "tl": ["finally", "(", "go_to(transh_can)", ")", "or", "finally", "(", "got_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "some", "time", "got", "to", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["transh_can)"], "args_ref": ["transh can)"]}, "prop_2": {"action_canon": "got_to", "action_ref": "got to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 3428, "sentence": ["move", "to", "trash", "can", "and", "when", "possible", "make", "your", "way", "flag"], "tl": ["move_to(trash_can)", "and", "finally", "(", "make_your_way(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "make", "your", "way", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1) indicating the action of moving to the trash can. The second part suggests that this action should occur whenever it is possible, which can be represented using the \"finally\" operator (F) to indicate that at some point in the future, the action should be taken. Therefore, the overall formula can be expressed as: \"move to trash can\" (prop_1) should happen \"when possible\" (F).\n\n2. *Explanation dictionary* \u2013\n{\n  \"move to trash can\": \"prop_1\",\n  \"when possible\": \"F\"\n}\n\n3. *FINAL:* prop_1 U F(prop_1)"}
{"id": 1080, "sentence": ["at", "some", "time", "snag", "orange", "and", "travel", "to", "apple"], "tl": ["finally", "(", "snag(orange)", ")", "and", "travel_to(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"and\": \"and\""}
{"id": 854, "sentence": ["at", "any", "time", "set", "out", "to", "house", "and", "at", "some", "time", "touch", "tree"], "tl": ["finally", "(", "set_out_to(house)", ")", "and", "finally", "(", "touch(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "touch", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "set_out_to", "action_ref": "set out to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(G). The phrase \"at some time\" indicates that the second action must eventually occur, which can be represented using the finally operator (F)"}
{"id": 81, "sentence": ["forever", "have", "in", "orange", "until", "reach", "house"], "tl": ["globally", "(", "have_in(orange)", ")", "until", "reach(house)"], "masked_tl": ["globally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["forever", "prop_1", "until", "reach", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* G (prop_1 and prop_2 and prop_3) U prop_4  FINISH"}
{"id": 3970, "sentence": ["at", "any", "time", "go", "to", "trash", "bin", "or", "at", "some", "time", "tax", "apple"], "tl": ["finally", "(", "go_to(trash_bin)", ")", "or", "finally", "(", "tax(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "some", "time", "tax", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 5249, "sentence": ["at", "any", "time", "approach", "house", "and", "at", "some", "time", "show", "yourself", "near", "house"], "tl": ["finally", "(", "approach(house)", ")", "and", "finally", "(", "show_yourself_near(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "show", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* G prop_1 and F prop_2 FINISH"}
{"id": 1579, "sentence": ["at", "some", "time", "snag", "orange", "or", "take", "to", "trashcan"], "tl": ["finally", "(", "snag(orange)", ")", "or", "take_to(trashcan)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 2750, "sentence": ["venture", "to", "trash", "can", "and", "at", "some", "time", "go", "near", "pear"], "tl": ["venture_to(trash_can)", "and", "finally", "(", "go_near(pear)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "go", "near", "pear", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(F) to indicate that both actions will eventually happen. We can represent the action of venturing to the trash can as prop_1 and going near the pear as prop_2.\n\n2. *Explanation dictionary* \u2013\n{\n  \"venture to trash can\" : \"prop_1\",\n  \"go near pear\" : \"prop_2\"\n}\n\n3. *FINAL:* F(prop_1) U F(prop_2)"}
{"id": 446, "sentence": ["when", "possible", "advance", "to", "house", "or", "at", "any", "time", "get", "close", "flag"], "tl": ["finally", "(", "advance_to(house)", ")", "or", "finally", "(", "get_close(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "get", "close", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "    \"or\": \"or\""}
{"id": 1137, "sentence": ["travel", "to", "apple", "or", "don't", "let", "go", "pear"], "tl": ["travel_to(apple)", "or", "negation", "(", "let_go(pear)", ")"], "masked_tl": ["prop_1", "or", "negation", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "don't", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 5995, "sentence": ["whenever", "venture", "to", "waste", "basket", "or", "when", "possible", "procure", "orange"], "tl": ["finally", "(", "venture_to(waste_basket)", ")", "or", "finally", "(", "procure(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "procure", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1 or prop_2)"}
{"id": 3737, "sentence": ["move", "to", "trashcan", "or", "when", "possible", "make", "to", "flag"], "tl": ["move_to(trashcan)", "or", "finally", "(", "make_to(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "make", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "make_to", "action_ref": "make to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(making to flag) is contingent on the possibility of doing so. Therefore, we can express this as a disjunction where the first action is to move to the trashcan, and the second action is to make to flag if it is possible.\n\n2. *Explanation dictionary* \u2013\n{\n  \"move to trashcan\": \"prop_1\",\n  \"make to flag\": \"prop_2\",\n  \"or when possible\": \"prop_2\"\n}\n\n3. *FINAL:* prop_1 or (F prop_2)"}
{"id": 5554, "sentence": ["when", "possible", "move", "to", "flag", "or", "at", "any", "time", "walk", "near", "flag"], "tl": ["finally", "(", "move_to(flag)", ")", "or", "finally", "(", "walk_near(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "walk", "near", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "walk_near", "action_ref": "walk near", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* prop_1 \u2192 (F (prop_2 or prop_3)) FINISH"}
{"id": 4578, "sentence": ["when", "repeatedly", "go", "to", "apple", "trashcan", ",", "grip", "apple"], "tl": ["globally", "(", "finally", "(", "go_to(apple_trashcan)", ")", ")", "imply", "grip(apple)"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "imply", "prop_2"], "grounded_sentence": ["when", "repeatedly", "prop_1", ",", "grip", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple_trashcan)"], "args_ref": ["apple trashcan)"]}, "prop_2": {"action_canon": "grip", "action_ref": "grip", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1 \u2192 F prop_2)\",\n  \"grip apple\" : \"prop_2\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 F prop_2)"}
{"id": 2981, "sentence": ["when", "possible", "go", "home", "and", "forever", "touch", "flag"], "tl": ["finally", "(", "go(home)", ")", "and", "globally", "(", "touch(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "forever", "touch", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* prop_1 \u2192 (prop_2 and G prop_3) FINISH"}
{"id": 7387, "sentence": ["get", "to", "tree", "or", "approach", "trash", "can"], "tl": ["get_to(tree)", "or", "approach(trash_can)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "approach", "trash", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 3378, "sentence": ["at", "some", "time", "obtain", "orange", "and", "whenever", "stop", "by", "trash", "can"], "tl": ["finally", "(", "obtain(orange)", ")", "and", "finally", "(", "stop_by(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "whenever", "stop", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(prop_2 \u2192 prop_1)\"\n}\n\n3. *FINAL:* F prop_1 and G (prop_2 \u2192 prop_1)"}
{"id": 901, "sentence": ["whenever", "proceed", "to", "flag", "or", "whenever", "approach", "flag"], "tl": ["finally", "(", "proceed_to(flag)", ")", "or", "finally", "(", "approach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "approach", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 \u2192 ...) or (prop_2 \u2192 ...) FINISH"}
{"id": 7392, "sentence": ["whenever", "go", "by", "house", "and", "pick", "up", "pear"], "tl": ["finally", "(", "go_by(house)", ")", "and", "pick_up(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_1 \u2192 F prop_2)"}
{"id": 4972, "sentence": ["when", "possible", "proceed", "to", "house", "and", "when", "possible", "start", "going", "to", "tree"], "tl": ["finally", "(", "proceed_to(house)", ")", "and", "finally", "(", "start_going_to(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "start", "going", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(eventually we will proceed to the house)"}
{"id": 5217, "sentence": ["put", "in", "apple", "bucket", "and", "at", "any", "time", "travel", "to", "trash", "can"], "tl": ["put_in(apple_bucket)", "and", "finally", "(", "travel_to(trash_can)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "any", "time", "travel", "to", "trash", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["apple_bucket)"], "args_ref": ["apple bucket)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "  \"and\": \"and\""}
{"id": 2456, "sentence": ["at", "any", "time", "seize", "orange", "or", "when", "possible", "acquire", "pear"], "tl": ["finally", "(", "seize(orange)", ")", "or", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "acquire", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 2870, "sentence": ["whenever", "let", "go", "apple", "or", "pick", "up", "fruit"], "tl": ["finally", "(", "let_go(apple)", ")", "or", "pick_up(fruit)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["fruit)"], "args_ref": ["fruit)"]}}, "prediction": "    \"or\" : \"or\","}
{"id": 171, "sentence": ["when", "possible", "travel", "to", "house", "or", "whenever", "move", "past", "trash", "can"], "tl": ["finally", "(", "travel_to(house)", ")", "or", "finally", "(", "move_past(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "whenever", "move", "past", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_past", "action_ref": "move past", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 5959, "sentence": ["go", "to", "bucket", "until", "when", "possible", "touch", "house"], "tl": ["go_to(bucket)", "until", "finally", "(", "touch(house)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "when", "possible", "touch", "house", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(e.g., prop_1) and the condition of being able to touch the house is represented by another proposition (e.g., prop_2)"}
{"id": 7182, "sentence": ["never", "let", "go", "apple", "until", "at", "some", "time", "collect", "orange"], "tl": ["globally", "(", "negation", "(", "let_go(apple)", ")", ")", "until", "finally", "(", "collect(orange)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "until", "at", "some", "time", "collect", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(which we can represent as prop_1) should not happen (not prop_1) until \"collecting an orange\" (represented as prop_2) happens (prop_2)"}
{"id": 6703, "sentence": ["at", "some", "time", "stop", "by", "house", "or", "forever", "have", "in", "orange"], "tl": ["finally", "(", "stop_by(house)", ")", "or", "globally", "(", "have_in(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "forever", "have", "in", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 49, "sentence": ["at", "some", "time", "grab", "pear", "and", "whenever", "pick", "up", "peach"], "tl": ["finally", "(", "grab(pear)", ")", "and", "finally", "(", "pick_up(peach)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "whenever", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["peach)"], "args_ref": ["peach)"]}}, "prediction": "3. *FINAL:* F(prop_1) and G(prop_2 \u2192 prop_1) FINISH"}
{"id": 6078, "sentence": ["never", "drop", "orange", "and", "move", "to", "tree"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "and", "move_to(tree)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "and", "prop_2"], "grounded_sentence": ["never", "prop_1", "and", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* G not (prop_1 and prop_2) FINISH"}
{"id": 3893, "sentence": ["whenever", "grab", "apple", "and", "never", "drop", "orange"], "tl": ["finally", "(", "grab(apple)", ")", "and", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"and\" : \"and\","}
{"id": 3432, "sentence": ["whenever", "getting", "pear", "can", "infer", "that", "at", "any", "time", "go", "to", "house"], "tl": ["finally", "(", "getting(pear)", ")", "imply", "finally", "(", "go_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "can", "infer", "that", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "getting", "action_ref": "getting", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(G) for the condition and the finally operator (F)"}
{"id": 2403, "sentence": ["when", "possible", "go", "by", "waste", "basket", "and", "when", "possible", "go", "by", "waste", "basket"], "tl": ["finally", "(", "go_by(waste_basket)", ")", "and", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_2", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "go", "by", "waste", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "3. *FINAL:* (prop_2 \u2192 F prop_1) and (prop_2 \u2192 F prop_1) FINISH"}
{"id": 4795, "sentence": ["at", "some", "time", "withhold", "apple", "and", "at", "some", "time", "reach", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "some", "time", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1), and the second part \"reach flag\" can be represented as another proposition (prop_2). Since both actions need to happen at some point in the future, we can use the \"finally\" operator (F) to indicate that each action will eventually occur.\n\n2. *Explanation dictionary* \u2013\n{\n  \"withhold apple\": \"prop_1\",\n  \"reach flag\": \"prop_2\"\n}\n\n3. *FINAL:* F(prop_1) and F(prop_2)"}
{"id": 2809, "sentence": ["at", "any", "time", "start", "going", "to", "house", "or", "when", "possible", "start", "going", "to", "house"], "tl": ["finally", "(", "start_going_to(house)", ")", "or", "finally", "(", "start_going_to(house)", ")"], "masked_tl": ["finally", "(", "prop_2", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "start", "going", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 6951, "sentence": ["venture", "towards", "house", "or", "whenever", "go", "by", "waste", "basket"], "tl": ["venture_towards(house)", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(prop_1), and the second part \"whenever go by waste basket\" can be represented as \"go by waste basket\" (prop_2) that is globally true (G)"}
{"id": 3371, "sentence": ["always", "touch", "flag", "can", "infer", "that", "whenever", "go", "to", "apple"], "tl": ["globally", "(", "touch(flag)", ")", "imply", "finally", "(", "go_to(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "can", "infer", "that", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(always), if we go to apple, then we are touching the flag.\n\n2. *Explanation dictionary* \u2013\n{\n  \"always\" : \"G\",\n  \"touch\" : \"prop_1\",\n  \"flag\" : \"prop_2\",\n  \"can\" : \"\u2192\",\n  \"infer\" : \"\u2192\",\n  \"whenever\" : \"\u2192\",\n  \"go\" : \"prop_3\",\n  \"to\" : \"\",\n  \"apple\" : \"prop_4\"\n}\n\n3. *FINAL:* G (prop_3 \u2192 prop_1)"}
{"id": 6901, "sentence": ["when", "possible", "come", "home", "means", "that", "pick", "up", "pear"], "tl": ["finally", "(", "come(home)", ")", "imply", "pick_up(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "means", "that", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "come", "action_ref": "come", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* prop_1 \u2192 (prop_2 \u2192 prop_3) FINISH"}
{"id": 2217, "sentence": ["at", "any", "time", "go", "to", "tree", "until", "take", "apple"], "tl": ["finally", "(", "go_to(tree)", ")", "until", "take(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "until", "take", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1 U prop_2)"}
{"id": 1929, "sentence": ["at", "any", "time", "withhold", "apple", "and", "at", "some", "time", "present", "at", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "present", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(represented by prop_1) can occur, and at some time in the future, the condition of being present at a flag (represented by prop_2) can also occur. This can be expressed as: globally (at any time) withholding an apple implies that eventually (at some time) being present at the flag will happen.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time withhold apple\": \"G (prop_1)\",\n  \"at some time present at flag\": \"F (prop_2)\"\n}\n\n3. *FINAL:* G (prop_1) \u2192 F (prop_2)"}
{"id": 6116, "sentence": ["at", "some", "time", "withhold", "apple", "and", "at", "any", "time", "present", "at", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "any", "time", "present", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(representing \"withhold apple\") is true. The second part, \"at any time present at flag,\" indicates that at all times, the proposition `prop_2` (representing \"present at flag\")"}
{"id": 1794, "sentence": ["don't", "let", "go", "pear", "means", "that", "take", "pear"], "tl": ["negation", "(", "let_go(pear)", ")", "imply", "take(pear)"], "masked_tl": ["negation", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["don't", "prop_1", "means", "that", "take", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(not prop_1)"}
{"id": 5394, "sentence": ["go", "to", "orange", "or", "pick", "up", "flag"], "tl": ["go_to(orange)", "or", "pick_up(flag)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 3055, "sentence": ["go", "to", "bucket", "and", "when", "possible", "procure", "orange"], "tl": ["go_to(bucket)", "and", "finally", "(", "procure(orange)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "procure", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1), and then, once we are at the bucket, we can procure the orange (prop_2) if the condition allows it.\n\n2. *Explanation dictionary* \u2013\n{\n  \"go to bucket\": \"prop_1\",\n  \"procure orange\": \"prop_2\",\n  \"when possible\": \"F prop_2\"\n}\n\n3. *FINAL:* prop_1 and (X (F prop_2))"}
{"id": 64, "sentence": ["at", "any", "time", "bring", "pear", "or", "venture", "towards", "house"], "tl": ["finally", "(", "bring(pear)", ")", "or", "venture_towards(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 136, "sentence": ["whenever", "make", "to", "flag", "or", "drop", "pear"], "tl": ["finally", "(", "make_to(flag)", ")", "or", "drop(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "drop", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_to", "action_ref": "make to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(make_to_flag \u2192 (drop_pear \u2228 make_to_flag)).\n\n2. *Explanation dictionary* \u2013\n{\n  \"whenever make to flag\" : \"make_to_flag\",\n  \"or drop pear\" : \"drop_pear\",\n  \"should hold globally\" : \"G\"\n}\n\n3. *FINAL:* G (make_to_flag \u2192 (drop_pear \u2228 make_to_flag))"}
{"id": 5779, "sentence": ["when", "possible", "walk", "to", "flag", "until", "pick", "up", "pear"], "tl": ["finally", "(", "walk_to(flag)", ")", "until", "pick_up(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "until", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_1), while \"walk to flag\" can be represented as another proposition (prop_2), and \"pick up pear\" as a third proposition (prop_3). The structure of the command implies that walking to the flag should happen globally until the action of picking up the pear occurs.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible\": \"prop_1\",\n  \"walk to flag\": \"prop_2\",\n  \"until\": \"U\",\n  \"pick up pear\": \"prop_3\"\n}\n\n3. *FINAL:* prop_1 \u2192 (prop_2 U prop_3)"}
{"id": 1702, "sentence": ["if", "at", "some", "time", "secure", "pear", ",", "whenever", "take", "possession", "of", "bear"], "tl": ["finally", "(", "secure(pear)", ")", "imply", "finally", "(", "take_possession_of(bear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "at", "some", "time", "prop_1", ",", "whenever", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}}, "prediction": "(prop_1) where prop_1 represents \"secure pear\".\n   - \"whenever take possession of bear\" indicates that every time we take possession of the bear (represented by prop_2), the condition of securing the pear must hold. This can be expressed as G(prop_2 \u2192 F(prop_1)).\n\n2. *Explanation dictionary* \u2013\n```json\n{\n  \"secure pear\": \"prop_1\",\n  \"take possession of bear\": \"prop_2\"\n}\n```\n\n3. *FINAL:* F(prop_1) U G(prop_2 \u2192 F(prop_1))"}
{"id": 1502, "sentence": ["when", "possible", "going", "to", "house", "and", "move", "towards", "trash", "can"], "tl": ["finally", "(", "going_to(house)", ")", "and", "move_towards(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "move", "towards", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_towards", "action_ref": "move towards", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(prop_1 \u2192 prop_2)"}
{"id": 1410, "sentence": ["at", "some", "time", "seize", "pear", "or", "at", "some", "time", "grab", "apple"], "tl": ["finally", "(", "seize(pear)", ")", "or", "finally", "(", "grab(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "grab", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 5643, "sentence": ["go", "by", "waste", "bin", "and", "when", "possible", "reach", "flag"], "tl": ["go_by(waste_bin)", "and", "finally", "(", "reach(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "reach", "flag", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1) and \"reach flag\" as another proposition (prop_2)"}
{"id": 1576, "sentence": ["at", "any", "time", "be", "at", "house", "means", "that", "when", "possible", "reach", "tree"], "tl": ["finally", "(", "be_at(house)", ")", "imply", "finally", "(", "reach(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "means", "that", "when", "possible", "reach", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_at", "action_ref": "be at", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(prop_1 \u2192 ...)\", and \"when possible reach tree\" translates to \"F (prop_2)\". The implication connects these two parts.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time be at house\" : \"G (prop_1)\",\n  \"means that when possible reach tree\" : \"F (prop_2)\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 F (prop_2))"}
{"id": 5511, "sentence": ["don't", "let", "go", "orange", "and", "come", "to", "tree"], "tl": ["negation", "(", "let_go(orange)", ")", "and", "come_to(tree)"], "masked_tl": ["negation", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["don't", "prop_1", "and", "come", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "come_to", "action_ref": "come to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"and\" : \"and\""}
{"id": 7437, "sentence": ["at", "any", "time", "capture", "pear", "or", "move", "to", "trash", "can"], "tl": ["finally", "(", "capture(pear)", ")", "or", "move_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 6715, "sentence": ["whenever", "make", "contact", "with", "house", "or", "when", "possible", "go", "near", "pear"], "tl": ["finally", "(", "make_contact_with(house)", ")", "or", "finally", "(", "go_near(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "go", "near", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_1), then we should also go near the pear (prop_2).\n\n2. *Explanation dictionary* \u2013\n```json\n{\n  \"whenever make contact with house\": \"G (prop_1 \u2192 prop_2)\",\n  \"when possible go near pear\": \"prop_2\"\n}\n```\n\n3. *FINAL:* G (prop_1 \u2192 prop_2)"}
{"id": 2392, "sentence": ["pick", "up", "pear", "and", "when", "possible", "get", "apple"], "tl": ["pick_up(pear)", "and", "finally", "(", "get(apple)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "get", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "get", "action_ref": "get", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1), and the second action can be represented as another proposition (prop_2). The phrase \"when possible\" suggests that the action of getting the apple should occur eventually after the first action is completed. Therefore, we can express this as \"prop_1\" happens first, and then \"prop_2\" should happen eventually (F prop_2)"}
{"id": 2287, "sentence": ["at", "some", "time", "scoop", "up", "pear", "or", "never", "let", "go", "orange"], "tl": ["finally", "(", "scoop_up(pear)", ")", "or", "globally", "(", "negation", "(", "let_go(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "never", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(represented by prop_1) will occur, or the action of never letting go of an orange (represented by prop_2) will hold true. This can be expressed using the \"finally\" operator (F)"}
{"id": 782, "sentence": ["when", "possible", "approach", "flag", "and", "whenever", "obtain", "orange"], "tl": ["finally", "(", "approach(flag)", ")", "and", "finally", "(", "obtain(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "whenever", "obtain", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1 \u2192 X prop_2)"}
{"id": 7207, "sentence": ["at", "any", "time", "travel", "house", "or", "when", "possible", "journey", "to", "flag"], "tl": ["finally", "(", "travel(house)", ")", "or", "finally", "(", "journey_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "journey", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel", "action_ref": "travel", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 6828, "sentence": ["whenever", "spend", "time", "at", "tree", "and", "at", "some", "time", "move", "near", "tree"], "tl": ["finally", "(", "spend_time_at(tree)", ")", "and", "finally", "(", "move_near(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "some", "time", "move", "near", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "move_near", "action_ref": "move near", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(G) for the first part and the finally operator (F) for the second part, combined with an implication.\n\n2. *Explanation dictionary* \u2013\n{\n  \"whenever spend time at tree\" : \"G(prop_1)\",\n  \"at some time move near tree\" : \"F(prop_2)\"\n}\n\n3. *FINAL:* G(prop_1) \u2192 F(prop_2)"}
{"id": 6481, "sentence": ["whenever", "going", "to", "house", "or", "at", "any", "time", "venture", "to", "flag"], "tl": ["finally", "(", "going_to(house)", ")", "or", "finally", "(", "venture_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1 or F prop_2)"}
{"id": 546, "sentence": ["whenever", "reach", "flag", "or", "go", "by", "waste", "bin"], "tl": ["finally", "(", "reach(flag)", ")", "or", "go_by(waste_bin)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 1109, "sentence": ["at", "any", "time", "seize", "orange", "or", "go", "to", "bucket"], "tl": ["finally", "(", "seize(orange)", ")", "or", "go_to(bucket)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 5062, "sentence": ["whenever", "get", "orange", "and", "whenever", "let", "go", "apple"], "tl": ["finally", "(", "get(orange)", ")", "and", "finally", "(", "let_go(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "whenever", "let", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1 \u2192 F prop_2)\",\n    \"whenever let go apple\" : \"G (prop_3 \u2192 F prop_4)\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 F prop_2) and G (prop_3 \u2192 F prop_4)"}
{"id": 6779, "sentence": ["always", "have", "in", "orange", "or", "when", "possible", "be", "in", "house's", "vicinity"], "tl": ["globally", "(", "have_in(orange)", ")", "or", "finally", "(", "be_in(house's_vicinity)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "or", "when", "possible", "be", "in", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "be_in", "action_ref": "be in", "args_canon": ["house's_vicinity)"], "args_ref": ["house's vicinity)"]}}, "prediction": "(G) to indicate that the condition holds at all times. The \"or\" condition suggests a disjunction between being in the house's vicinity and being in orange when possible.\n\n2. *Explanation dictionary* \u2013\n{\n  \"always have in orange or when possible be in house's vicinity\": \"G (prop_1 or (prop_2))\",\n  \"in orange\": \"prop_1\",\n  \"when possible be in house's vicinity\": \"prop_2\"\n}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 4873, "sentence": ["go", "by", "waste", "bin", "or", "never", "drop", "apple"], "tl": ["go_by(waste_bin)", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "or", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 2720, "sentence": ["hold", "pear", "or", "pick", "up", "flag"], "tl": ["hold(pear)", "or", "pick_up(flag)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "pick", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 2885, "sentence": ["hold", "pear", "and", "when", "possible", "get", "close", "tree"], "tl": ["hold(pear)", "and", "finally", "(", "get_close(tree)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "get", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* prop_1 and (prop_1 \u2192 prop_2) FINISH"}
{"id": 7316, "sentence": ["at", "some", "time", "start", "going", "to", "house", "means", "that", "repeatedly", "go", "to", "apple", "trashcan"], "tl": ["finally", "(", "start_going_to(house)", ")", "imply", "globally", "(", "finally", "(", "go_to(apple_trashcan)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "means", "that", "repeatedly", "go", "to", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple_trashcan)"], "args_ref": ["apple trashcan)"]}}, "prediction": "(F), indicating that the event will happen eventually. The \"start going to house\" can be represented as a proposition (prop_1), and the \"repeatedly go to apple trashcan\" can be represented as a proposition (prop_2) that must hold globally (G)"}
{"id": 4368, "sentence": ["whenever", "withhold", "apple", "or", "at", "any", "time", "go", "by", "waste", "basket"], "tl": ["finally", "(", "withhold(apple)", ")", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(prop_1 \u2192 F prop_2)"}
{"id": 5298, "sentence": ["at", "any", "time", "scoop", "up", "apple", "and", "at", "any", "time", "seize", "pear"], "tl": ["finally", "(", "scoop_up(apple)", ")", "and", "finally", "(", "seize(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "any", "time", "seize", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* F prop_1 and F prop_2 FINISH"}
{"id": 2977, "sentence": ["at", "any", "time", "got", "to", "house", "means", "that", "at", "some", "time", "venture", "flag"], "tl": ["finally", "(", "got_to(house)", ")", "imply", "finally", "(", "venture(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "means", "that", "at", "some", "time", "venture", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "got_to", "action_ref": "got to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(represented by prop_1) is true, it implies that at some future time (eventually) the condition of \"venture flag\" (represented by prop_2) will also be true. This can be expressed using the globally operator to indicate that the implication holds at all times.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time got to house means that at some time venture flag\": \"G (prop_1 \u2192 F prop_2)\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 F prop_2)"}
{"id": 5472, "sentence": ["never", "drop", "orange", "or", "acquire", "apple"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "or", "acquire(apple)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "prop_2"], "grounded_sentence": ["never", "prop_1", "or", "acquire", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* G not (prop_1 or prop_2) FINISH"}
{"id": 55, "sentence": ["go", "to", "bucket", "and", "take", "to", "tree"], "tl": ["go_to(bucket)", "and", "take_to(tree)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "take", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* prop_1 \u2192 X prop_2 FINISH"}
{"id": 5781, "sentence": ["approach", "tree", "can", "infer", "that", "when", "possible", "make", "your", "way", "flag"], "tl": ["approach(tree)", "imply", "finally", "(", "make_your_way(flag)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "can", "infer", "that", "when", "possible", "make", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1), indicating that the action of approaching the tree is possible. The phrase \"can infer\" suggests a capability or condition that can be represented as another proposition (prop_2). The phrase \"when possible\" indicates a condition that can be expressed as a temporal condition, leading to the action of \"make your way flag,\" which can be represented as another proposition (prop_3). The overall structure implies that if the first action is taken, then the second action can follow under the condition of possibility.\n\n2. *Explanation dictionary* \u2013\n{\n  \"approach tree\" : \"prop_1\",\n  \"can infer\" : \"prop_2\",\n  \"when possible\" : \"prop_2\",\n  \"make your way flag\" : \"prop_3\"\n}\n\n3. *FINAL:* prop_1 \u2192 (prop_2 U prop_3)"}
{"id": 4160, "sentence": ["secure", "apple", "and", "at", "some", "time", "go", "by", "waste", "basket"], "tl": ["secure(apple)", "and", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(prop_1), and \"at some time go by waste basket\" indicates that eventually (F) the action of going by the waste basket (prop_2) should occur. Therefore, the complete formula states that we want to secure the apple (prop_1) and eventually go by the waste basket (prop_2)"}
{"id": 2320, "sentence": ["venture", "towards", "house", "and", "at", "some", "time", "go", "by", "waste", "basket"], "tl": ["venture_towards(house)", "and", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "  \"and\": \"and\","}
{"id": 653, "sentence": ["when", "possible", "venture", "to", "waste", "basket", "or", "at", "any", "time", "venture", "house"], "tl": ["finally", "(", "venture_to(waste_basket)", ")", "or", "finally", "(", "venture(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "venture", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* G \u2192 (F(prop_1) or F(prop_2)) FINISH"}
{"id": 3030, "sentence": ["get", "hold", "of", "pear", "and", "whenever", "obtain", "apple"], "tl": ["get_hold_of(pear)", "and", "finally", "(", "obtain(apple)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "obtain", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold_of", "action_ref": "get hold of", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* prop_1 and G (prop_2 \u2192 prop_1) FINISH"}
{"id": 2982, "sentence": ["when", "walk", ",", "at", "some", "time", "journey", "by", "house"], "tl": ["walk", "imply", "finally", "(", "journey_by(house)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "prop_1", ",", "at", "some", "time", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk", "action_ref": "walk", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(prop_1 \u2192 F prop_2)"}
{"id": 5513, "sentence": ["at", "some", "time", "make", "your", "way", "flag", "or", "whenever", "make", "your", "way", "flag"], "tl": ["finally", "(", "make_your_way(flag)", ")", "or", "finally", "(", "make_your_way(flag)", ")"], "masked_tl": ["finally", "(", "prop_2", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "whenever", "make", "your", "way", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(making your way to the flag). The phrase \"or whenever\" indicates that this action can happen at any time, which can be interpreted as a condition that allows for the action to be repeated or to occur at different times. Therefore, we can express this as \"eventually make your way to the flag\" (F prop_1) or \"whenever make your way to the flag\" (G prop_1)"}
{"id": 6844, "sentence": ["when", "possible", "travel", "to", "house", "or", "at", "any", "time", "go", "to", "flag"], "tl": ["finally", "(", "travel_to(house)", ")", "or", "finally", "(", "go_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 5432, "sentence": ["when", "possible", "go", "by", "house", "or", "never", "let", "go", "apple"], "tl": ["finally", "(", "go_by(house)", ")", "or", "globally", "(", "negation", "(", "let_go(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "never", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 \u2192 prop_2) or (not prop_3) FINISH"}
{"id": 4487, "sentence": ["whenever", "contact", "house", "or", "at", "any", "time", "get", "hold", "orange"], "tl": ["finally", "(", "contact(house)", ")", "or", "finally", "(", "get_hold(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "get", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 4817, "sentence": ["travel", "to", "apple", "and", "at", "some", "time", "venture", "flag"], "tl": ["travel_to(apple)", "and", "finally", "(", "venture(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "venture", "flag", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1) and \"venture flag\" as another proposition (prop_2). The phrase \"at some time\" indicates that the second action (venturing flag) will eventually happen after the first action (traveling to apple)"}
{"id": 980, "sentence": ["whenever", "go", "to", "home", "until", "when", "possible", "pass", "by", "trash", "bin"], "tl": ["finally", "(", "go_to(home)", ")", "until", "finally", "(", "pass_by(trash_bin)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "until", "when", "possible", "pass", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "(prop_1 \u2192 (prop_2 U prop_3))\",\n    \"until when possible pass by trash bin\" : \"prop_2 U prop_3\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 (prop_2 U prop_3))"}
{"id": 1032, "sentence": ["at", "some", "time", "move", "near", "tree", "and", "repeatedly", "go", "to", "apple", "trashcan"], "tl": ["finally", "(", "move_near(tree)", ")", "and", "globally", "(", "finally", "(", "go_to(apple_trashcan)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "repeatedly", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_near", "action_ref": "move near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple_trashcan)"], "args_ref": ["apple trashcan)"]}}, "prediction": "  \"and\": \"and\","}
{"id": 1994, "sentence": ["at", "any", "time", "travel", "to", "flag", "and", "stop", "by", "flag"], "tl": ["finally", "(", "travel_to(flag)", ")", "and", "stop_by(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "stop", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"and\" : \"and\""}
{"id": 6783, "sentence": ["at", "any", "time", "walk", "near", "flag", "or", "at", "any", "time", "get", "hold", "orange"], "tl": ["finally", "(", "walk_near(flag)", ")", "or", "finally", "(", "get_hold(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "any", "time", "get", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk_near", "action_ref": "walk near", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(represented by prop_1) or the action of getting hold of an orange (represented by prop_2) can occur. The phrase \"at any time\" suggests that these actions can happen globally, so we will use the globally operator (G) to express that either of these actions can happen at any point in time.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time walk near flag\": \"prop_1\",\n  \"at any time get hold orange\": \"prop_2\"\n}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 6217, "sentence": ["visit", "tree", "and", "at", "any", "time", "show", "yourself", "near", "house"], "tl": ["visit(tree)", "and", "finally", "(", "show_yourself_near(house)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "any", "time", "show", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* prop_1 \u2192 G prop_2 FINISH"}
{"id": 6152, "sentence": ["go", "to", "orange", "bin", "or", "come", "to", "tree"], "tl": ["go_to(orange_bin)", "or", "come_to(tree)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "come", "to", "tree", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange_bin)"], "args_ref": ["orange bin)"]}, "prop_2": {"action_canon": "come_to", "action_ref": "come to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 5350, "sentence": ["secure", "apple", "or", "secure", "apple"], "tl": ["secure(apple)", "or", "secure(apple)"], "masked_tl": ["prop_2", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "secure", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(logical OR)"}
{"id": 2509, "sentence": ["when", "possible", "go", "by", "waste", "basket", "and", "at", "any", "time", "reach", "flag"], "tl": ["finally", "(", "go_by(waste_basket)", ")", "and", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "any", "time", "reach", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(which can be interpreted as a condition that can be checked), the action of going by the waste basket should occur. Additionally, at any time, there should be a condition to reach the flag. This can be expressed in temporal logic by stating that the action of going by the waste basket should happen until the condition of reaching the flag is satisfied.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible\" : \"F(prop_1)\",\n  \"go by waste basket\" : \"prop_2\",\n  \"and at any time\" : \"G\",\n  \"reach flag\" : \"prop_3\"\n}\n\n3. *FINAL:* F(prop_1) \u2192 (prop_2 U prop_3)"}
{"id": 6656, "sentence": ["at", "some", "time", "show", "yourself", "near", "house", "or", "at", "some", "time", "pass", "by", "trash", "bin"], "tl": ["finally", "(", "show_yourself_near(house)", ")", "or", "finally", "(", "pass_by(trash_bin)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "pass", "by", "trash", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 7472, "sentence": ["snatch", "up", "pear", "and", "go", "to", "orange", "bin"], "tl": ["snatch_up(pear)", "and", "go_to(orange_bin)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch_up", "action_ref": "snatch up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange_bin)"], "args_ref": ["orange bin)"]}}, "prediction": "(and)"}
{"id": 5282, "sentence": ["put", "in", "bin", "or", "at", "any", "time", "gather", "pear"], "tl": ["put_in(bin)", "or", "finally", "(", "gather(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "any", "time", "gather", "pear", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}, "prop_2": {"action_canon": "gather", "action_ref": "gather", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_1) or gathering pears (prop_2). The phrase \"at any time\" indicates that this condition holds globally.\n\n2. *Explanation dictionary* \u2013\n{\n  \"put in bin\" : \"prop_1\",\n  \"gather pear\" : \"prop_2\",\n  \"at any time\" : \"G\"\n}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 6373, "sentence": ["when", "drop", "orange", ",", "pick", "up", "fruit"], "tl": ["drop(orange)", "imply", "pick_up(fruit)"], "masked_tl": ["prop_1", "imply", "prop_2"], "grounded_sentence": ["when", "prop_1", ",", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["fruit)"], "args_ref": ["fruit)"]}}, "prediction": "(drop orange) happens, then (pick up fruit) should happen.\" In temporal logic, this can be represented using the \"implies\" operator to show that the action of picking up fruit occurs after the action of dropping the orange.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when drop orange\" : \"prop_1\",\n  \"pick up fruit\" : \"prop_2\"\n}\n\n3. *FINAL:* prop_1 \u2192 F(prop_2)"}
{"id": 5359, "sentence": ["if", "at", "some", "time", "take", "possession", "of", "bear", ",", "venture", "to", "trash", "can"], "tl": ["finally", "(", "take_possession_of(bear)", ")", "imply", "venture_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["if", "at", "some", "time", "prop_1", ",", "venture", "to", "trash", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(prop_1), then we will venture to the trash can (prop_2)"}
{"id": 891, "sentence": ["collect", "pear", "or", "at", "any", "time", "contact", "house"], "tl": ["collect(pear)", "or", "finally", "(", "contact(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "any", "time", "contact", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or at any time\": \"G(prop_1 or prop_2)\""}
{"id": 2105, "sentence": ["when", "possible", "go", "visit", "house", "and", "move", "to", "trash", "can"], "tl": ["finally", "(", "go_visit(house)", ")", "and", "move_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(which can be interpreted as a condition that can be checked), the action of going to visit the house should occur, and after that, the action of moving to the trash can should also occur. This can be represented in temporal logic by stating that if it is possible (represented by a proposition), then the sequence of visiting the house and then moving to the trash can should happen.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible\" : \"prop_1\",\n  \"go visit house\" : \"prop_2\",\n  \"move to trash can\" : \"prop_3\"\n}\n\n3. *FINAL:* prop_1 \u2192 (prop_2 U prop_3)"}
{"id": 5548, "sentence": ["at", "any", "time", "venture", "house", "and", "whenever", "visit", "house"], "tl": ["finally", "(", "venture(house)", ")", "and", "finally", "(", "visit(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "whenever", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* G (prop_1) and G (prop_2 \u2192 prop_1) FINISH"}
{"id": 2348, "sentence": ["never", "drop", "apple", "and", "go", "by", "waste", "bin"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "and", "go_by(waste_bin)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "and", "prop_2"], "grounded_sentence": ["never", "prop_1", "and", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "(prop_1). The phrase \"and\" connects this with the action of going by the waste bin, which can be represented as a proposition (prop_2)"}
{"id": 4701, "sentence": ["at", "some", "time", "seize", "orange", "and", "take", "pear"], "tl": ["finally", "(", "seize(orange)", ")", "and", "take(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(F), both actions (represented by proposition placeholders) will happen. We can denote \"seize orange\" as prop_1 and \"take pear\" as prop_2. Therefore, the formula will express that at some point in the future, both actions will occur.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at some time\" : \"F\",\n  \"seize orange\" : \"prop_1\",\n  \"take pear\" : \"prop_2\"\n}\n\n3. *FINAL:* F(prop_1 and prop_2)"}
{"id": 3989, "sentence": ["at", "some", "time", "seize", "pear", "or", "hold", "on", "to", "pear"], "tl": ["finally", "(", "seize(pear)", ")", "or", "hold_on_to(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "hold_on_to", "action_ref": "hold on to", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 6649, "sentence": ["whenever", "withold", "apple", "or", "at", "any", "time", "reach", "tree"], "tl": ["finally", "(", "withold(apple)", ")", "or", "finally", "(", "reach(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withold", "action_ref": "withold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* prop_1 \u2192 F prop_2 FINISH"}
{"id": 365, "sentence": ["at", "any", "time", "advance", "to", "house", "or", "at", "any", "time", "touch", "tree"], "tl": ["finally", "(", "advance_to(house)", ")", "or", "finally", "(", "touch(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "any", "time", "touch", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 4126, "sentence": ["if", "when", "possible", "arrive", "at", "tree", ",", "take", "to", "trash", "can"], "tl": ["finally", "(", "arrive_at(tree)", ")", "imply", "take_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["if", "when", "possible", "prop_1", ",", "take", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "arrive_at", "action_ref": "arrive at", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(globally). The action \"arrive at tree\" can be represented as a proposition (prop_1), and the action \"take to trash can\" can be represented as another proposition (prop_2). The overall structure indicates that if it is possible to arrive at the tree, then the action of taking to the trash can should occur.\n\n2. *Explanation dictionary* \u2013\n{\n  \"if when possible arrive at tree\" : \"G (prop_1 \u2192 F prop_2)\",\n  \"take to trash can\" : \"prop_2\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 F prop_2)"}
{"id": 4223, "sentence": ["never", "drop", "orange", "or", "at", "any", "time", "spend", "time", "at", "tree"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "or", "finally", "(", "spend_time_at(tree)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "any", "time", "spend", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* G (not prop_1 and not prop_2) FINISH"}
{"id": 3192, "sentence": ["do", "not", "let", "go", "orange", "and", "get", "to", "tree"], "tl": ["negation", "(", "let_go(orange)", ")", "and", "get_to(tree)"], "masked_tl": ["negation", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["do", "not", "prop_1", "and", "get", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(globally), while \"get to tree\" can be seen as an action that should eventually happen (finally). Therefore, we can express this command in temporal logic as: globally, we should not let go of orange, and eventually, we should get to the tree.\n\n2. *Explanation dictionary* \u2013\n{\n  \"do not let go orange\": \"not prop_1\",\n  \"get to tree\": \"F prop_2\"\n}\n\n3. *FINAL:* G (not prop_1)"}
{"id": 1104, "sentence": ["at", "any", "time", "go", "near", "flag", "or", "when", "possible", "go", "visit", "house"], "tl": ["finally", "(", "go_near(flag)", ")", "or", "finally", "(", "go_visit(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "go", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 3946, "sentence": ["when", "possible", "present", "at", "flag", "or", "never", "drop", "apple"], "tl": ["finally", "(", "present_at(flag)", ")", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (F(prop_1) \u2192 G(prop_2)) or not prop_3 FINISH"}
{"id": 4330, "sentence": ["secure", "apple", "or", "never", "drop", "apple"], "tl": ["secure(apple)", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 or G not prop_2) FINISH"}
{"id": 4510, "sentence": ["when", "possible", "start", "going", "to", "house", "can", "infer", "that", "when", "possible", "grab", "flag"], "tl": ["finally", "(", "start_going_to(house)", ")", "imply", "finally", "(", "grab(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "can", "infer", "that", "when", "possible", "grab", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* F prop_1 \u2192 F prop_2 FINISH"}
{"id": 193, "sentence": ["at", "some", "time", "be", "near", "tree", "and", "at", "any", "time", "stop", "by", "trash", "can"], "tl": ["finally", "(", "be_near(tree)", ")", "and", "finally", "(", "stop_by(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "any", "time", "stop", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(representing \"be near tree\") is true. The second part, \"at any time stop by trash can,\" indicates that at all times, the proposition `prop_2` (representing \"stop by trash can\")"}
{"id": 5422, "sentence": ["whenever", "visit", "house", "or", "never", "drop", "orange"], "tl": ["finally", "(", "visit(house)", ")", "or", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 \u2192 not prop_2) FINISH"}
{"id": 6425, "sentence": ["whenever", "migrate", "to", "tree", "or", "reach", "house"], "tl": ["finally", "(", "migrate_to(tree)", ")", "or", "reach(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "reach", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "migrate_to", "action_ref": "migrate to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 4407, "sentence": ["whenever", "be", "in", "house's", "vicinity", "or", "at", "any", "time", "snag", "orange"], "tl": ["finally", "(", "be_in(house's_vicinity)", ")", "or", "finally", "(", "snag(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "snag", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_in", "action_ref": "be in", "args_canon": ["house's_vicinity)"], "args_ref": ["house's vicinity)"]}, "prop_2": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "    \"or\" : \"or\","}
{"id": 2820, "sentence": ["venture", "towards", "house", "or", "at", "some", "time", "present", "at", "flag"], "tl": ["venture_towards(house)", "or", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "present", "at", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(or) and the temporal operator for eventuality (finally).\n\n2. *Explanation dictionary* \u2013\n{\n  \"venture towards house\" : prop_1,\n  \"present at flag\" : prop_2\n}\n\n3. *FINAL:* prop_1 or F(prop_2)"}
{"id": 4469, "sentence": ["at", "some", "time", "go", "past", "house", "or", "repeatedly", "make", "way", "to", "house"], "tl": ["finally", "(", "go_past(house)", ")", "or", "globally", "(", "finally", "(", "make_way_to(house)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "repeatedly", "make", "way", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_past", "action_ref": "go past", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "make_way_to", "action_ref": "make way to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 5825, "sentence": ["when", "possible", "proceed", "to", "flag", "and", "at", "some", "time", "make", "contact", "with", "house"], "tl": ["finally", "(", "proceed_to(flag)", ")", "and", "finally", "(", "make_contact_with(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "some", "time", "make", "contact", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(prop_1 \u2192 X prop_2)\",\n  \"proceed to flag\" : \"prop_2\",\n  \"at some time make contact with house\" : \"F prop_3\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 X prop_2)"}
{"id": 5358, "sentence": ["do", "not", "let", "go", "pear", "and", "at", "some", "time", "procure", "orange"], "tl": ["negation", "(", "let_go(pear)", ")", "and", "finally", "(", "procure(orange)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["do", "not", "prop_1", "and", "at", "some", "time", "procure", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(not letting go of the pear), while the second part indicates that at some point in the future, the action of procuring an orange should occur. We can represent \"not let go pear\" as `not prop_1` and \"procure orange\" as `prop_2`. The phrase \"at some time\" translates to the temporal operator \"finally\" (F)"}
{"id": 4281, "sentence": ["at", "some", "time", "getting", "pear", "and", "hold", "orange"], "tl": ["finally", "(", "getting(pear)", ")", "and", "hold(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "getting", "action_ref": "getting", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"and hold orange\": \"and prop_2\""}
{"id": 7452, "sentence": ["if", "at", "some", "time", "go", "to", "trash", "receptacle", ",", "grasp", "orange"], "tl": ["finally", "(", "go_to(trash_receptacle)", ")", "imply", "grasp(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["if", "at", "some", "time", "prop_1", ",", "grasp", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 0, 1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_receptacle)"], "args_ref": ["trash receptacle)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(F) to indicate that at some point in the future, the actions will occur. The actions themselves can be represented as propositions, such as prop_1 for \"go to trash receptacle\" and prop_2 for \"grasp orange.\" The overall structure will be that if the condition is met, then both actions will follow.\n\n2. *Explanation dictionary* \u2013\n{\n  \"if at some time\" : \"F\",\n  \"go to trash receptacle\" : \"prop_1\",\n  \"grasp orange\" : \"prop_2\"\n}\n\n3. *FINAL:* F \u2192 (prop_1 and prop_2)"}
{"id": 2544, "sentence": ["when", "possible", "reach", "tree", "or", "whenever", "seize", "orange"], "tl": ["finally", "(", "reach(tree)", ")", "or", "finally", "(", "seize(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "whenever", "seize", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 1277, "sentence": ["when", "possible", "visit", "flag", "and", "when", "possible", "go", "to", "trash", "bin"], "tl": ["finally", "(", "visit(flag)", ")", "and", "finally", "(", "go_to(trash_bin)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "(F)"}
{"id": 2250, "sentence": ["get", "to", "tree", "or", "always", "hold", "on", "pear"], "tl": ["get_to(tree)", "or", "globally", "(", "hold_on(pear)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "always", "hold", "on", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "hold_on", "action_ref": "hold on", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(tree) while globally maintaining the state represented by prop_2 (pear)"}
{"id": 4662, "sentence": ["never", "drop", "pear", "or", "whenever", "grasp", "pear"], "tl": ["globally", "(", "negation", "(", "drop(pear)", ")", ")", "or", "finally", "(", "grasp(pear)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "whenever", "grasp", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* G (not prop_1) and (prop_2 \u2192 not prop_1) FINISH"}
{"id": 6094, "sentence": ["when", "possible", "withdraw", "pear", "or", "always", "hold", "on", "pear"], "tl": ["finally", "(", "withdraw(pear)", ")", "or", "globally", "(", "hold_on(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "always", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withdraw", "action_ref": "withdraw", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "hold_on", "action_ref": "hold on", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 5274, "sentence": ["whenever", "secure", "pear", "or", "when", "possible", "go", "visit", "house"], "tl": ["finally", "(", "secure(pear)", ")", "or", "finally", "(", "go_visit(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_1 \u2192 F (prop_2)) FINISH"}
{"id": 5856, "sentence": ["repeatedly", "go", "to", "waste", "basket", "or", "at", "any", "time", "proceed", "to", "flag"], "tl": ["globally", "(", "finally", "(", "go_to(waste_basket)", ")", ")", "or", "finally", "(", "proceed_to(flag)", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "at", "any", "time", "proceed", "to", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 4755, "sentence": ["never", "let", "go", "orange", "or", "when", "possible", "have", "possession", "of", "apple"], "tl": ["globally", "(", "negation", "(", "let_go(orange)", ")", ")", "or", "finally", "(", "have_possession_of(apple)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "when", "possible", "have", "possession", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "have_possession_of", "action_ref": "have possession of", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* G (not prop_1) and (F prop_2) FINISH"}
{"id": 2302, "sentence": ["whenever", "venture", "to", "waste", "basket", "or", "at", "any", "time", "tax", "apple"], "tl": ["finally", "(", "venture_to(waste_basket)", ")", "or", "finally", "(", "tax(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "tax", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 4022, "sentence": ["travel", "to", "tree", "and", "when", "possible", "approach", "flag"], "tl": ["travel_to(tree)", "and", "finally", "(", "approach(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "approach", "flag", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1) that indicates the action of traveling to the tree. The second part indicates that the action of approaching the flag (prop_2) should occur when it is possible, which can be represented using the \"finally\" operator (F)"}
{"id": 423, "sentence": ["whenever", "contact", "flag", "or", "at", "any", "time", "move", "past", "trash", "can"], "tl": ["finally", "(", "contact(flag)", ")", "or", "finally", "(", "move_past(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "move_past", "action_ref": "move past", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 3228, "sentence": ["drop", "pear", "or", "at", "some", "time", "clutch", "orange"], "tl": ["drop(pear)", "or", "finally", "(", "clutch(orange)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "clutch", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "clutch", "action_ref": "clutch", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 3685, "sentence": ["whenever", "withdraw", "pear", "or", "at", "some", "time", "move", "near", "tree"], "tl": ["finally", "(", "withdraw(pear)", ")", "or", "finally", "(", "move_near(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "some", "time", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withdraw", "action_ref": "withdraw", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "move_near", "action_ref": "move near", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(prop_1 \u2192 F prop_2)\",\n  \"or at some time move near tree\" : \"F prop_2\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 F prop_2)"}
{"id": 4316, "sentence": ["when", "possible", "go", "to", "trashcan", "and", "travel", "to", "apple"], "tl": ["finally", "(", "go_to(trashcan)", ")", "and", "travel_to(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* prop_1 \u2192 (prop_2 and prop_3) FINISH"}
{"id": 4727, "sentence": ["when", "possible", "present", "at", "flag", "until", "when", "possible", "reach", "flag"], "tl": ["finally", "(", "present_at(flag)", ")", "until", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "until", "when", "possible", "reach", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(F prop_2)"}
{"id": 6051, "sentence": ["secure", "apple", "or", "venture", "towards", "house"], "tl": ["secure(apple)", "or", "venture_towards(house)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "venture", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\": or"}
{"id": 3453, "sentence": ["when", "possible", "reach", "flag", "can", "infer", "that", "when", "possible", "bring", "pear"], "tl": ["finally", "(", "reach(flag)", ")", "imply", "finally", "(", "bring(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "can", "infer", "that", "when", "possible", "bring", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_1 \u2192 prop_2)"}
{"id": 3222, "sentence": ["at", "any", "time", "go", "by", "waste", "basket", "or", "venture", "towards", "house"], "tl": ["finally", "(", "go_by(waste_basket)", ")", "or", "venture_towards(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "venture", "towards", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 260, "sentence": ["go", "by", "waste", "bin", "until", "go", "by", "waste", "bin"], "tl": ["go_by(waste_bin)", "until", "go_by(waste_bin)"], "masked_tl": ["prop_2", "until", "prop_2"], "grounded_sentence": ["prop_1", "until", "go", "by", "waste", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "3. *FINAL:* prop_1 U prop_1 FINISH"}
{"id": 2518, "sentence": ["at", "some", "time", "get", "hold", "apple", "or", "at", "some", "time", "seize", "orange"], "tl": ["finally", "(", "get_hold(apple)", ")", "or", "finally", "(", "seize(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "seize", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(represented by prop_1) will occur, or the action of seizing an orange (represented by prop_2) will occur. The phrase \"at some time\" suggests the use of the \"finally\" operator (F), which indicates that one of these actions will eventually happen.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at some time get hold apple\": \"F prop_1\",\n  \"at some time seize orange\": \"F prop_2\"\n}\n\n3. *FINAL:* F (prop_1 or prop_2)"}
{"id": 2963, "sentence": ["forever", "moving", "or", "whenever", "venture", "flag"], "tl": ["globally", "(", "moving", ")", "or", "finally", "(", "venture(flag)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "whenever", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "moving", "action_ref": "moving", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* G prop_1 or (prop_2 \u2192 prop_3) FINISH"}
{"id": 5389, "sentence": ["at", "some", "time", "go", "by", "house", "and", "whenever", "grasp", "pear"], "tl": ["finally", "(", "go_by(house)", ")", "and", "finally", "(", "grasp(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "whenever", "grasp", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* F(prop_1) and (prop_2 \u2192 G(prop_1)) FINISH"}
{"id": 6293, "sentence": ["when", "possible", "venture", "flag", "or", "at", "any", "time", "stop", "by", "house"], "tl": ["finally", "(", "venture(flag)", ")", "or", "finally", "(", "stop_by(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "stop", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 4675, "sentence": ["travel", "to", "tree", "or", "at", "any", "time", "go", "home"], "tl": ["travel_to(tree)", "or", "finally", "(", "go(home)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "any", "time", "go", "home", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "3. *FINAL:* (prop_1 or G(prop_2)) FINISH"}
{"id": 3471, "sentence": ["at", "some", "time", "present", "at", "flag", "until", "at", "some", "time", "go", "by", "waste", "basket"], "tl": ["finally", "(", "present_at(flag)", ")", "until", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "at", "some", "time", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(prop_1)\",\n  \"at flag\" : \"prop_2\",\n  \"until\" : \"U\",\n  \"at some time go by waste basket\" : \"prop_3\"\n}\n\n3. *FINAL:* F(prop_2)"}
{"id": 347, "sentence": ["whenever", "show", "yourself", "near", "house", "and", "pick", "up", "orange"], "tl": ["finally", "(", "show_yourself_near(house)", ")", "and", "pick_up(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "pick", "up", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 and prop_2) \u2192 prop_3 FINISH"}
{"id": 3431, "sentence": ["when", "don't", "let", "go", "orange", ",", "when", "possible", "lay", "hold", "of", "apple"], "tl": ["negation", "(", "let_go(orange)", ")", "imply", "finally", "(", "lay_hold_of(apple)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "don't", "prop_1", ",", "when", "possible", "lay", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "lay_hold_of", "action_ref": "lay hold of", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(not prop_1)"}
{"id": 2521, "sentence": ["capture", "orange", "or", "at", "some", "time", "secure", "pear"], "tl": ["capture(orange)", "or", "finally", "(", "secure(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "secure", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "    \"or\" : \"or\","}
{"id": 3592, "sentence": ["at", "some", "time", "withhold", "apple", "and", "at", "some", "time", "reach", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "some", "time", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1), and the second part \"reach flag\" can be represented as another proposition (prop_2). Since both actions need to happen at some point in the future, we can use the \"finally\" operator (F) to indicate that each action will eventually occur.\n\n2. *Explanation dictionary* \u2013\n{\n  \"withhold apple\": \"prop_1\",\n  \"reach flag\": \"prop_2\"\n}\n\n3. *FINAL:* F(prop_1) and F(prop_2)"}
{"id": 3804, "sentence": ["keep", "apple", "until", "at", "any", "time", "start", "going", "to", "house"], "tl": ["keep(apple)", "until", "finally", "(", "start_going_to(house)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "any", "time", "start", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "keep", "action_ref": "keep", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* prop_1 U prop_2 FINISH"}
{"id": 5352, "sentence": ["at", "any", "time", "journey", "to", "flag", "or", "forever", "hold", "onto", "orange"], "tl": ["finally", "(", "journey_to(flag)", ")", "or", "globally", "(", "hold_onto(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "forever", "hold", "onto", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 6684, "sentence": ["hold", "orange", "or", "go", "to", "bucket"], "tl": ["hold(orange)", "or", "go_to(bucket)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 3940, "sentence": ["venture", "to", "trash", "can", "or", "hold", "pear"], "tl": ["venture_to(trash_can)", "or", "hold(pear)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "hold", "pear", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 4973, "sentence": ["snatch", "up", "pear", "and", "get", "to", "tree"], "tl": ["snatch_up(pear)", "and", "get_to(tree)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "get", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch_up", "action_ref": "snatch up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* prop_1 and prop_2 FINISH"}
{"id": 6886, "sentence": ["at", "any", "time", "take", "possession", "of", "bear", "or", "when", "possible", "travel", "to", "house"], "tl": ["finally", "(", "take_possession_of(bear)", ")", "or", "finally", "(", "travel_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "travel", "to", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 612, "sentence": ["do", "not", "let", "go", "pear", "or", "at", "any", "time", "venture", "flag"], "tl": ["negation", "(", "let_go(pear)", ")", "or", "finally", "(", "venture(flag)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["do", "not", "prop_1", "or", "at", "any", "time", "venture", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(not letting go of the pear) or the second condition can occur at any time, which can be expressed using the \"finally\" operator (F)"}
{"id": 1739, "sentence": ["at", "any", "time", "set", "out", "to", "house", "or", "go", "visit", "flag"], "tl": ["finally", "(", "set_out_to(house)", ")", "or", "go_visit(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "go", "visit", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "set_out_to", "action_ref": "set out to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 3961, "sentence": ["at", "some", "time", "go", "to", "trashcan", "or", "keep", "apple"], "tl": ["finally", "(", "go_to(trashcan)", ")", "or", "keep(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "keep", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "keep", "action_ref": "keep", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 7433, "sentence": ["if", "always", "have", "in", "orange", ",", "at", "any", "time", "journey", "by", "flag"], "tl": ["globally", "(", "have_in(orange)", ")", "imply", "finally", "(", "journey_by(flag)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "always", "prop_1", ",", "at", "any", "time", "journey", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_2 \u2192 prop_1)"}
{"id": 3580, "sentence": ["when", "possible", "go", "to", "trash", "can", "and", "at", "any", "time", "journey", "to", "flag"], "tl": ["finally", "(", "go_to(trash_can)", ")", "and", "finally", "(", "journey_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "any", "time", "journey", "to", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"and\" : \"and\","}
{"id": 1776, "sentence": ["at", "some", "time", "have", "pear", "or", "at", "any", "time", "start", "going", "to", "house"], "tl": ["finally", "(", "have(pear)", ")", "or", "finally", "(", "start_going_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "any", "time", "start", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F) for the events that can happen at some time and the \"globally\" operator (G)"}
{"id": 3071, "sentence": ["secure", "apple", "or", "at", "some", "time", "withhold", "apple"], "tl": ["secure(apple)", "or", "finally", "(", "withhold(apple)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "withhold", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 53, "sentence": ["always", "touch", "flag", "or", "at", "any", "time", "go", "to", "trash", "bin"], "tl": ["globally", "(", "touch(flag)", ")", "or", "finally", "(", "go_to(trash_bin)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "or", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 3691, "sentence": ["at", "any", "time", "lay", "hold", "of", "apple", "or", "go", "to", "orange", "bin"], "tl": ["finally", "(", "lay_hold_of(apple)", ")", "or", "go_to(orange_bin)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "go", "to", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "lay_hold_of", "action_ref": "lay hold of", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange_bin)"], "args_ref": ["orange bin)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 4782, "sentence": ["at", "any", "time", "snag", "orange", "and", "approach", "trash", "can"], "tl": ["finally", "(", "snag(orange)", ")", "and", "approach(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "approach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "  \"and\" : \"and\""}
{"id": 7024, "sentence": ["at", "some", "time", "travel", "to", "trash", "can", "or", "at", "any", "time", "get", "hold", "apple"], "tl": ["finally", "(", "travel_to(trash_can)", ")", "or", "finally", "(", "get_hold(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "any", "time", "get", "hold", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* F prop_1 or F prop_2 FINISH"}
{"id": 361, "sentence": ["at", "some", "time", "withhold", "apple", "or", "at", "some", "time", "present", "at", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "or", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "present", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "    \"or\" : \"or\""}
{"id": 6586, "sentence": ["move", "to", "trashcan", "or", "when", "possible", "migrate", "to", "tree"], "tl": ["move_to(trashcan)", "or", "finally", "(", "migrate_to(tree)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "migrate", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "migrate_to", "action_ref": "migrate to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"or when possible\" : (prop_1 or F(prop_2))"}
{"id": 2331, "sentence": ["never", "let", "go", "or", "at", "any", "time", "go", "to", "tree"], "tl": ["globally", "(", "negation", "(", "let_go", ")", ")", "or", "finally", "(", "go_to(tree)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* not prop_2 G (not prop_2) FINISH"}
{"id": 6639, "sentence": ["when", "possible", "show", "yourself", "near", "house", "and", "when", "possible", "pick", "up", "apple"], "tl": ["finally", "(", "show_yourself_near(house)", ")", "and", "finally", "(", "pick_up(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "pick", "up", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1)\" where \"prop_1\" indicates the condition of showing oneself near the house. The second part is \"pick up apple\", represented as \"F (prop_2)\" where \"prop_2\" indicates the action of picking up an apple. Since both actions should occur when possible, we can combine them with an \"and\" operator.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible show yourself near house\": \"F (prop_1)\",\n  \"when possible pick up apple\": \"F (prop_2)\"\n}\n\n3. *FINAL:* F (prop_1) and F (prop_2)"}
{"id": 5343, "sentence": ["reach", "house", "or", "when", "possible", "journey", "by", "flag"], "tl": ["reach(house)", "or", "finally", "(", "journey_by(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "journey", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* prop_1 or (not prop_1 and prop_2) FINISH"}
{"id": 5509, "sentence": ["come", "to", "tree", "or", "forever", "have", "in", "orange"], "tl": ["come_to(tree)", "or", "globally", "(", "have_in(orange)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "forever", "have", "in", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "come_to", "action_ref": "come to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(represented by a proposition placeholder, e.g., prop_1) occurs or, if that does not happen, the state of having something in orange (represented by another proposition placeholder, e.g., prop_2) must hold forever. This can be expressed using the logical operators for disjunction (or) and globally (G)"}
{"id": 2727, "sentence": ["approach", "tree", "or", "whenever", "make", "way", "for", "tree"], "tl": ["approach(tree)", "or", "finally", "(", "make_way_for(tree)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "make", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "make_way_for", "action_ref": "make way for", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 5477, "sentence": ["at", "any", "time", "withhold", "apple", "or", "whenever", "present", "at", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "or", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "whenever", "present", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(at all times), if the condition of being present at the flag (prop_2) holds, then the action of withholding the apple (prop_1) should also hold.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time\" : \"G\",\n  \"withhold apple\" : \"prop_1\",\n  \"whenever present at flag\" : \"prop_2\"\n}\n\n3. *FINAL:* G (prop_2 \u2192 prop_1)"}
{"id": 6082, "sentence": ["at", "some", "time", "get", "apple", "or", "take", "orange"], "tl": ["finally", "(", "get(apple)", ")", "or", "take(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 1246, "sentence": ["at", "some", "time", "make", "to", "flag", "or", "come", "to", "tree"], "tl": ["finally", "(", "make_to(flag)", ")", "or", "come_to(tree)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "come", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_to", "action_ref": "make to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "come_to", "action_ref": "come to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 2732, "sentence": ["go", "to", "orange", "bin", "until", "whenever", "migrate", "to", "tree"], "tl": ["go_to(orange_bin)", "until", "finally", "(", "migrate_to(tree)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "whenever", "migrate", "to", "tree", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange_bin)"], "args_ref": ["orange bin)"]}, "prop_2": {"action_canon": "migrate_to", "action_ref": "migrate to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(let's say prop_1) and the condition of migrating to the tree is represented by another proposition (let's say prop_2)"}
{"id": 2199, "sentence": ["when", "possible", "journey", "by", "flag", "and", "at", "some", "time", "spend", "time", "at", "tree"], "tl": ["finally", "(", "journey_by(flag)", ")", "and", "finally", "(", "spend_time_at(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "some", "time", "spend", "time", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(prop_2 \u2192 F prop_3)"}
{"id": 3938, "sentence": ["whenever", "show", "yourself", "near", "house", "and", "when", "possible", "take", "possession", "of", "bear"], "tl": ["finally", "(", "show_yourself_near(house)", ")", "and", "finally", "(", "take_possession_of(bear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "when", "possible", "take", "possession", "of", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}}, "prediction": "  \"and\" : \"\u2192\""}
{"id": 2541, "sentence": ["procure", "apple", "and", "pick", "up", "orange"], "tl": ["procure(apple)", "and", "pick_up(orange)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "pick", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"and\": \"and\""}
{"id": 5634, "sentence": ["at", "any", "time", "go", "near", "house", "and", "at", "any", "time", "grab", "flag"], "tl": ["finally", "(", "go_near(house)", ")", "and", "finally", "(", "grab(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "any", "time", "grab", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1 and prop_2)"}
{"id": 3909, "sentence": ["always", "have", "apple", "and", "at", "some", "time", "acquire", "pear"], "tl": ["globally", "(", "have(apple)", ")", "and", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "and", "at", "some", "time", "acquire", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(globally), the condition of having an apple must hold true, and at some point in the future (eventually), the condition of acquiring a pear must also hold true. This can be expressed in temporal logic as: G (prop_1) and F (prop_2), where prop_1 represents \"having an apple\" and prop_2 represents \"acquiring a pear\".\n\n2. *Explanation dictionary* \u2013\n{\n  \"always have apple\": \"G(prop_1)\",\n  \"at some time acquire pear\": \"F(prop_2)\"\n}\n\n3. *FINAL:* G(prop_1) and F(prop_2)"}
{"id": 6198, "sentence": ["grasp", "orange", "or", "at", "some", "time", "getting", "pear"], "tl": ["grasp(orange)", "or", "finally", "(", "getting(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "getting", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "getting", "action_ref": "getting", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(represented by prop_1) or the action of getting a pear (represented by prop_2) should occur. The phrase \"at some time\" suggests the use of the \"finally\" operator (F), which indicates that one of the two actions will eventually happen.\n\n2. *Explanation dictionary* \u2013\n{\n  \"grasp orange\": \"prop_1\",\n  \"getting pear\": \"prop_2\",\n  \"at some time\": \"F\"\n}\n\n3. *FINAL:* F(prop_1 or prop_2)"}
{"id": 3269, "sentence": ["whenever", "steal", "apple", "or", "go", "to", "bucket"], "tl": ["finally", "(", "steal(apple)", ")", "or", "go_to(bucket)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "steal", "action_ref": "steal", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}}, "prediction": "(G) to indicate that this condition must always be true. The logical structure is that if either of the propositions (prop_1 for \"steal apple\" and prop_2 for \"go to bucket\") is true, then the overall condition must hold.\n\n2. *Explanation dictionary* \u2013\n{\n  \"whenever steal apple or go to bucket\" : \"G (prop_1 or prop_2)\"\n}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 2095, "sentence": ["when", "possible", "secure", "pear", "or", "never", "drop", "apple"], "tl": ["finally", "(", "secure(pear)", ")", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* F prop_1 or not prop_2 FINISH"}
{"id": 343, "sentence": ["hold", "apple", "and", "at", "any", "time", "obtain", "apple"], "tl": ["hold(apple)", "and", "finally", "(", "obtain(apple)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "any", "time", "obtain", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1), and \"at any time obtain apple\" can be represented as \"eventually obtain apple\" (prop_2)"}
{"id": 4393, "sentence": ["when", "possible", "withold", "apple", "or", "when", "possible", "get", "apple"], "tl": ["finally", "(", "withold(apple)", ")", "or", "finally", "(", "get(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "get", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withold", "action_ref": "withold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "get", "action_ref": "get", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1)\" where prop_1 represents the action of withholding the apple. The second condition states that when it is possible, we should get the apple, represented as \"F (prop_2)\" where prop_2 represents the action of getting the apple. The overall command can be expressed as the disjunction of these two conditions.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible withhold apple\": \"F (prop_1)\",\n  \"when possible get apple\": \"F (prop_2)\"\n}\n\n3. *FINAL:* F (prop_1) or F (prop_2)"}
{"id": 865, "sentence": ["at", "any", "time", "secure", "pear", "until", "visit", "tree"], "tl": ["finally", "(", "secure(pear)", ")", "until", "visit(tree)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "until", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* prop_1 U prop_2 FINISH"}
{"id": 3649, "sentence": ["whenever", "grab", "apple", "until", "at", "any", "time", "grasp", "apple"], "tl": ["finally", "(", "grab(apple)", ")", "until", "finally", "(", "grasp(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "until", "at", "any", "time", "grasp", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1)\",\n  \"until at any time grasp apple\" : \"U (prop_2)\"\n}\n\n3. *FINAL:* G (prop_1) U (prop_2)"}
{"id": 627, "sentence": ["at", "any", "time", "travel", "to", "house", "and", "when", "possible", "travel", "house"], "tl": ["finally", "(", "travel_to(house)", ")", "and", "finally", "(", "travel(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "when", "possible", "travel", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel", "action_ref": "travel", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* G prop_1 and (prop_2 \u2192 prop_1) FINISH"}
{"id": 1569, "sentence": ["repeatedly", "go", "to", "pear", "and", "put", "in", "bin"], "tl": ["globally", "(", "finally", "(", "go_to(pear)", ")", ")", "and", "put_in(bin)"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "and", "prop_2"], "grounded_sentence": ["repeatedly", "prop_1", "and", "put", "in", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}}, "prediction": "  \"and\" : \"and\""}
{"id": 1040, "sentence": ["hold", "on", "to", "pear", "or", "whenever", "reach", "tree"], "tl": ["hold_on_to(pear)", "or", "finally", "(", "reach(tree)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "reach", "tree", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold_on_to", "action_ref": "hold on to", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"whenever reach tree\": \"prop_2 \u2192 globally(prop_1)\""}
{"id": 568, "sentence": ["whenever", "tax", "apple", "or", "when", "possible", "go", "to", "apple"], "tl": ["finally", "(", "tax(apple)", ")", "or", "finally", "(", "go_to(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(tax \u2192 apple) \u2227 G (possible \u2192 go_to_apple)"}
{"id": 7086, "sentence": ["repeatedly", "go", "to", "pear", "or", "whenever", "procure", "pear"], "tl": ["globally", "(", "finally", "(", "go_to(pear)", ")", ")", "or", "finally", "(", "procure(pear)", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "whenever", "procure", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* G (prop_1 \u2192 X prop_1) and (prop_2 \u2192 prop_1) FINISH"}
{"id": 6475, "sentence": ["do", "not", "let", "go", "pear", "and", "repeatedly", "grab", "tree"], "tl": ["negation", "(", "let_go(pear)", ")", "and", "globally", "(", "finally", "(", "grab(tree)", ")", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "and", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["do", "not", "prop_1", "and", "repeatedly", "grab", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* not prop_1 and G prop_2 FINISH"}
{"id": 3083, "sentence": ["whenever", "venture", "flag", "or", "travel", "to", "apple"], "tl": ["finally", "(", "venture(flag)", ")", "or", "travel_to(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1)\",\n  \"or travel to apple\" : \"or prop_2\"\n}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 6294, "sentence": ["put", "in", "bucket", "or", "at", "any", "time", "go", "to", "tree"], "tl": ["put_in(bucket)", "or", "finally", "(", "go_to(tree)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "any", "time", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 2139, "sentence": ["whenever", "visit", "house", "or", "whenever", "start", "going", "to", "tree"], "tl": ["finally", "(", "visit(house)", ")", "or", "finally", "(", "start_going_to(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "start", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 3045, "sentence": ["whenever", "contact", "house", "or", "stop", "by", "flag"], "tl": ["finally", "(", "contact(house)", ")", "or", "stop_by(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "stop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* G ( (prop_1 or prop_2) \u2192 prop_3 ) FINISH"}
{"id": 186, "sentence": ["when", "possible", "withhold", "apple", "and", "when", "possible", "withhold", "apple"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "finally", "(", "withhold(apple)", ")"], "masked_tl": ["finally", "(", "prop_2", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "withhold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(eventually withholding the apple)"}
{"id": 3661, "sentence": ["at", "any", "time", "walk", "to", "flag", "or", "never", "let", "go", "apple"], "tl": ["finally", "(", "walk_to(flag)", ")", "or", "globally", "(", "negation", "(", "let_go(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "never", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* G (prop_1 or not prop_2) FINISH"}
{"id": 5291, "sentence": ["when", "when", "possible", "let", "go", "apple", ",", "at", "some", "time", "move", "to", "flag"], "tl": ["finally", "(", "let_go(apple)", ")", "imply", "finally", "(", "move_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "when", "possible", "prop_1", ",", "at", "some", "time", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1) leads to the action of moving to the flag (prop_2) at some time in the future (F).\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible\" : \"prop_1\",\n  \"let go apple\" : \"prop_1\",\n  \"at some time move to flag\" : \"F(prop_2)\"\n}\n\n3. *FINAL:* prop_1 \u2192 F(prop_2)"}
{"id": 4919, "sentence": ["never", "let", "go", "apple", "or", "approach", "tree"], "tl": ["globally", "(", "negation", "(", "let_go(apple)", ")", ")", "or", "approach(tree)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "prop_2"], "grounded_sentence": ["never", "prop_1", "or", "approach", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* G (not prop_1 and not prop_2) FINISH"}
{"id": 6710, "sentence": ["at", "any", "time", "approach", "flag", "or", "put", "in", "apple", "bucket"], "tl": ["finally", "(", "approach(flag)", ")", "or", "put_in(apple_bucket)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "put", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["apple_bucket)"], "args_ref": ["apple bucket)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 2394, "sentence": ["when", "possible", "get", "close", "tree", "or", "at", "any", "time", "grab", "orange"], "tl": ["finally", "(", "get_close(tree)", ")", "or", "finally", "(", "grab(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "grab", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(F). The action of getting close to the tree can be represented as prop_1, and grabbing the orange can be represented as prop_2. The \"or\" indicates that either action can occur, so we will use the \"or\" operator to combine them.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible\" : \"F\",\n  \"get close to tree\" : \"prop_1\",\n  \"at any time\" : \"G\",\n  \"grab orange\" : \"prop_2\"\n}\n\n3. *FINAL:* F(prop_1 or G(prop_2))"}
{"id": 6256, "sentence": ["when", "possible", "be", "near", "tree", "and", "at", "some", "time", "procure", "orange"], "tl": ["finally", "(", "be_near(tree)", ")", "and", "finally", "(", "procure(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "some", "time", "procure", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(F). The action of procuring an orange can be represented as a proposition (prop_1). Therefore, the complete formula states that it is possible to be near the tree (prop_2) and eventually procure an orange (prop_1).\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible\" : \"F\",\n  \"be near tree\" : \"prop_2\",\n  \"at some time procure orange\" : \"prop_1\"\n}\n\n3. *FINAL:* F(prop_2) \u2192 F(prop_1)"}
{"id": 1829, "sentence": ["approach", "tree", "or", "at", "some", "time", "acquire", "pear"], "tl": ["approach(tree)", "or", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "acquire", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 7284, "sentence": ["always", "have", "apple", "or", "whenever", "go", "to", "flag"], "tl": ["globally", "(", "have(apple)", ")", "or", "finally", "(", "go_to(flag)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "or", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_2 \u2192 prop_3)\" where prop_2 represents \"go\" and prop_3 represents \"to flag\". The entire command combines these two parts with an \"or\" operator.\n\n2. *Explanation dictionary* \u2013\n{\n  \"always have apple\": \"G prop_1\",\n  \"or whenever go to flag\": \"F (prop_2 \u2192 prop_3)\"\n}\n\n3. *FINAL:* G prop_1 or F (prop_2 \u2192 prop_3)"}
{"id": 6252, "sentence": ["pick", "up", "flag", "or", "always", "hold", "onto", "orange"], "tl": ["pick_up(flag)", "or", "globally", "(", "hold_onto(orange)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "always", "hold", "onto", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 724, "sentence": ["when", "possible", "touch", "tree", "and", "reach", "trash", "can"], "tl": ["finally", "(", "touch(tree)", ")", "and", "reach(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "  \"and\" : \"and\""}
{"id": 3121, "sentence": ["when", "possible", "reach", "flag", "and", "venture", "towards", "house"], "tl": ["finally", "(", "reach(flag)", ")", "and", "venture_towards(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(represented by a proposition), then the action of venturing towards the house should follow. The phrase \"when possible\" indicates a condition that can be expressed using the \"finally\" operator, meaning that at some point in the future, the condition of reaching the flag should lead to venturing towards the house.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible\" : \"F\",\n  \"reach flag\" : \"prop_1\",\n  \"venture towards house\" : \"prop_2\"\n}\n\n3. *FINAL:* F(prop_1 \u2192 prop_2)"}
{"id": 2991, "sentence": ["at", "some", "time", "go", "near", "house", "or", "keep", "apple"], "tl": ["finally", "(", "go_near(house)", ")", "or", "keep(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "keep", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "keep", "action_ref": "keep", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(logical OR) of the two actions, both of which can be represented by proposition placeholders.\n\n2. *Explanation dictionary* \u2013\n{\n    \"go near house\": \"prop_1\",\n    \"keep apple\": \"prop_2\",\n    \"at some time\": \"F\"\n}\n\n3. *FINAL:* F(prop_1 or prop_2)"}
{"id": 784, "sentence": ["at", "some", "time", "go", "by", "waste", "basket", "and", "whenever", "reach", "flag"], "tl": ["finally", "(", "go_by(waste_basket)", ")", "and", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "whenever", "reach", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(going by the waste basket), and this action should happen whenever the condition of reaching the flag is met. This can be expressed using the \"finally\" operator for the initial action and the \"globally\" operator for the condition that follows.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at some time go by waste basket\" : \"F prop_1\",\n  \"whenever reach flag\" : \"G (prop_2 \u2192 prop_1)\"\n}\n\n3. *FINAL:* F prop_1 and G (prop_2 \u2192 prop_1)"}
{"id": 3362, "sentence": ["whenever", "advance", "to", "house", "or", "at", "some", "time", "take", "possession", "of", "bear"], "tl": ["finally", "(", "advance_to(house)", ")", "or", "finally", "(", "take_possession_of(bear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "some", "time", "take", "possession", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 1912, "sentence": ["never", "let", "go", "or", "whenever", "grab", "orange"], "tl": ["globally", "(", "negation", "(", "let_go", ")", ")", "or", "finally", "(", "grab(orange)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "whenever", "grab", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* G (not prop_1 or prop_2) FINISH"}
{"id": 2889, "sentence": ["whenever", "go", "to", "trash", "can", "or", "take", "apple"], "tl": ["finally", "(", "go_to(trash_can)", ")", "or", "take(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "take", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 6174, "sentence": ["forever", "have", "apple", "or", "at", "any", "time", "travel", "to", "flag"], "tl": ["globally", "(", "have(apple)", ")", "or", "finally", "(", "travel_to(flag)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "at", "any", "time", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(forever)"}
{"id": 3048, "sentence": ["when", "possible", "grasp", "pear", "can", "infer", "that", "whenever", "go", "to", "flag"], "tl": ["finally", "(", "grasp(pear)", ")", "imply", "finally", "(", "go_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "can", "infer", "that", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* prop_1 \u2192 (G (prop_2 \u2192 prop_1)) FINISH"}
{"id": 2998, "sentence": ["at", "some", "time", "scoop", "up", "pear", "or", "whenever", "travel", "by", "tree"], "tl": ["finally", "(", "scoop_up(pear)", ")", "or", "finally", "(", "travel_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "whenever", "travel", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "travel_by", "action_ref": "travel by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "    \"or\": \"or\","}
{"id": 7219, "sentence": ["seize", "apple", "or", "forever", "touch", "flag"], "tl": ["seize(apple)", "or", "globally", "(", "touch(flag)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "forever", "touch", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 1775, "sentence": ["at", "some", "time", "obtain", "apple", "and", "visit", "tree"], "tl": ["finally", "(", "obtain(apple)", ")", "and", "visit(tree)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"and\" : \"and\""}
{"id": 7250, "sentence": ["when", "possible", "procure", "orange", "and", "at", "any", "time", "pick", "up", "peach"], "tl": ["finally", "(", "procure(orange)", ")", "and", "finally", "(", "pick_up(peach)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "any", "time", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["peach)"], "args_ref": ["peach)"]}}, "prediction": "(which can be interpreted as a condition that can be checked at any time), the action of procuring an orange should occur. Additionally, at any time (which can be interpreted as a condition that can be checked at any time)"}
{"id": 6054, "sentence": ["whenever", "go", "near", "pear", "and", "move", "to", "tree"], "tl": ["finally", "(", "go_near(pear)", ")", "and", "move_to(tree)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(prop_1) and moving to the tree (prop_2), then this condition holds globally.\n\n2. *Explanation dictionary* \u2013\n{\n  \"whenever go near pear\" : \"prop_1\",\n  \"and move to tree\" : \"prop_2\",\n  \"whenever\" : \"G\"\n}\n\n3. *FINAL:* G (prop_1 and prop_2)"}
{"id": 2549, "sentence": ["at", "any", "time", "pass", "by", "trash", "bin", "and", "whenever", "go", "by", "tree"], "tl": ["finally", "(", "pass_by(trash_bin)", ")", "and", "finally", "(", "go_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "whenever", "go", "by", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(prop_1)\",\n  \"whenever go by tree\": \"prop_2\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 F prop_2)"}
{"id": 2487, "sentence": ["at", "any", "time", "grab", "pear", "or", "when", "possible", "shift", "to", "flag"], "tl": ["finally", "(", "grab(pear)", ")", "or", "finally", "(", "shift_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "shift", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "shift_to", "action_ref": "shift to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* G (prop_1 or prop_2 \u2192 prop_3) FINISH"}
{"id": 2918, "sentence": ["at", "any", "time", "go", "near", "pear", "and", "never", "let", "go", "apple"], "tl": ["finally", "(", "go_near(pear)", ")", "and", "globally", "(", "negation", "(", "let_go(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "never", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(represented by prop_1) should occur, and it should never be the case that the action of letting go of the apple (represented by prop_2) happens. This can be expressed as: globally, it is true that if we go near the pear, we never let go of the apple.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time\" : \"G\",\n  \"go near pear\" : \"prop_1\",\n  \"never let go apple\" : \"not prop_2\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 not prop_2)"}
{"id": 3010, "sentence": ["when", "possible", "stand", "by", "tree", "until", "at", "any", "time", "walk", "to", "flag"], "tl": ["finally", "(", "stand_by(tree)", ")", "until", "finally", "(", "walk_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "until", "at", "any", "time", "walk", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "stand_by", "action_ref": "stand by", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_2 U F prop_3)"}
{"id": 4397, "sentence": ["whenever", "proceed", "to", "tree", "or", "gather", "apple"], "tl": ["finally", "(", "proceed_to(tree)", ")", "or", "gather(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "gather", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "gather", "action_ref": "gather", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(G). The actions \"proceed to tree\" and \"gather apple\" can be represented by the proposition placeholders prop_1 and prop_2, respectively. The logical structure indicates that if either action occurs, it should hold true globally.\n\n2. *Explanation dictionary* \u2013\n{\n  \"whenever proceed to tree or gather apple\": \"G (prop_1 or prop_2)\"\n}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 2699, "sentence": ["when", "whenever", "go", "visit", "house", ",", "move", "to", "house"], "tl": ["finally", "(", "go_visit(house)", ")", "imply", "move_to(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["when", "whenever", "prop_1", ",", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(prop_2 \u2192 F(prop_1))"}
{"id": 2211, "sentence": ["whenever", "make", "contact", "flag", "and", "go", "visit", "flag"], "tl": ["finally", "(", "make_contact(flag)", ")", "and", "go_visit(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "go", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact", "action_ref": "make contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"and\" : \"\u2192\""}
{"id": 2863, "sentence": ["hold", "on", "to", "pear", "or", "go", "to", "orange"], "tl": ["hold_on_to(pear)", "or", "go_to(orange)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "go", "to", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold_on_to", "action_ref": "hold on to", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 1828, "sentence": ["at", "any", "time", "come", "home", "until", "never", "let", "go", "orange"], "tl": ["finally", "(", "come(home)", ")", "until", "globally", "(", "negation", "(", "let_go(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "until", "never", "let", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "come", "action_ref": "come", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(never let go of orange)\". In temporal logic, \"never let go of orange\" can be represented as \"not prop_2\" (assuming prop_2 represents \"let go of orange\")"}
{"id": 7096, "sentence": ["when", "possible", "go", "near", "flag", "or", "move", "towards", "trash", "can"], "tl": ["finally", "(", "go_near(flag)", ")", "or", "move_towards(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "or", "move", "towards", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "move_towards", "action_ref": "move towards", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 108, "sentence": ["forever", "hold", "onto", "orange", "or", "at", "some", "time", "make", "contact", "with", "house"], "tl": ["globally", "(", "hold_onto(orange)", ")", "or", "finally", "(", "make_contact_with(house)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "at", "some", "time", "make", "contact", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(where prop_1 represents holding onto orange), and \"at some time make contact with house\" translates to \"F prop_2\" (where prop_2 represents making contact with house)"}
{"id": 1308, "sentence": ["whenever", "get", "hold", "apple", "or", "travel", "to", "waste", "bin"], "tl": ["finally", "(", "get_hold(apple)", ")", "or", "travel_to(waste_bin)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 1927, "sentence": ["at", "some", "time", "track", "towards", "tree", "and", "grip", "apple"], "tl": ["finally", "(", "track_towards(tree)", ")", "and", "grip(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "grip", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "track_towards", "action_ref": "track towards", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "grip", "action_ref": "grip", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(F) to indicate that these actions will eventually occur.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at some time\" : \"F\",\n  \"track towards tree\" : \"prop_1\",\n  \"grip apple\" : \"prop_2\"\n}\n\n3. *FINAL:* F (prop_1 and prop_2)"}
{"id": 4155, "sentence": ["at", "some", "time", "going", "to", "house", "and", "at", "some", "time", "be", "near", "tree"], "tl": ["finally", "(", "going_to(house)", ")", "and", "finally", "(", "be_near(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "some", "time", "be", "near", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* F prop_1 and F prop_2 FINISH"}
{"id": 1341, "sentence": ["at", "some", "time", "steal", "apple", "and", "when", "possible", "move", "to", "flag"], "tl": ["finally", "(", "steal(apple)", ")", "and", "finally", "(", "move_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "when", "possible", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "steal", "action_ref": "steal", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1 \u2192 F prop_2)"}
{"id": 3625, "sentence": ["when", "possible", "bring", "pear", "until", "whenever", "go", "by", "waste", "basket"], "tl": ["finally", "(", "bring(pear)", ")", "until", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "until", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(prop_2 U prop_3)"}
{"id": 5755, "sentence": ["go", "to", "orange", "and", "don't", "pick", "up", "anything"], "tl": ["go_to(orange)", "and", "negation", "(", "finally", "(", "pick_up(anything)", ")", ")"], "masked_tl": ["prop_1", "and", "negation", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "don't", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["anything)"], "args_ref": ["anything)"]}}, "prediction": "(prop_1), while \"don't pick up anything\" can be represented as the negation of another proposition (prop_2)"}
{"id": 5496, "sentence": ["never", "drop", "orange", "or", "at", "some", "time", "seize", "pear"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "or", "finally", "(", "seize(pear)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "some", "time", "seize", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(at all times)"}
{"id": 1455, "sentence": ["never", "drop", "orange", "and", "when", "possible", "acquire", "pear"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "and", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "and", "when", "possible", "acquire", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* G(not prop_1) and (not prop_1) U prop_2 FINISH"}
{"id": 3985, "sentence": ["whenever", "contact", "flag", "and", "at", "any", "time", "move", "to", "flag"], "tl": ["finally", "(", "contact(flag)", ")", "and", "finally", "(", "move_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "any", "time", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(contact_flag \u2192 move_to_flag).\n\n2. *Explanation dictionary* \u2013\n{\n  \"whenever contact flag\" : \"contact_flag\",\n  \"move to flag\" : \"move_to_flag\",\n  \"at any time\" : \"G\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 prop_2)"}
{"id": 6755, "sentence": ["when", "possible", "get", "pear", "or", "at", "any", "time", "approach", "flag"], "tl": ["finally", "(", "get(pear)", ")", "or", "finally", "(", "approach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "approach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "    \"or\" : \"or\","}
{"id": 1505, "sentence": ["at", "any", "time", "move", "forward", "trash", "can", "or", "whenever", "getting", "pear"], "tl": ["finally", "(", "move_forward(trash_can)", ")", "or", "finally", "(", "getting(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "whenever", "getting", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_forward", "action_ref": "move forward", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "getting", "action_ref": "getting", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 5479, "sentence": ["at", "any", "time", "grasp", "pear", "and", "at", "some", "time", "tax", "apple"], "tl": ["finally", "(", "grasp(pear)", ")", "and", "finally", "(", "tax(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "tax", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(at any point in time), which translates to G(prop_1). The phrase \"at some time tax apple\" indicates that the action of taxing the apple will eventually happen, which translates to F(prop_2). Therefore, the overall formula combines these two conditions with a logical conjunction (and).\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time grasp pear\": \"G(prop_1)\",\n  \"at some time tax apple\": \"F(prop_2)\"\n}\n\n3. *FINAL:* G(prop_1) and F(prop_2)"}
{"id": 718, "sentence": ["forever", "have", "apple", "or", "at", "some", "time", "grab", "apple"], "tl": ["globally", "(", "have(apple)", ")", "or", "finally", "(", "grab(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "at", "some", "time", "grab", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 5860, "sentence": ["go", "to", "bucket", "or", "whenever", "stand", "by", "tree"], "tl": ["go_to(bucket)", "or", "finally", "(", "stand_by(tree)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "stand", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "stand_by", "action_ref": "stand by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 1334, "sentence": ["at", "any", "time", "go", "to", "trash", "can", "or", "pick", "up", "flag"], "tl": ["finally", "(", "go_to(trash_can)", ")", "or", "pick_up(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "pick", "up", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 6752, "sentence": ["forever", "move", "or", "whenever", "obtain", "apple"], "tl": ["globally", "(", "move", ")", "or", "finally", "(", "obtain(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "whenever", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move", "action_ref": "move", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* G prop_1 and (prop_2 \u2192 prop_1) FINISH"}
{"id": 3716, "sentence": ["when", "possible", "be", "near", "tree", "or", "at", "some", "time", "go", "past", "flag"], "tl": ["finally", "(", "be_near(tree)", ")", "or", "finally", "(", "go_past(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "some", "time", "go", "past", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go_past", "action_ref": "go past", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 3935, "sentence": ["whenever", "go", "past", "flag", "or", "always", "hold", "onto", "orange"], "tl": ["finally", "(", "go_past(flag)", ")", "or", "globally", "(", "hold_onto(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "always", "hold", "onto", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_past", "action_ref": "go past", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(flag U orange)\".\n   - \"or always hold onto orange\" indicates that at all times, the condition of holding onto \"orange\" must be true. This can be represented as \"G orange\".\n   - Combining these two parts with an \"or\" gives us the final formula.\n\n2. *Explanation dictionary* \u2013\n```json\n{\n  \"whenever go past flag\": \"go \u2192 (flag U orange)\",\n  \"or always hold onto orange\": \"G orange\"\n}\n```\n\n3. *FINAL:* (go \u2192 (flag U orange))"}
{"id": 2090, "sentence": ["whenever", "withdraw", "pear", "or", "never", "drop", "orange"], "tl": ["finally", "(", "withdraw(pear)", ")", "or", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withdraw", "action_ref": "withdraw", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* G (not prop_2) \u2192 (prop_1 \u2192 not prop_2) FINISH"}
{"id": 2789, "sentence": ["drop", "orange", "or", "whenever", "contact", "house"], "tl": ["drop(orange)", "or", "finally", "(", "contact(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "contact", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_2 \u2192 prop_1) or (prop_1) FINISH"}
{"id": 6669, "sentence": ["pick", "up", "pear", "or", "forever", "have", "apple"], "tl": ["pick_up(pear)", "or", "globally", "(", "have(apple)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "forever", "have", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 5928, "sentence": ["when", "venture", "towards", "house", ",", "at", "some", "time", "venture", "to", "house"], "tl": ["venture_towards(house)", "imply", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "prop_1", ",", "at", "some", "time", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* prop_1 \u2192 F prop_2 FINISH"}
{"id": 2621, "sentence": ["when", "possible", "scoop", "up", "pear", "or", "when", "possible", "capture", "pear"], "tl": ["finally", "(", "scoop_up(pear)", ")", "or", "finally", "(", "capture(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "capture", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 6192, "sentence": ["whenever", "venture", "to", "house", "until", "whenever", "bring", "pear"], "tl": ["finally", "(", "venture_to(house)", ")", "until", "finally", "(", "bring(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "until", "whenever", "bring", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_1)\",\n  \"until whenever bring pear\" : \"U (prop_2)\"\n}\n\n3. *FINAL:* G (prop_1 U prop_2)"}
{"id": 4044, "sentence": ["visit", "tree", "until", "acquire", "apple"], "tl": ["visit(tree)", "until", "acquire(apple)"], "masked_tl": ["prop_1", "until", "prop_2"], "grounded_sentence": ["prop_1", "until", "acquire", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(U), where we want to visit the tree (prop_1) until we acquire the apple (prop_2)"}
{"id": 352, "sentence": ["when", "never", "drop", "apple", ",", "secure", "apple"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "imply", "secure(apple)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "imply", "prop_2"], "grounded_sentence": ["when", "never", "prop_1", ",", "secure", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1), then it is globally true that the apple is never dropped (not prop_2).\n\n2. *Explanation dictionary* \u2013\n{\n  \"when\": \"implies\",\n  \"never\": \"not\",\n  \"drop apple\": \"prop_2\",\n  \"secure apple\": \"prop_1\"\n}\n\n3. *FINAL:* prop_1 \u2192 G(not prop_2)"}
{"id": 3088, "sentence": ["always", "have", "apple", "and", "at", "some", "time", "get", "hold", "apple"], "tl": ["globally", "(", "have(apple)", ")", "and", "finally", "(", "get_hold(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "and", "at", "some", "time", "get", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(where prop_1 represents having an apple), and \"at some time get hold apple\" translates to \"F prop_2\" (where prop_2 represents getting and holding an apple)"}
{"id": 5000, "sentence": ["when", "possible", "pass", "by", "house", "or", "at", "some", "time", "travel", "to", "trash", "can"], "tl": ["finally", "(", "pass_by(house)", ")", "or", "finally", "(", "travel_to(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "some", "time", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 6725, "sentence": ["at", "any", "time", "be", "in", "house's", "vicinity", "or", "repeatedly", "grab", "tree"], "tl": ["finally", "(", "be_in(house's_vicinity)", ")", "or", "globally", "(", "finally", "(", "grab(tree)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "repeatedly", "grab", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_in", "action_ref": "be in", "args_canon": ["house's_vicinity)"], "args_ref": ["house's vicinity)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"or\" : \"or\","}
{"id": 700, "sentence": ["repeatedly", "make", "way", "to", "house", "or", "do", "not", "let", "go", "pear"], "tl": ["globally", "(", "finally", "(", "make_way_to(house)", ")", ")", "or", "negation", "(", "let_go(pear)", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "negation", "(", "prop_2", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "do", "not", "let", "go", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_way_to", "action_ref": "make way to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(always), while \"do not let go of pear\" can be interpreted as a condition that should hold globally as well. Therefore, we can express this as a disjunction (or)"}
{"id": 2285, "sentence": ["at", "any", "time", "go", "to", "trash", "bin", "or", "when", "possible", "go", "near", "flag"], "tl": ["finally", "(", "go_to(trash_bin)", ")", "or", "finally", "(", "go_near(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "go", "near", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(or) of the two actions, each of which can happen globally (at any time).\n\n2. *Explanation dictionary* \u2013\n{\n  \"go to trash bin\" : prop_1,\n  \"go near flag\" : prop_2,\n  \"at any time\" : G\n}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 2384, "sentence": ["acquire", "apple", "or", "whenever", "grab", "pear"], "tl": ["acquire(apple)", "or", "finally", "(", "grab(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "grab", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 1833, "sentence": ["at", "any", "time", "take", "possession", "of", "bear", "and", "hold", "on", "to", "pear"], "tl": ["finally", "(", "take_possession_of(bear)", ")", "and", "hold_on_to(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "hold", "on", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}, "prop_2": {"action_canon": "hold_on_to", "action_ref": "hold on to", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"and\": \"and\""}
{"id": 5763, "sentence": ["secure", "apple", "until", "whenever", "bring", "pear"], "tl": ["secure(apple)", "until", "finally", "(", "bring(pear)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "whenever", "bring", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* prop_1 U prop_2 FINISH"}
{"id": 4451, "sentence": ["when", "possible", "advance", "to", "house", "or", "whenever", "travel", "to", "house"], "tl": ["finally", "(", "advance_to(house)", ")", "or", "finally", "(", "travel_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "whenever", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\" : \"or\""}
{"id": 5902, "sentence": ["whenever", "be", "in", "house's", "vicinity", "or", "when", "possible", "go", "to", "trashcan"], "tl": ["finally", "(", "be_in(house's_vicinity)", ")", "or", "finally", "(", "go_to(trashcan)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "go", "to", "trashcan", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_in", "action_ref": "be in", "args_canon": ["house's_vicinity)"], "args_ref": ["house's vicinity)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "(prop_1), then we should go to the trashcan (prop_2), or if it is possible to go to the trashcan (prop_3), we should also go to the trashcan.\n\n2. *Explanation dictionary* \u2013\n{\n  \"whenever be in house's vicinity\": \"prop_1\",\n  \"or when possible\": \"prop_3\",\n  \"go to trashcan\": \"prop_2\"\n}\n\n3. *FINAL:* (prop_1 \u2192 prop_2)"}
{"id": 115, "sentence": ["go", "by", "waste", "bin", "and", "secure", "apple"], "tl": ["go_by(waste_bin)", "and", "secure(apple)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "secure", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* prop_1 \u2192 prop_2 FINISH"}
{"id": 6544, "sentence": ["if", "move", "to", "house", ",", "at", "some", "time", "travel", "by", "tree"], "tl": ["move_to(house)", "imply", "finally", "(", "travel_by(tree)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "prop_1", ",", "at", "some", "time", "travel", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_by", "action_ref": "travel by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(F)"}
{"id": 2901, "sentence": ["drop", "orange", "and", "when", "possible", "go", "by", "flag"], "tl": ["drop(orange)", "and", "finally", "(", "go_by(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1), and the second part \"go by flag\" can be represented as another proposition (prop_2). The phrase \"when possible\" indicates that the second action should occur under the condition that it is possible, which can be interpreted as \"eventually\" (F)"}
{"id": 6550, "sentence": ["forever", "have", "in", "orange", "or", "when", "possible", "lay", "hold", "of", "apple"], "tl": ["globally", "(", "have_in(orange)", ")", "or", "finally", "(", "lay_hold_of(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "when", "possible", "lay", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "lay_hold_of", "action_ref": "lay hold of", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 6731, "sentence": ["whenever", "walk", "near", "flag", "and", "at", "any", "time", "travel", "by", "tree"], "tl": ["finally", "(", "walk_near(flag)", ")", "and", "finally", "(", "travel_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "any", "time", "travel", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk_near", "action_ref": "walk near", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "travel_by", "action_ref": "travel by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(prop_1 \u2192 F prop_2)"}
{"id": 2706, "sentence": ["if", "whenever", "make", "way", "waste", "basket", ",", "at", "any", "time", "spend", "time", "at", "tree"], "tl": ["finally", "(", "make_way(waste_basket)", ")", "imply", "finally", "(", "spend_time_at(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "whenever", "prop_1", ",", "at", "any", "time", "spend", "time", "at", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_way", "action_ref": "make way", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* prop_1 \u2192 F prop_2 FINISH"}
{"id": 3470, "sentence": ["travel", "to", "apple", "or", "always", "have", "in", "orange"], "tl": ["travel_to(apple)", "or", "globally", "(", "have_in(orange)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "always", "have", "in", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"or\": \"or\""}
