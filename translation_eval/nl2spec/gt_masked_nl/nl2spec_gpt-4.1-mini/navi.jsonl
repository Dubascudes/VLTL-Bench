{"id": 5390, "sentence": ["travel", "to", "waste", "bin", "or", "drop", "orange"], "tl": ["travel_to(waste_bin)", "or", "drop(orange)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "drop", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 or prop_2) FINISH"}
{"id": 5999, "sentence": ["at", "any", "time", "scoop", "up", "apple", "until", "when", "possible", "move", "past", "trash", "can"], "tl": ["finally", "(", "scoop_up(apple)", ")", "until", "finally", "(", "move_past(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "until", "when", "possible", "move", "past", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "move_past", "action_ref": "move past", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(G), indicating the property should hold at all times. \"scoop up apple\" is represented by prop_1. The phrase \"until when possible move past trash can\" indicates that \"scoop up apple\" holds until \"move past trash can\" becomes possible, represented by prop_2. The word \"possible\" suggests that prop_2 is true when moving past the trash can is possible. So the formula is: globally (prop_1 until prop_2).\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"globally\", \"scoop up apple\": \"prop_1\", \"possible move past trash can\": \"prop_2\", \"until\": \"until\"}\n\n3. *FINAL:* G (prop_1 U prop_2)"}
{"id": 3757, "sentence": ["at", "any", "time", "touch", "house", "or", "capture", "orange"], "tl": ["finally", "(", "touch(house)", ")", "or", "capture(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "capture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1 or prop_2)\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 5730, "sentence": ["at", "some", "time", "present", "at", "flag", "or", "whenever", "bring", "pear"], "tl": ["finally", "(", "present_at(flag)", ")", "or", "finally", "(", "bring(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "whenever", "bring", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(where prop_1 represents \"present at flag\").\n- \"or\" is the logical disjunction.\n- \"whenever bring pear\" corresponds to \"globally (prop_2 implies ...)"}
{"id": 6450, "sentence": ["move", "to", "house", "and", "put", "in", "bucket"], "tl": ["move_to(house)", "and", "put_in(bucket)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "put", "in", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}}, "prediction": "     \"and\": \"and\""}
{"id": 6506, "sentence": ["at", "any", "time", "pick", "up", "peach", "and", "drop", "orange"], "tl": ["finally", "(", "pick_up(peach)", ")", "and", "drop(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "drop", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["peach)"], "args_ref": ["peach)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(G), meaning the condition must hold at all times. The phrase \"pick up peach and drop orange\" is a conjunction of two propositions: \"pick up peach\" as prop_1 and \"drop orange\" as prop_2. The entire command means that at all times, both prop_1 and prop_2 hold simultaneously.\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"globally\", \"pick up peach\": \"prop_1\", \"drop orange\": \"prop_2\", \"pick up peach and drop orange\": \"(prop_1 and prop_2)\"}\n\n3. *FINAL:* G (prop_1 and prop_2)"}
{"id": 1893, "sentence": ["never", "drop", "orange", "or", "at", "some", "time", "move", "forward", "trash", "can"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "or", "finally", "(", "move_forward(trash_can)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "some", "time", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "move_forward", "action_ref": "move forward", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) or (finally prop_2) FINISH"}
{"id": 6221, "sentence": ["at", "any", "time", "visit", "trash", "bin", "or", "when", "possible", "journey", "by", "flag"], "tl": ["finally", "(", "visit(trash_bin)", ")", "or", "finally", "(", "journey_by(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "journey", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(G), indicating the property should hold at all times. The phrase \"visit trash bin or when possible journey by flag\" means that either \"visit trash bin\" or \"when possible journey by flag\" should hold at any time. We can represent \"visit trash bin\" as prop_1 and \"journey by flag\" as prop_2. The phrase \"when possible\" suggests that if it is possible to journey by flag, then the journey should happen eventually. So \"when possible journey by flag\" can be interpreted as \"if possible (prop_2), then eventually prop_2\". Since \"possible\" is not explicitly defined, we treat \"journey by flag\" as prop_2 and interpret \"when possible journey by flag\" as \"eventually prop_2\". The overall formula is globally (prop_1 or eventually prop_2)"}
{"id": 5253, "sentence": ["hold", "pear", "and", "at", "any", "time", "venture", "to", "waste", "basket"], "tl": ["hold(pear)", "and", "finally", "(", "venture_to(waste_basket)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "any", "time", "venture", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "3. *FINAL:* (prop_1 and finally prop_2) FINISH"}
{"id": 4059, "sentence": ["at", "some", "time", "get", "close", "flag", "or", "at", "some", "time", "walk", "to", "flag"], "tl": ["finally", "(", "get_close(flag)", ")", "or", "finally", "(", "walk_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "walk", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 4803, "sentence": ["at", "some", "time", "proceed", "to", "house", "and", "whenever", "go", "to", "tree"], "tl": ["finally", "(", "proceed_to(house)", ")", "and", "finally", "(", "go_to(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "whenever", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(finally) prop_1 (proceed to house) will be true, so we use F prop_1. The phrase \"whenever go to tree\" means that globally, if prop_2 (go to tree) holds, then something follows. Since the command is incomplete after \"whenever go to tree,\" we interpret it as \"whenever go to tree, something should happen,\" but since no further action is specified, we assume the requirement is just that whenever prop_2 holds, it is recognized globally. To combine both parts, we use \"finally prop_1 and globally (prop_2 implies true)\" which simplifies to \"finally prop_1 and globally (prop_2 implies true)\" but since \"implies true\" is always true, the second part is just globally true, so the main requirement is F prop_1 and G (prop_2 implies true)"}
{"id": 5583, "sentence": ["whenever", "withhold", "apple", "until", "venture", "towards", "house"], "tl": ["finally", "(", "withhold(apple)", ")", "until", "venture_towards(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "until", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(U) captures this behavior. The \"whenever\" indicates that globally, if \"withhold apple\" starts, it must hold until \"venture towards house\" happens.\n\n2. *Explanation dictionary* \u2013\n{\n  \"withhold apple\": \"prop_1\",\n  \"venture towards house\": \"prop_2\",\n  \"withhold apple until venture towards house\": \"(prop_1 U prop_2)\",\n  \"whenever withhold apple until venture towards house\": \"G (prop_1 \u2192 (prop_1 U prop_2))\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 (prop_1 U prop_2))"}
{"id": 1035, "sentence": ["whenever", "secure", "pear", "and", "whenever", "travel", "to", "house"], "tl": ["finally", "(", "secure(pear)", ")", "and", "finally", "(", "travel_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "whenever", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (globally prop_1) and (globally prop_2) FINISH"}
{"id": 968, "sentence": ["hold", "pear", "until", "when", "possible", "get", "apple"], "tl": ["hold(pear)", "until", "finally", "(", "get(apple)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "when", "possible", "get", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "get", "action_ref": "get", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 until prop_2) FINISH"}
{"id": 1439, "sentence": ["at", "some", "time", "snatch", "pear", "means", "that", "go", "visit", "flag"], "tl": ["finally", "(", "snatch(pear)", ")", "imply", "go_visit(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "means", "that", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch", "action_ref": "snatch", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(F prop_1), meaning that at some point in the future, the action \"snatch pear\" (prop_1) occurs. The phrase \"means that go visit flag\" indicates an implication from \"snatch pear\" to \"go visit flag\" (prop_2). Since the command says \"at some time snatch pear means that go visit flag,\" it implies that whenever \"snatch pear\" happens at some time, it implies \"go visit flag\" happens at some time as well. To capture this, we say: if eventually prop_1, then eventually prop_2, i.e., (F prop_1) implies (F prop_2).\n\n2. *Explanation dictionary* \u2013 {\"at some time snatch pear\": \"F prop_1\", \"go visit flag\": \"prop_2\", \"means that\": \"implies\", \"at some time snatch pear means that go visit flag\": \"(F prop_1) implies (F prop_2)\"}\n\n3. *FINAL:* (F prop_1) implies (F prop_2)"}
{"id": 2835, "sentence": ["take", "orange", "and", "at", "any", "time", "go", "near", "pear"], "tl": ["take(orange)", "and", "finally", "(", "go_near(pear)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take", "action_ref": "take", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(taking orange).\n   - \"at any time go near pear\" means eventually (finally) go near pear, represented by F prop_2.\n   The entire command is the conjunction of these two parts: prop_1 and F prop_2.\n\n2. *Explanation dictionary* \u2013\n   {\n     \"take orange\": \"prop_1\",\n     \"at any time go near pear\": \"F prop_2\"\n   }\n\n3. *FINAL:* (prop_1 and F prop_2)"}
{"id": 501, "sentence": ["when", "possible", "journey", "by", "house", "or", "when", "possible", "stand", "by", "tree"], "tl": ["finally", "(", "journey_by(house)", ")", "or", "finally", "(", "stand_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "stand", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "stand_by", "action_ref": "stand by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(F), indicating eventual possibility. \"Journey by house\" and \"stand by tree\" are represented by propositions prop_1 and prop_2 respectively. So, the formula is the disjunction of \"finally prop_1\" and \"finally prop_2.\"\n\n2. *Explanation dictionary* \u2013 {\"when possible journey by house\": \"F prop_1\", \"when possible stand by tree\": \"F prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 5202, "sentence": ["at", "some", "time", "pass", "by", "house", "or", "move", "to", "trash", "can"], "tl": ["finally", "(", "pass_by(house)", ")", "or", "move_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 52, "sentence": ["secure", "apple", "until", "secure", "apple"], "tl": ["secure(apple)", "until", "secure(apple)"], "masked_tl": ["prop_2", "until", "prop_2"], "grounded_sentence": ["prop_1", "until", "secure", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(represented as prop_1) holds continuously until \"secure apple\" holds. Since both phrases are the same, this reduces to \"prop_1 until prop_1\", which is logically equivalent to just \"prop_1\".\n\n2. *Explanation dictionary* \u2013 {\"secure apple\": \"prop_1\", \"secure apple until secure apple\": \"prop_1 U prop_1\"}\n\n3. *FINAL:* (prop_1 U prop_1)"}
{"id": 7171, "sentence": ["travel", "to", "waste", "bin", "or", "pick", "up", "orange"], "tl": ["travel_to(waste_bin)", "or", "pick_up(orange)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "pick", "up", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 5547, "sentence": ["put", "in", "bucket", "until", "at", "some", "time", "obtain", "orange"], "tl": ["put_in(bucket)", "until", "finally", "(", "obtain(orange)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "some", "time", "obtain", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 until prop_2) FINISH"}
{"id": 1429, "sentence": ["at", "some", "time", "get", "orange", "means", "that", "at", "any", "time", "proceed", "to", "house"], "tl": ["finally", "(", "get(orange)", ")", "imply", "finally", "(", "proceed_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "means", "that", "at", "any", "time", "proceed", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (finally(prop_1) implies globally(prop_2)) FINISH"}
{"id": 1408, "sentence": ["pick", "up", "fruit", "until", "at", "any", "time", "go", "past", "flag"], "tl": ["pick_up(fruit)", "until", "finally", "(", "go_past(flag)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "any", "time", "go", "past", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["fruit)"], "args_ref": ["fruit)"]}, "prop_2": {"action_canon": "go_past", "action_ref": "go past", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 until prop_2) FINISH"}
{"id": 431, "sentence": ["whenever", "spend", "time", "at", "tree", "and", "never", "drop", "orange"], "tl": ["finally", "(", "spend_time_at(tree)", ")", "and", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "never", "drop", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies globally (not prop_2)) FINISH"}
{"id": 1430, "sentence": ["at", "any", "time", "be", "near", "tree", "and", "at", "some", "time", "getting", "pear"], "tl": ["finally", "(", "be_near(tree)", ")", "and", "finally", "(", "getting(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "getting", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "getting", "action_ref": "getting", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (globally prop_1) and (finally prop_2) FINISH"}
{"id": 5678, "sentence": ["put", "in", "bin", "or", "seize", "apple"], "tl": ["put_in(bin)", "or", "seize(apple)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "seize", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(\"or\") between two actions: \"put in bin\" and \"seize apple\". We represent \"put in bin\" as prop_1 and \"seize apple\" as prop_2. The formula states that eventually one of these actions should happen, so we use the finally (F) operator over the disjunction.\n\n2. *Explanation dictionary* \u2013 {\"put in bin\": \"prop_1\", \"seize apple\": \"prop_2\", \"put in bin or seize apple\": \"prop_1 or prop_2\", \"eventually put in bin or seize apple\": \"F (prop_1 or prop_2)\"}\n\n3. *FINAL:* F (prop_1 or prop_2)"}
{"id": 3015, "sentence": ["if", "at", "any", "time", "present", "at", "flag", ",", "never", "drop", "apple"], "tl": ["finally", "(", "present_at(flag)", ")", "imply", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["if", "at", "any", "time", "prop_1", ",", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (F prop_1) implies (G not prop_2) FINISH"}
{"id": 1949, "sentence": ["at", "some", "time", "arrive", "at", "tree", "or", "at", "any", "time", "journey", "to", "house"], "tl": ["finally", "(", "arrive_at(tree)", ")", "or", "finally", "(", "journey_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "any", "time", "journey", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "arrive_at", "action_ref": "arrive at", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F prop_1), where prop_1 represents \"arrive at tree\". The phrase \"at any time journey to house\" corresponds to \"always prop_2\" (G prop_2), where prop_2 represents \"journey to house\". The \"or\" connects these two temporal statements.\n\n2. *Explanation dictionary* \u2013 {\"at some time arrive at tree\": \"F prop_1\", \"at any time journey to house\": \"G prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (F prop_1) or (G prop_2)"}
{"id": 3250, "sentence": ["when", "secure", "apple", ",", "at", "some", "time", "present", "at", "flag"], "tl": ["secure(apple)", "imply", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "prop_1", ",", "at", "some", "time", "present", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 implies finally prop_2) FINISH"}
{"id": 5502, "sentence": ["whenever", "stop", "by", "house", "and", "move", "to", "trashcan"], "tl": ["finally", "(", "stop_by(house)", ")", "and", "move_to(trashcan)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "(stop by house) is true, then \"move to trashcan\" (prop_2) should eventually happen afterward. This is captured by globally (G) stating that whenever prop_1 holds, then eventually (F) prop_2 will hold.\n\n2. *Explanation dictionary* \u2013 {\"stop by house\": \"prop_1\", \"move to trashcan\": \"prop_2\", \"whenever stop by house and move to trashcan\": \"G (prop_1 implies F prop_2)\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 3955, "sentence": ["when", "possible", "stop", "by", "house", "and", "whenever", "venture", "flag"], "tl": ["finally", "(", "stop_by(house)", ")", "and", "finally", "(", "venture(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "whenever", "venture", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(venture flag) is true, the rest of the formula applies. The phrase \"when possible stop by house\" means that if it is possible to stop by house (prop_1), then eventually stop by house should happen. So, whenever prop_2 holds, eventually prop_1 should hold.\n\n2. *Explanation dictionary* \u2013 {\"whenever venture flag\": \"G (prop_2 \u2192 ...)\", \"when possible stop by house\": \"F prop_1\"}\n\n3. *FINAL:* G (prop_2 implies F prop_1)"}
{"id": 2188, "sentence": ["never", "drop", "apple", "and", "never", "drop", "apple"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "and", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_2", ")", ")", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["never", "prop_1", "and", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) and (globally (not prop_1)) FINISH"}
{"id": 725, "sentence": ["at", "some", "time", "grab", "apple", "and", "when", "possible", "capture", "pear"], "tl": ["finally", "(", "grab(apple)", ")", "and", "finally", "(", "capture(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "when", "possible", "capture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(F prop_1), where prop_1 represents \"grab apple\". The phrase \"when possible capture pear\" means \"whenever it is possible to capture pear, then capture pear\", which can be interpreted as \"globally (if possible then capture pear)\". Since \"possible\" is not explicitly defined, we treat \"possible\" as a condition that allows capturing pear, so we model it as \"globally (prop_2 implies prop_3)\", where prop_2 represents \"possible to capture pear\" and prop_3 represents \"capture pear\". However, since only prop_1, prop_2, etc. are allowed and the command only mentions \"capture pear\" as an action, we can simplify by assuming \"when possible capture pear\" means \"if at any time it is possible, then capture pear immediately\", which can be modeled as \"globally (prop_2 implies next prop_3)\". But since \"possible\" is not given as a proposition, we can interpret \"when possible capture pear\" as \"eventually capture pear\" (F prop_2)"}
{"id": 46, "sentence": ["when", "possible", "lay", "hold", "of", "apple", "and", "drop", "pear"], "tl": ["finally", "(", "lay_hold_of(apple)", ")", "and", "drop(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "drop", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "lay_hold_of", "action_ref": "lay hold of", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (F (prop_1 and prop_2)) FINISH"}
{"id": 3574, "sentence": ["at", "some", "time", "tax", "apple", "can", "infer", "that", "whenever", "advance", "to", "house"], "tl": ["finally", "(", "tax(apple)", ")", "imply", "finally", "(", "advance_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "can", "infer", "that", "whenever", "advance", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* finally (prop_1 implies prop_2) FINISH"}
{"id": 2585, "sentence": ["never", "drop", "pear", "until", "at", "any", "time", "collect", "apple"], "tl": ["globally", "(", "negation", "(", "drop(pear)", ")", ")", "until", "finally", "(", "collect(apple)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "until", "at", "any", "time", "collect", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (not prop_1) until prop_2 FINISH"}
{"id": 4452, "sentence": ["at", "any", "time", "get", "close", "flag", "or", "at", "any", "time", "capture", "pear"], "tl": ["finally", "(", "get_close(flag)", ")", "or", "finally", "(", "capture(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "any", "time", "capture", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(globally), either prop_1 or prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"G\", \"get close flag\": \"prop_1\", \"capture pear\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 4906, "sentence": ["hold", "orange", "or", "pick", "up", "pear"], "tl": ["hold(orange)", "or", "pick_up(pear)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "pick", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 3746, "sentence": ["when", "possible", "arrive", "at", "tree", "and", "pick", "up", "orange"], "tl": ["finally", "(", "arrive_at(tree)", ")", "and", "pick_up(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "arrive_at", "action_ref": "arrive at", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1 and prop_2).\n\n2. *Explanation dictionary* \u2013\n{\n  \"arrive at tree\": \"prop_1\",\n  \"pick up orange\": \"prop_2\",\n  \"arrive at tree and pick up orange\": \"(prop_1 and prop_2)\",\n  \"when possible\": \"F\"\n}\n\n3. *FINAL:* F(prop_1 and prop_2)"}
{"id": 4932, "sentence": ["when", "possible", "pass", "by", "waste", "receptacle", "and", "when", "possible", "take", "possession", "of", "bear"], "tl": ["finally", "(", "pass_by(waste_receptacle)", ")", "and", "finally", "(", "take_possession_of(bear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "take", "possession", "of", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["waste_receptacle)"], "args_ref": ["waste receptacle)"]}, "prop_2": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}}, "prediction": " \"and\": \"and\"}"}
{"id": 7345, "sentence": ["when", "possible", "obtain", "orange", "or", "take", "to", "tree"], "tl": ["finally", "(", "obtain(orange)", ")", "or", "take_to(tree)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "or", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or prop_2) FINISH"}
{"id": 473, "sentence": ["drop", "by", "and", "never", "let", "go", "orange"], "tl": ["drop_by", "and", "globally", "(", "negation", "(", "let_go(orange)", ")", ")"], "masked_tl": ["prop_1", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "never", "let", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop_by", "action_ref": "drop by", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (finally prop_1) and (globally (not prop_2)) FINISH"}
{"id": 2877, "sentence": ["come", "to", "tree", "or", "at", "some", "time", "stop", "by", "house"], "tl": ["come_to(tree)", "or", "finally", "(", "stop_by(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "stop", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "come_to", "action_ref": "come to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F), meaning eventually. The \"or\" connects the two eventualities.\n\n2. *Explanation dictionary* \u2013 {\"come to tree\": \"prop_1\", \"stop by house\": \"prop_2\", \"at some time\": \"finally\", \"or\": \"or\"}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 3313, "sentence": ["at", "some", "time", "make", "contact", "with", "house", "and", "travel", "to", "waste", "bin"], "tl": ["finally", "(", "make_contact_with(house)", ")", "and", "travel_to(waste_bin)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "travel", "to", "waste", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "3. *FINAL:* (F (prop_1 and prop_2)) FINISH"}
{"id": 5898, "sentence": ["at", "any", "time", "venture", "to", "house", "or", "never", "drop", "apple"], "tl": ["finally", "(", "venture_to(house)", ")", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(G), meaning the property must hold at all times. The phrase \"venture to house or never drop apple\" is a disjunction: either \"venture to house\" (prop_1) holds at some point, or \"never drop apple\" means \"globally not drop apple\" (G not prop_2). Since \"never drop apple\" is a global property, and the whole is under \"at any time,\" the formula is G (F prop_1 or G not prop_2).\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time\": \"G\",\n  \"venture to house\": \"F prop_1\",\n  \"never drop apple\": \"G not prop_2\",\n  \"venture to house or never drop apple\": \"(F prop_1 or G not prop_2)\"\n}\n\n3. *FINAL:* G (F prop_1 or G (not prop_2))"}
{"id": 515, "sentence": ["at", "some", "time", "pass", "by", "house", "or", "whenever", "stand", "by", "tree"], "tl": ["finally", "(", "pass_by(house)", ")", "or", "finally", "(", "stand_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "whenever", "stand", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "stand_by", "action_ref": "stand by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (globally (prop_2 implies prop_1)) FINISH"}
{"id": 4616, "sentence": ["at", "some", "time", "go", "to", "tree", "or", "at", "some", "time", "grasp", "apple"], "tl": ["finally", "(", "go_to(tree)", ")", "or", "finally", "(", "grasp(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "grasp", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 1713, "sentence": ["never", "drop", "apple", "or", "at", "any", "time", "reach", "flag"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "or", "finally", "(", "reach(flag)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "any", "time", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (G not prop_1) or (F prop_2) FINISH"}
{"id": 3627, "sentence": ["when", "possible", "contact", "house", "or", "when", "possible", "pass", "by", "house"], "tl": ["finally", "(", "contact(house)", ")", "or", "finally", "(", "pass_by(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "pass", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or prop_2) FINISH"}
{"id": 6960, "sentence": ["at", "some", "time", "go", "near", "house", "or", "move", "to", "trashcan"], "tl": ["finally", "(", "go_near(house)", ")", "or", "move_to(trashcan)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or prop_2) FINISH"}
{"id": 7050, "sentence": ["at", "some", "time", "make", "contact", "flag", "or", "venture", "to", "trash", "can"], "tl": ["finally", "(", "make_contact(flag)", ")", "or", "venture_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact", "action_ref": "make contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or prop_2) FINISH"}
{"id": 7289, "sentence": ["at", "some", "time", "move", "past", "trash", "can", "and", "at", "any", "time", "procure", "pear"], "tl": ["finally", "(", "move_past(trash_can)", ")", "and", "finally", "(", "procure(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "any", "time", "procure", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_past", "action_ref": "move past", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(finally) the proposition representing \"move past trash can\" (prop_1) should be true. The phrase \"and at any time procure pear\" means that globally (always) the proposition representing \"procure pear\" (prop_2) should hold.\n\n2. *Explanation dictionary* \u2013 {\"at some time move past trash can\": \"F prop_1\", \"at any time procure pear\": \"G prop_2\"}\n\n3. *FINAL:* (F prop_1) and (G prop_2)"}
{"id": 4923, "sentence": ["drop", "orange", "or", "when", "possible", "collect", "apple"], "tl": ["drop(orange)", "or", "finally", "(", "collect(apple)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "collect", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_2 or finally prop_1) FINISH"}
{"id": 2894, "sentence": ["acquire", "orange", "or", "never", "drop", "apple"], "tl": ["acquire(orange)", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 or (globally (not prop_2))) FINISH"}
{"id": 1873, "sentence": ["snatch", "up", "pear", "and", "when", "possible", "move", "near", "tree"], "tl": ["snatch_up(pear)", "and", "finally", "(", "move_near(tree)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "move", "near", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch_up", "action_ref": "snatch up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "move_near", "action_ref": "move near", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (prop_1 and finally prop_2) FINISH"}
{"id": 3481, "sentence": ["when", "secure", "apple", ",", "go", "by", "waste", "bin"], "tl": ["secure(apple)", "imply", "go_by(waste_bin)"], "masked_tl": ["prop_1", "imply", "prop_2"], "grounded_sentence": ["when", "prop_1", ",", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "(prop_1 implies F prop_2)"}
{"id": 4698, "sentence": ["at", "some", "time", "visit", "waste", "basket", "until", "at", "any", "time", "venture", "to", "flag"], "tl": ["finally", "(", "visit(waste_basket)", ")", "until", "finally", "(", "venture_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "at", "any", "time", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 until prop_2) FINISH"}
{"id": 2263, "sentence": ["go", "visit", "flag", "and", "when", "possible", "go", "home"], "tl": ["go_visit(flag)", "and", "finally", "(", "go(home)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "go", "home", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "3. *FINAL:* (F prop_1) and (prop_2 implies F prop_3) FINISH"}
{"id": 6535, "sentence": ["when", "possible", "touch", "tree", "or", "never", "drop", "apple"], "tl": ["finally", "(", "touch(tree)", ")", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (F prop_1) or (G (not prop_2)) FINISH"}
{"id": 6595, "sentence": ["go", "to", "bucket", "and", "when", "possible", "obtain", "orange"], "tl": ["go_to(bucket)", "and", "finally", "(", "obtain(orange)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "obtain", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* finally(prop_1) and globally(implies(prop_1, finally(prop_2))) FINISH"}
{"id": 167, "sentence": ["put", "in", "bin", "until", "whenever", "scoop", "up", "pear"], "tl": ["put_in(bin)", "until", "finally", "(", "scoop_up(pear)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "whenever", "scoop", "up", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}, "prop_2": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(scoop up pear) is true, then \"put in bin\" (prop_2) must hold continuously until some condition. The phrase \"put in bin until\" suggests that prop_2 holds until some event, but since no event after \"until\" is specified, we interpret \"put in bin until whenever scoop up pear\" as: whenever prop_1 happens, prop_2 must hold continuously from that point on. This can be captured by globally (G) stating that if prop_1 occurs, then prop_2 holds until prop_1 occurs again or indefinitely. Since the command is ambiguous, the safest interpretation is: globally, whenever prop_1 happens, prop_2 holds until the next occurrence of prop_1 or forever. This is expressed as G(prop_1 \u2192 (prop_2 U prop_1)).\n\n2. *Explanation dictionary* \u2013 {\"scoop up pear\": \"prop_1\", \"put in bin\": \"prop_2\", \"whenever scoop up pear\": \"G(prop_1 \u2192 (prop_2 U prop_1))"}
{"id": 4769, "sentence": ["at", "any", "time", "snatch", "pear", "and", "at", "some", "time", "pass", "by", "house"], "tl": ["finally", "(", "snatch(pear)", ")", "and", "finally", "(", "pass_by(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "pass", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch", "action_ref": "snatch", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(always) the proposition representing \"snatch pear\" (prop_1) holds. The phrase \"at some time pass by house\" means that eventually (finally) the proposition representing \"pass by house\" (prop_2) holds. The conjunction \"and\" connects these two temporal requirements.\n\n2. *Explanation dictionary* \u2013 {\"at any time snatch pear\": \"G prop_1\", \"at some time pass by house\": \"F prop_2\"}\n\n3. *FINAL:* (G prop_1) and (F prop_2)"}
{"id": 2378, "sentence": ["drop", "orange", "or", "when", "possible", "go", "to", "trash", "bin"], "tl": ["drop(orange)", "or", "finally", "(", "go_to(trash_bin)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 7440, "sentence": ["move", "towards", "trash", "can", "or", "approach", "tree"], "tl": ["move_towards(trash_can)", "or", "approach(tree)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "approach", "tree", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_towards", "action_ref": "move towards", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 4225, "sentence": ["hold", "apple", "and", "repeatedly", "go", "to", "pear"], "tl": ["hold(apple)", "and", "globally", "(", "finally", "(", "go_to(pear)", ")", ")"], "masked_tl": ["prop_1", "and", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "repeatedly", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (globally prop_1) and (globally finally prop_2) FINISH"}
{"id": 1529, "sentence": ["when", "possible", "take", "possession", "of", "bear", "or", "when", "possible", "go", "home"], "tl": ["finally", "(", "take_possession_of(bear)", ")", "or", "finally", "(", "go(home)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "go", "home", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}, "prop_2": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 5085, "sentence": ["at", "some", "time", "migrate", "to", "tree", "until", "travel", "to", "apple"], "tl": ["finally", "(", "migrate_to(tree)", ")", "until", "travel_to(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "migrate_to", "action_ref": "migrate to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* finally (prop_1 until prop_2) FINISH"}
{"id": 3188, "sentence": ["visit", "tree", "or", "whenever", "touch", "house"], "tl": ["visit(tree)", "or", "finally", "(", "touch(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "touch", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(visit tree)\n- \"touch house\" \u2192 prop_2 (touch house)\n- \"visit tree eventually\" \u2192 F prop_1\n- \"whenever touch house, eventually visit tree\" \u2192 G (prop_2 \u2192 F prop_1)\n- \"visit tree or whenever touch house ...\" \u2192 F prop_1 or G (prop_2 \u2192 F prop_1)"}
{"id": 1591, "sentence": ["travel", "to", "apple", "and", "when", "possible", "visit", "trash", "bin"], "tl": ["travel_to(apple)", "and", "finally", "(", "visit(trash_bin)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "visit", "trash", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "3. *FINAL:* (prop_1) and (G (prop_2 implies F prop_3)) FINISH"}
{"id": 5488, "sentence": ["when", "possible", "make", "contact", "with", "house", "or", "never", "let", "go", "orange"], "tl": ["finally", "(", "make_contact_with(house)", ")", "or", "globally", "(", "negation", "(", "let_go(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "never", "let", "go", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(i.e., always held). So, \"make contact with house or never let go orange\" translates to \"finally prop_1 (contact with house) or globally prop_2 (never let go orange)\". The \"when possible\" implies that if it is possible to make contact, then eventually do so, which can be interpreted as \"finally (prop_1 or prop_2)\". Since the command is to do this \"when possible,\" the formula ensures that if it is possible to make contact, then eventually contact is made or the orange is never let go.\n\n2. *Explanation dictionary* \u2013\n{\n  \"make contact with house\": \"prop_1\",\n  \"never let go orange\": \"globally prop_2\",\n  \"make contact with house or never let go orange\": \"(F prop_1) or (G prop_2)\",\n  \"when possible\": \"F ((F prop_1)"}
{"id": 335, "sentence": ["take", "pear", "and", "whenever", "grab", "apple"], "tl": ["take(pear)", "and", "finally", "(", "grab(apple)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "grab", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take", "action_ref": "take", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "   - prop_1 (take pear) and"}
{"id": 6869, "sentence": ["whenever", "visit", "trash", "bin", "and", "move", "to", "trashcan"], "tl": ["finally", "(", "visit(trash_bin)", ")", "and", "move_to(trashcan)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "(\"visit trash bin\" and \"move to trashcan\"), something should hold. Since the command is about the occurrence of these two events together, we interpret it as \"whenever (visit trash bin and move to trashcan) happens, some property holds.\" However, since no further property is specified, the simplest interpretation is to express that \"whenever (visit trash bin and move to trashcan) occurs, it is true,\" which is tautological. Alternatively, if the command is to specify that whenever these two events happen, they happen simultaneously, we can express the conjunction globally. But since the command is just \"whenever visit trash bin and move to trashcan,\" the best interpretation is to express that whenever the conjunction of these two propositions holds, it is true. So the formula is: globally (if visit trash bin and move to trashcan, then true), which is trivial. To make it meaningful, we can just express globally (visit trash bin and move to trashcan) implies something, but since no consequent is given, we just express globally (visit trash bin and move to trashcan)"}
{"id": 3376, "sentence": ["at", "some", "time", "withhold", "apple", "and", "secure", "apple"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "secure(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "secure", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 and prop_2)) FINISH"}
{"id": 5586, "sentence": ["don't", "let", "go", "pear", "or", "when", "possible", "snag", "orange"], "tl": ["negation", "(", "let_go(pear)", ")", "or", "finally", "(", "snag(orange)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["don't", "prop_1", "or", "when", "possible", "snag", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) or (finally prop_2) FINISH"}
{"id": 5396, "sentence": ["at", "some", "time", "make", "contact", "flag", "and", "at", "any", "time", "seize", "pear"], "tl": ["finally", "(", "make_contact(flag)", ")", "and", "finally", "(", "seize(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "any", "time", "seize", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact", "action_ref": "make contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(finally) the proposition prop_1 (representing \"make contact flag\") will be true, so we use F prop_1. The phrase \"at any time seize pear\" means that globally (always) the proposition prop_2 (representing \"seize pear\") holds, so we use G prop_2. The entire command is a conjunction of these two requirements, so we combine them with and.\n\n2. *Explanation dictionary* \u2013 {\"at some time make contact flag\" : \"F prop_1\", \"at any time seize pear\" : \"G prop_2\"}\n\n3. *FINAL:* (F prop_1) and (G prop_2)"}
{"id": 3187, "sentence": ["whenever", "travel", "to", "trash", "can", "can", "infer", "that", "whenever", "approach", "house"], "tl": ["finally", "(", "travel_to(trash_can)", ")", "imply", "finally", "(", "approach(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "can", "can", "infer", "that", "whenever", "approach", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(travel to trash can) happens, it implies that whenever prop_2 (approach house) happens. Since the command uses \"whenever\" twice, it indicates a nested implication over time. We model \"whenever\" as globally (G) and the implication as \u2192. So, globally, if prop_1 holds, then globally prop_2 holds.\n\n2. *Explanation dictionary* \u2013\n{\n  \"whenever travel to trash can\": \"G prop_1\",\n  \"whenever approach house\": \"G prop_2\",\n  \"can infer that\": \"\u2192\"\n}\n\n3. *FINAL:* (G prop_1) \u2192 (G prop_2)"}
{"id": 2058, "sentence": ["going", "to", "tree", "or", "at", "some", "time", "go", "near", "pear"], "tl": ["going_to(tree)", "or", "finally", "(", "go_near(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "go", "near", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 2505, "sentence": ["venture", "towards", "house", "and", "go", "by", "waste", "bin"], "tl": ["venture_towards(house)", "and", "go_by(waste_bin)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "3. *FINAL:* (finally(prop_1) and finally(prop_2)) FINISH"}
{"id": 5018, "sentence": ["at", "some", "time", "move", "past", "trash", "can", "or", "repeatedly", "go", "to", "pear"], "tl": ["finally", "(", "move_past(trash_can)", ")", "or", "globally", "(", "finally", "(", "go_to(pear)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "repeatedly", "go", "to", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_past", "action_ref": "move past", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 1645, "sentence": ["if", "whenever", "go", "home", ",", "at", "some", "time", "travel", "by", "tree"], "tl": ["finally", "(", "go(home)", ")", "imply", "finally", "(", "travel_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "whenever", "prop_1", ",", "at", "some", "time", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "travel_by", "action_ref": "travel by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 1762, "sentence": ["hold", "apple", "or", "hold", "orange"], "tl": ["hold(apple)", "or", "hold(orange)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "hold", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 or prop_2) FINISH"}
{"id": 1758, "sentence": ["at", "any", "time", "secure", "pear", "or", "whenever", "set", "out", "to", "house"], "tl": ["finally", "(", "secure(pear)", ")", "or", "finally", "(", "set_out_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "whenever", "set", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "set_out_to", "action_ref": "set out to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 1383, "sentence": ["whenever", "go", "by", "waste", "basket", "or", "at", "some", "time", "venture", "to", "house"], "tl": ["finally", "(", "go_by(waste_basket)", ")", "or", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "some", "time", "venture", "to", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(prop_1) holds, something else must follow. The phrase \"or at some time venture to house\" indicates that either the first condition holds or eventually \"venture to house\" (prop_2) holds. The entire command can be interpreted as: globally, if \"go by waste basket\" happens, or eventually \"venture to house\" happens.\n\n2. *Explanation dictionary* \u2013 {\"whenever go by waste basket\": \"G (prop_1 \u2192 ...)\", \"or at some time venture to house\": \"or F prop_2\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 1701, "sentence": ["move", "towards", "trash", "can", "or", "whenever", "go", "home"], "tl": ["move_towards(trash_can)", "or", "finally", "(", "go(home)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "go", "home", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_towards", "action_ref": "move towards", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (globally (prop_2 implies finally prop_1)) FINISH"}
{"id": 6789, "sentence": ["at", "some", "time", "travel", "to", "trash", "can", "and", "at", "any", "time", "go", "near", "flag"], "tl": ["finally", "(", "travel_to(trash_can)", ")", "and", "finally", "(", "go_near(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "any", "time", "go", "near", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(F prop_1), meaning that at some point in the future, prop_1 (travel to trash can) will be true. The phrase \"at any time go near flag\" corresponds to \"globally prop_2\" (G prop_2), meaning that at all times, prop_2 (go near flag) holds. The conjunction \"and\" connects these two temporal requirements.\n\n2. *Explanation dictionary* \u2013 {\"at some time travel to trash can\": \"F prop_1\", \"at any time go near flag\": \"G prop_2\"}\n\n3. *FINAL:* (F prop_1) and (G prop_2)"}
{"id": 4240, "sentence": ["approach", "trash", "can", "and", "whenever", "get", "to", "flag"], "tl": ["approach(trash_can)", "and", "finally", "(", "get_to(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "get", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"whenever get to flag\": \"globally (prop_2 implies finally prop_1)\","}
{"id": 5862, "sentence": ["when", "possible", "get", "close", "flag", "and", "go", "visit", "flag"], "tl": ["finally", "(", "get_close(flag)", ")", "and", "go_visit(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "go", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(i.e., not impossible), then eventually both actions should happen in order: first get close the flag, then go visit the flag. This can be expressed as: if eventually prop_1 is possible, then eventually prop_1 happens and then eventually prop_2 happens after that. Since we only have the given operators, we can express \"when possible\" as \"if eventually prop_1 then eventually (prop_1 and eventually prop_2)"}
{"id": 559, "sentence": ["never", "drop", "orange", "until", "put", "in", "bin"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "until", "put_in(bin)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "until", "prop_2"], "grounded_sentence": ["never", "prop_1", "until", "put", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}}, "prediction": "3. *FINAL:* (not prop_1) until prop_2 FINISH"}
{"id": 1216, "sentence": ["at", "any", "time", "be", "near", "tree", "or", "whenever", "going", "to", "house"], "tl": ["finally", "(", "be_near(tree)", ")", "or", "finally", "(", "going_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "whenever", "going", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 2050, "sentence": ["whenever", "secure", "pear", "and", "when", "possible", "scoop", "up", "pear"], "tl": ["finally", "(", "secure(pear)", ")", "and", "finally", "(", "scoop_up(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "when", "possible", "scoop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 6976, "sentence": ["at", "some", "time", "journey", "by", "flag", "until", "grab", "hold", "pear"], "tl": ["finally", "(", "journey_by(flag)", ")", "until", "grab_hold(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "grab", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "grab_hold", "action_ref": "grab hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(finally). The action \"journey by flag\" is represented by a proposition, say prop_1. The phrase \"until grab hold pear\" indicates that prop_1 holds until another proposition, say prop_2, becomes true. So, the formula is \"finally (prop_1 until prop_2)\".\n\n2. *Explanation dictionary* \u2013 {\"at some time\": \"F\", \"journey by flag\": \"prop_1\", \"until grab hold pear\": \"prop_1 U prop_2\"}\n\n3. *FINAL:* F (prop_1 U prop_2)"}
{"id": 2388, "sentence": ["whenever", "travel", "to", "house", "or", "at", "some", "time", "go", "by", "tree"], "tl": ["finally", "(", "travel_to(house)", ")", "or", "finally", "(", "go_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "some", "time", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(travel to house) holds, something else must follow. The phrase \"or at some time go by tree\" means that either the first condition holds, or eventually prop_2 (go by tree) holds. Combining these, the formula states that globally, either travel to house holds, or eventually go by tree holds.\n\n2. *Explanation dictionary* \u2013 {\"whenever travel to house\": \"G(prop_1 implies ...)\", \"or at some time go by tree\": \"or F prop_2\"}\n\n3. *FINAL:* G(prop_1) or F(prop_2)"}
{"id": 6457, "sentence": ["at", "some", "time", "reach", "flag", "means", "that", "at", "some", "time", "venture", "to", "house"], "tl": ["finally", "(", "reach(flag)", ")", "imply", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "means", "that", "at", "some", "time", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (implies (F prop_1) (F prop_2)) FINISH"}
{"id": 6361, "sentence": ["at", "some", "time", "make", "to", "flag", "until", "forever", "have", "in", "orange"], "tl": ["finally", "(", "make_to(flag)", ")", "until", "globally", "(", "have_in(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "globally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "forever", "have", "in", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_to", "action_ref": "make to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(F), indicating that something will eventually happen. The phrase \"make to flag\" is interpreted as achieving or setting \"prop_1\" (flag). The phrase \"until forever have in orange\" means that \"prop_2\" (orange) holds globally (forever). So the formula states: eventually prop_1 holds, and prop_2 holds globally.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at some time\": \"F\",\n  \"make to flag\": \"prop_1\",\n  \"until forever have in orange\": \"G prop_2\"\n}\n\n3. *FINAL:* (F prop_1) and (G prop_2)"}
{"id": 5064, "sentence": ["repeatedly", "grab", "tree", "or", "forever", "hold", "on", "pear"], "tl": ["globally", "(", "finally", "(", "grab(tree)", ")", ")", "or", "globally", "(", "hold_on(pear)", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "forever", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "hold_on", "action_ref": "hold on", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (globally (finally prop_1)) or (globally prop_2) FINISH"}
{"id": 410, "sentence": ["hold", "orange", "or", "at", "some", "time", "go", "to", "trash", "can"], "tl": ["hold(orange)", "or", "finally", "(", "go_to(trash_can)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 2642, "sentence": ["at", "some", "time", "bring", "pear", "until", "when", "possible", "reach", "flag"], "tl": ["finally", "(", "bring(pear)", ")", "until", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "when", "possible", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1 U prop_2)"}
{"id": 3419, "sentence": ["when", "possible", "make", "your", "way", "flag", "or", "always", "have", "apple"], "tl": ["finally", "(", "make_your_way(flag)", ")", "or", "globally", "(", "have(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "always", "have", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"when possible\": \"finally prop_1 or globally prop_2\""}
{"id": 5250, "sentence": ["acquire", "orange", "or", "whenever", "make", "your", "way", "flag"], "tl": ["acquire(orange)", "or", "finally", "(", "make_your_way(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "make", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(whenever make your way flag).\" However, the natural reading is \"acquire orange whenever make your way flag,\" so the formula is: globally (if prop_1 then eventually prop_2).\n\n2. *Explanation dictionary* \u2013 {\"make your way flag\": \"prop_1\", \"acquire orange\": \"prop_2\", \"whenever\": \"implies\", \"or\": \"or\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 6740, "sentence": ["at", "some", "time", "travel", "house", "or", "never", "drop", "orange"], "tl": ["finally", "(", "travel(house)", ")", "or", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel", "action_ref": "travel", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"travel house or never drop orange\": \"(prop_1 or globally not prop_2)\""}
{"id": 2017, "sentence": ["move", "to", "house", "or", "when", "possible", "get", "to", "cup"], "tl": ["move_to(house)", "or", "finally", "(", "get_to(cup)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "get", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["cup)"], "args_ref": ["cup)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 1300, "sentence": ["at", "any", "time", "scoop", "up", "apple", "and", "capture", "orange"], "tl": ["finally", "(", "scoop_up(apple)", ")", "and", "capture(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "capture", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* globally (prop_1 and prop_2) FINISH"}
{"id": 3815, "sentence": ["at", "any", "time", "get", "to", "cup", "or", "at", "any", "time", "grasp", "pear"], "tl": ["finally", "(", "get_to(cup)", ")", "or", "finally", "(", "grasp(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "any", "time", "grasp", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["cup)"], "args_ref": ["cup)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(finally) the proposition prop_1 (representing \"get to cup\") will be true. Similarly, \"at any time grasp pear\" means eventually (finally) prop_2 (representing \"grasp pear\") will be true. The \"or\" connects these two eventualities, so the formula states that eventually either prop_1 or prop_2 will be true.\n\n2. *Explanation dictionary* \u2013 {\"at any time get to cup\": \"F prop_1\", \"at any time grasp pear\": \"F prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 954, "sentence": ["venture", "towards", "house", "or", "when", "possible", "bring", "pear"], "tl": ["venture_towards(house)", "or", "finally", "(", "bring(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "bring", "pear", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 4757, "sentence": ["whenever", "venture", "to", "house", "and", "at", "some", "time", "go", "by", "waste", "basket"], "tl": ["finally", "(", "venture_to(house)", ")", "and", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "some", "time", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(venture to house) holds, something else must eventually happen. The phrase \"at some time go by waste basket\" means that eventually prop_2 (go by waste basket) must occur. Combining these, we get: globally, if prop_1 holds, then eventually prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"whenever venture to house\": \"prop_1\", \"at some time go by waste basket\": \"F prop_2\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 3152, "sentence": ["always", "touch", "flag", "or", "when", "possible", "approach", "house"], "tl": ["globally", "(", "touch(flag)", ")", "or", "finally", "(", "approach(house)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "or", "when", "possible", "approach", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* G (prop_1 or (prop_2 implies prop_3)) FINISH"}
{"id": 6491, "sentence": ["always", "moving", "until", "take", "to", "trashcan"], "tl": ["globally", "(", "moving", ")", "until", "take_to(trashcan)"], "masked_tl": ["globally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["always", "prop_1", "until", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "moving", "action_ref": "moving", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "3. *FINAL:* (globally prop_1) until prop_2 FINISH"}
{"id": 196, "sentence": ["whenever", "travel", "to", "house", "means", "that", "when", "possible", "move", "forward", "trash", "can"], "tl": ["finally", "(", "travel_to(house)", ")", "imply", "finally", "(", "move_forward(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "means", "that", "when", "possible", "move", "forward", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_forward", "action_ref": "move forward", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 3118, "sentence": ["repeatedly", "go", "to", "waste", "basket", "or", "whenever", "venture", "house"], "tl": ["globally", "(", "finally", "(", "go_to(waste_basket)", ")", ")", "or", "finally", "(", "venture(house)", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "whenever", "venture", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(G F), indicating that the event happens infinitely often. The phrase \"go to waste basket or whenever venture house\" corresponds to the proposition \"prop_1 or prop_2\" (assuming prop_1 = waste basket, prop_2 = venture house).\n\n2. *Explanation dictionary* \u2013 {\"repeatedly\": \"G F\", \"go to waste basket\": \"prop_1\", \"venture house\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G F (prop_1 or prop_2)"}
{"id": 3870, "sentence": ["capture", "orange", "and", "at", "some", "time", "go", "by", "house"], "tl": ["capture(orange)", "and", "finally", "(", "go_by(house)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_1 and finally prop_2) FINISH"}
{"id": 6876, "sentence": ["walk", "and", "put", "in", "bin"], "tl": ["walk", "and", "put_in(bin)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "prop_2"], "lifted_sentence_prop_ids": [1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk", "action_ref": "walk", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}}, "prediction": "3. *FINAL:* (prop_1 and prop_2) FINISH"}
{"id": 275, "sentence": ["at", "any", "time", "start", "going", "to", "tree", "or", "whenever", "acquire", "pear"], "tl": ["finally", "(", "start_going_to(tree)", ")", "or", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "whenever", "acquire", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(G), indicating the property holds always. The phrase \"start going to tree\" is represented by prop_1 (assuming prop_1 means \"start going to tree\"). The phrase \"or whenever acquire pear\" means either \"start going to tree\" or \"whenever acquire pear\" happens. \"Whenever acquire pear\" means that whenever prop_2 (acquire pear) happens, the property holds. Since the command is \"at any time start going to tree or whenever acquire pear,\" it means globally, either start going to tree holds, or whenever acquire pear holds. The \"whenever\" can be interpreted as \"if acquire pear happens, then something,\" but since the command is \"start going to tree or whenever acquire pear,\" it is a disjunction of \"start going to tree\" and \"whenever acquire pear.\" The \"whenever acquire pear\" can be interpreted as \"globally (acquire pear implies ...),\" but since no consequent is given, we interpret \"whenever acquire pear\" as \"acquire pear holds at some point,\" or simply prop_2. So the formula is G (prop_1 or prop_2)"}
{"id": 5248, "sentence": ["drop", "pear", "until", "at", "some", "time", "go", "to", "transh", "can"], "tl": ["drop(pear)", "until", "finally", "(", "go_to(transh_can)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["transh_can)"], "args_ref": ["transh can)"]}}, "prediction": "3. *FINAL:* (prop_1 until prop_2) FINISH"}
{"id": 5030, "sentence": ["at", "some", "time", "contact", "flag", "or", "at", "some", "time", "go", "past", "flag"], "tl": ["finally", "(", "contact(flag)", ")", "or", "finally", "(", "go_past(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_past", "action_ref": "go past", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 3133, "sentence": ["do", "not", "let", "go", "pear", "or", "at", "some", "time", "spend", "time", "at", "tree"], "tl": ["negation", "(", "let_go(pear)", ")", "or", "finally", "(", "spend_time_at(tree)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["do", "not", "prop_1", "or", "at", "some", "time", "spend", "time", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) or (finally prop_2) FINISH"}
{"id": 6408, "sentence": ["whenever", "journey", "to", "house", "or", "whenever", "travel", "to", "flag"], "tl": ["finally", "(", "journey_to(house)", ")", "or", "finally", "(", "travel_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(G) the implication that if either prop_1 or prop_2 holds, then something follows. Since no consequent is given, we can interpret the command as \"whenever journey to house or travel to flag occurs,\" i.e., globally, prop_1 or prop_2 holds. Alternatively, if the command is just to specify the occurrence of these events, the formula is G (prop_1 or prop_2).\n\n2. *Explanation dictionary* \u2013\n{\n  \"journey to house\": \"prop_1\",\n  \"travel to flag\": \"prop_2\",\n  \"whenever journey to house or whenever travel to flag\": \"G (prop_1 or prop_2)"}
{"id": 1333, "sentence": ["get", "hold", "of", "pear", "and", "hold", "pear"], "tl": ["get_hold_of(pear)", "and", "hold(pear)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "hold", "pear", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold_of", "action_ref": "get hold of", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(finally) the proposition prop_1 (representing \"get hold of pear\") becomes true.\n- \"and\" connects two conditions, so both must hold.\n- \"hold pear\" means globally (always) the proposition prop_2 (representing \"hold pear\") holds.\n\n2. *Explanation dictionary* \u2013 {\"get hold of pear\": \"F prop_1\", \"and\": \"and\", \"hold pear\": \"G prop_2\"}\n\n3. *FINAL:* (F prop_1) and (G prop_2)"}
{"id": 5607, "sentence": ["put", "in", "bin", "or", "at", "some", "time", "journey", "to", "house"], "tl": ["put_in(bin)", "or", "finally", "(", "journey_to(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "journey", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}, "prop_2": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 4827, "sentence": ["at", "any", "time", "clutch", "orange", "or", "repeatedly", "grab", "tree"], "tl": ["finally", "(", "clutch(orange)", ")", "or", "globally", "(", "finally", "(", "grab(tree)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "repeatedly", "grab", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "clutch", "action_ref": "clutch", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(G), meaning the property holds always. The phrase \"clutch orange or repeatedly grab tree\" is a disjunction of two conditions. \"clutch orange\" is represented by prop_1, and \"grab tree\" by prop_2. \"repeatedly grab tree\" means that \"grab tree\" happens infinitely often, which can be expressed as \"globally finally prop_2\" (G F prop_2). So the entire formula is: globally (prop_1 or globally finally prop_2).\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time\": \"G\",\n  \"clutch orange\": \"prop_1\",\n  \"grab tree\": \"prop_2\",\n  \"repeatedly grab tree\": \"G F prop_2\",\n  \"clutch orange or repeatedly grab tree\": \"(prop_1 or G F prop_2)\"\n}\n\n3. *FINAL:* G (prop_1 or G F prop_2)"}
{"id": 5715, "sentence": ["whenever", "track", "towards", "tree", "and", "at", "some", "time", "get", "near", "flag"], "tl": ["finally", "(", "track_towards(tree)", ")", "and", "finally", "(", "get_near(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "some", "time", "get", "near", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "track_towards", "action_ref": "track towards", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "get_near", "action_ref": "get near", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(get near flag) must be true. So, the entire command means: globally, if prop_1 holds, then eventually prop_2 will hold.\n\n2. *Explanation dictionary* \u2013 {\"whenever track towards tree\": \"prop_1\", \"at some time get near flag\": \"F prop_2\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 1999, "sentence": ["secure", "apple", "or", "at", "some", "time", "withhold", "apple"], "tl": ["secure(apple)", "or", "finally", "(", "withhold(apple)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "withhold", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 1465, "sentence": ["at", "some", "time", "make", "contact", "with", "house", "and", "when", "possible", "obtain", "orange"], "tl": ["finally", "(", "make_contact_with(house)", ")", "and", "finally", "(", "obtain(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "when", "possible", "obtain", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (F prop_1) and (G (prop_2 implies prop_3)) FINISH"}
{"id": 1183, "sentence": ["whenever", "make", "contact", "with", "house", "or", "when", "possible", "procure", "pear"], "tl": ["finally", "(", "make_contact_with(house)", ")", "or", "finally", "(", "procure(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "procure", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_2) should eventually happen. The word \"possible\" suggests that \"procure pear\" should eventually occur, so we use finally (F) for prop_2. The entire formula states that whenever prop_1 holds, then eventually prop_2 should hold, or prop_1 itself holds. Since the command is \"whenever ... or when possible ...\", the formula is a globally (G) statement that either prop_1 holds or eventually prop_2 holds.\n\n2. *Explanation dictionary* \u2013\n{\n  \"make contact with house\": \"prop_1\",\n  \"procure pear\": \"prop_2\",\n  \"whenever ... or when possible ...\": \"G (prop_1 or F prop_2)\"\n}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 4713, "sentence": ["when", "forever", "go", "by", "trash", "can", ",", "whenever", "get", "hold", "apple"], "tl": ["globally", "(", "go_by(trash_can)", ")", "imply", "finally", "(", "get_hold(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "forever", "prop_1", ",", "whenever", "get", "hold", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (G prop_1) and (G (prop_2 implies prop_1)) FINISH"}
{"id": 3479, "sentence": ["when", "possible", "obtain", "orange", "and", "take", "pear"], "tl": ["finally", "(", "obtain(orange)", ")", "and", "take(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (F prop_1) implies (F (prop_1 and prop_2)) FINISH"}
{"id": 6390, "sentence": ["pick", "up", "flag", "until", "at", "any", "time", "pick", "up", "apple"], "tl": ["pick_up(flag)", "until", "finally", "(", "pick_up(apple)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "any", "time", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1) U (F prop_2)"}
{"id": 1396, "sentence": ["always", "go", "by", "trash", "can", "or", "at", "any", "time", "go", "to", "peach"], "tl": ["globally", "(", "go_by(trash_can)", ")", "or", "finally", "(", "go_to(peach)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "or", "at", "any", "time", "go", "to", "peach", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["peach)"], "args_ref": ["peach)"]}}, "prediction": "(prop_1) or \"at any time go to peach\" (F prop_2). The \"or\" connects these two conditions. Since the command is \"always (go by trash can or eventually go to peach)\", the entire formula is G (prop_1 or F prop_2).\n\n2. *Explanation dictionary* \u2013 {\"always\": \"G\", \"go by trash can\": \"prop_1\", \"or\": \"or\", \"at any time go to peach\": \"F prop_2\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 909, "sentence": ["always", "hold", "onto", "orange", "until", "when", "possible", "get", "close", "tree"], "tl": ["globally", "(", "hold_onto(orange)", ")", "until", "finally", "(", "get_close(tree)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "until", "when", "possible", "get", "close", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(prop_1 U prop_2)\", \"possible get close tree\": \"prop_2\", \"hold onto orange\": \"prop_1\"}\n\n3. *FINAL:* G (prop_1 U prop_2)"}
{"id": 4180, "sentence": ["whenever", "procure", "orange", "until", "when", "possible", "shift", "to", "flag"], "tl": ["finally", "(", "procure(orange)", ")", "until", "finally", "(", "shift_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "until", "when", "possible", "shift", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "shift_to", "action_ref": "shift to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* G(prop_1 implies (prop_1 U prop_2)) FINISH"}
{"id": 4284, "sentence": ["move", "to", "house", "until", "at", "some", "time", "travel", "to", "trash", "can"], "tl": ["move_to(house)", "until", "finally", "(", "travel_to(trash_can)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "some", "time", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(U), and \"at some time\" corresponds to \"eventually\" (F). So, \"travel to trash can\" is an event that will eventually happen, and \"move to house\" holds until that event.\n\n2. *Explanation dictionary* \u2013\n{\n  \"move to house\": \"prop_1\",\n  \"travel to trash can\": \"prop_2\",\n  \"until\": \"U\",\n  \"at some time\": \"F\"\n}\n\n3. *FINAL:* (prop_1 U prop_2)"}
{"id": 7308, "sentence": ["whenever", "reach", "flag", "or", "go", "by", "waste", "bin"], "tl": ["finally", "(", "reach(flag)", ")", "or", "go_by(waste_bin)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "(prop_1 or prop_2)\", \"whenever reach flag or go by waste bin\": \"G(prop_1 or prop_2)\"}\n\n3. *FINAL:* G(prop_1 or prop_2)"}
{"id": 2776, "sentence": ["never", "drop", "apple", "or", "whenever", "go", "by", "waste", "basket"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(prop_2 implies ...)\" where prop_2 represents \"go by waste basket\". Since the command connects these two parts with \"or\", the overall formula is \"globally (not prop_1 or (prop_2 implies ...))\". However, the command is \"never drop apple or whenever go by waste basket\", which can be interpreted as \"either never drop apple, or whenever you go by the waste basket\". Since the second part is incomplete, we interpret \"whenever go by waste basket\" as a condition that triggers some behavior, but since no further action is specified, we only encode the condition as prop_2. Therefore, the formula is \"globally (not prop_1 or prop_2)\".\n\n2. *Explanation dictionary* \u2013 {\"never drop apple\": \"globally (not prop_1)\", \"drop apple\": \"prop_1\", \"go by waste basket\": \"prop_2\", \"whenever go by waste basket\": \"globally (prop_2 implies true)"}
{"id": 4056, "sentence": ["whenever", "snatch", "pear", "or", "venture", "to", "trash", "can"], "tl": ["finally", "(", "snatch(pear)", ")", "or", "venture_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch", "action_ref": "snatch", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 6444, "sentence": ["acquire", "orange", "or", "when", "possible", "let", "go", "apple"], "tl": ["acquire(orange)", "or", "finally", "(", "let_go(apple)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "let", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or prop_2) FINISH"}
{"id": 5599, "sentence": ["do", "not", "let", "go", "pear", "and", "don't", "let", "go", "pear"], "tl": ["negation", "(", "let_go(pear)", ")", "and", "negation", "(", "let_go(pear)", ")"], "masked_tl": ["negation", "(", "prop_2", ")", "and", "negation", "(", "prop_2", ")"], "grounded_sentence": ["do", "not", "prop_1", "and", "don't", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (not prop_1) and (not prop_1) FINISH"}
{"id": 6982, "sentence": ["at", "some", "time", "present", "at", "flag", "or", "never", "drop", "apple"], "tl": ["finally", "(", "present_at(flag)", ")", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (F prop_1) or (G not prop_2) FINISH"}
{"id": 896, "sentence": ["at", "some", "time", "present", "at", "flag", "means", "that", "whenever", "venture", "to", "house"], "tl": ["finally", "(", "present_at(flag)", ")", "imply", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "means", "that", "whenever", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F prop_1), where prop_1 represents \"present at flag\". The phrase \"whenever venture to house\" corresponds to \"globally (prop_2 implies ...)\", where prop_2 represents \"venture to house\". The command means that whenever \"venture to house\" happens, then at some time \"present at flag\" holds. So the formula is: globally (prop_2 implies finally prop_1).\n\n2. *Explanation dictionary* \u2013 {\"at some time present at flag\": \"F prop_1\", \"whenever venture to house\": \"G (prop_2 implies ...)\", \"venture to house\": \"prop_2\", \"present at flag\": \"prop_1\"}\n\n3. *FINAL:* G (prop_2 implies F prop_1)"}
{"id": 6665, "sentence": ["grasp", "orange", "until", "move", "to", "trash", "can"], "tl": ["grasp(orange)", "until", "move_to(trash_can)"], "masked_tl": ["prop_1", "until", "prop_2"], "grounded_sentence": ["prop_1", "until", "move", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (prop_1 until prop_2) FINISH"}
{"id": 6325, "sentence": ["going", "to", "tree", "and", "when", "possible", "stop", "by", "trash", "can"], "tl": ["going_to(tree)", "and", "finally", "(", "stop_by(trash_can)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "stop", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (prop_1 and finally prop_2) FINISH"}
{"id": 2099, "sentence": ["when", "possible", "collect", "orange", "or", "when", "possible", "reach", "tree"], "tl": ["finally", "(", "collect(orange)", ")", "or", "finally", "(", "reach(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(F) to express \"when possible\" (eventually), and or to combine the two options.\n\n2. *Explanation dictionary* \u2013 {\"when possible collect orange\": \"F prop_1\", \"when possible reach tree\": \"F prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 267, "sentence": ["venture", "towards", "house", "or", "when", "possible", "reach", "flag"], "tl": ["venture_towards(house)", "or", "finally", "(", "reach(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "reach", "flag", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 2784, "sentence": ["whenever", "be", "near", "tree", "or", "whenever", "withold", "apple"], "tl": ["finally", "(", "be_near(tree)", ")", "or", "finally", "(", "withold(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "withold", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "withold", "action_ref": "withold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"whenever be near tree or whenever withold apple\": \"globally (prop_1 implies prop_2) or globally (prop_3 implies prop_4)\""}
{"id": 3782, "sentence": ["seize", "apple", "or", "put", "in", "apple", "bucket"], "tl": ["seize(apple)", "or", "put_in(apple_bucket)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "put", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["apple_bucket)"], "args_ref": ["apple bucket)"]}}, "prediction": "(F) operator over the disjunction.\n\n2. *Explanation dictionary* \u2013 {\"seize apple\": \"prop_1\", \"put in apple bucket\": \"prop_2\", \"seize apple or put in apple bucket\": \"prop_1 or prop_2\", \"eventually (seize apple or put in apple bucket)\": \"F (prop_1 or prop_2)\"}\n\n3. *FINAL:* F (prop_1 or prop_2)"}
{"id": 4142, "sentence": ["take", "to", "trashcan", "or", "take", "to", "trashcan"], "tl": ["take_to(trashcan)", "or", "take_to(trashcan)"], "masked_tl": ["prop_2", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "take", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "3. *FINAL:* (prop_1 or prop_1) FINISH"}
{"id": 364, "sentence": ["at", "any", "time", "track", "towards", "tree", "and", "whenever", "stop", "by", "house"], "tl": ["finally", "(", "track_towards(tree)", ")", "and", "finally", "(", "stop_by(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "whenever", "stop", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "track_towards", "action_ref": "track towards", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* G((prop_2 implies prop_1) and prop_1) FINISH"}
{"id": 2589, "sentence": ["whenever", "procure", "pear", "and", "when", "possible", "pick", "up", "apple"], "tl": ["finally", "(", "procure(pear)", ")", "and", "finally", "(", "pick_up(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "when", "possible", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* G (prop_1 implies (prop_2 implies F prop_3"}
{"id": 5690, "sentence": ["when", "possible", "venture", "to", "house", "or", "at", "some", "time", "venture", "to", "house"], "tl": ["finally", "(", "venture_to(house)", ")", "or", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["finally", "(", "prop_2", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "some", "time", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_2 implies (F prop_1)) FINISH"}
{"id": 6689, "sentence": ["when", "going", "to", "tree", ",", "whenever", "travel", "to", "trash", "can"], "tl": ["going_to(tree)", "imply", "finally", "(", "travel_to(trash_can)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "prop_1", ",", "whenever", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(travel to trash can) must eventually happen.\n- This is captured by globally (G) stating that if prop_1 holds, then eventually (F) prop_2 holds.\n\n2. Explanation dictionary:\n{\"when going to tree\": \"prop_1\", \"whenever travel to trash can\": \"G (prop_1 implies F prop_2)\"}\n\n3. FINAL: G (prop_1 implies F prop_2)"}
{"id": 6539, "sentence": ["grip", "apple", "or", "repeatedly", "go", "to", "apple", "trashcan"], "tl": ["grip(apple)", "or", "globally", "(", "finally", "(", "go_to(apple_trashcan)", ")", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "or", "repeatedly", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grip", "action_ref": "grip", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple_trashcan)"], "args_ref": ["apple trashcan)"]}}, "prediction": "3. *FINAL:* (prop_1 or (globally (finally prop_2))) FINISH"}
{"id": 6314, "sentence": ["at", "any", "time", "migrate", "to", "tree", "or", "at", "some", "time", "go", "to", "transh", "can"], "tl": ["finally", "(", "migrate_to(tree)", ")", "or", "finally", "(", "go_to(transh_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "some", "time", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "migrate_to", "action_ref": "migrate to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["transh_can)"], "args_ref": ["transh can)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 6555, "sentence": ["do", "not", "let", "go", "pear", "or", "at", "some", "time", "clutch", "orange"], "tl": ["negation", "(", "let_go(pear)", ")", "or", "finally", "(", "clutch(orange)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["do", "not", "prop_1", "or", "at", "some", "time", "clutch", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "clutch", "action_ref": "clutch", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) or (finally prop_2) FINISH"}
{"id": 3578, "sentence": ["drop", "by", "and", "pick", "up", "orange"], "tl": ["drop_by", "and", "pick_up(orange)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "pick", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop_by", "action_ref": "drop by", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1 and F prop_2)\"}\n\n3. *FINAL:* F (prop_1 and F prop_2)"}
{"id": 1247, "sentence": ["drop", "by", "and", "hold", "orange"], "tl": ["drop_by", "and", "hold(orange)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "hold", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop_by", "action_ref": "drop by", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(F(prop_1 and prop_2) and F(prop_3 and prop_2)) FINISH"}
{"id": 1514, "sentence": ["if", "whenever", "go", "by", "house", ",", "at", "any", "time", "steal", "apple"], "tl": ["finally", "(", "go_by(house)", ")", "imply", "finally", "(", "steal(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "whenever", "prop_1", ",", "at", "any", "time", "steal", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "steal", "action_ref": "steal", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 5043, "sentence": ["reach", "trash", "can", "or", "whenever", "journey", "by", "house"], "tl": ["reach(trash_can)", "or", "finally", "(", "journey_by(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "journey", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (F prop_1) or (G (prop_2 implies F prop_1)) FINISH"}
{"id": 2910, "sentence": ["whenever", "make", "to", "flag", "or", "grip", "apple"], "tl": ["finally", "(", "make_to(flag)", ")", "or", "grip(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "grip", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_to", "action_ref": "make to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "grip", "action_ref": "grip", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* G ((prop_1 or prop_2) implies true) FINISH"}
{"id": 1602, "sentence": ["grab", "hold", "pear", "and", "whenever", "track", "towards", "tree"], "tl": ["grab_hold(pear)", "and", "finally", "(", "track_towards(tree)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "track", "towards", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab_hold", "action_ref": "grab hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "track_towards", "action_ref": "track towards", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "- The first part holds globally: G(prop_1 and prop_2 and prop_3)"}
{"id": 3134, "sentence": ["when", "when", "possible", "make", "contact", "with", "house", ",", "gather", "orange"], "tl": ["finally", "(", "make_contact_with(house)", ")", "imply", "gather(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["when", "when", "possible", "prop_1", ",", "gather", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "gather", "action_ref": "gather", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(F prop_1), and \"gather orange\" should happen after that, so \"after prop_1, eventually prop_2\" (F prop_1 \u2192 F prop_2). Since the command is a single instruction, we combine these as \"if eventually prop_1, then eventually prop_2\".\n\n2. *Explanation dictionary* \u2013 {\"when possible\": \"F prop_1\", \"make contact with house\": \"prop_1\", \"gather orange\": \"prop_2\"}\n\n3. *FINAL:* (F prop_1) implies (F prop_2)"}
{"id": 5821, "sentence": ["when", "possible", "visit", "trash", "bin", "means", "that", "reach", "house"], "tl": ["finally", "(", "visit(trash_bin)", ")", "imply", "reach(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "means", "that", "reach", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(G) stating that if prop_1 is true at some point, then finally (F) prop_2 will be true.\n\n2. *Explanation dictionary* \u2013 {\"visit trash bin\": \"prop_1\", \"reach house\": \"prop_2\", \"when possible\": \"G (prop_1 implies F prop_2)\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 7470, "sentence": ["approach", "trash", "can", "or", "whenever", "got", "to", "house"], "tl": ["approach(trash_can)", "or", "finally", "(", "got_to(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "got", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "got_to", "action_ref": "got to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_1 or globally prop_2) FINISH"}
{"id": 6372, "sentence": ["move", "to", "tree", "or", "when", "possible", "set", "out", "to", "house"], "tl": ["move_to(tree)", "or", "finally", "(", "set_out_to(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "set", "out", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "set_out_to", "action_ref": "set out to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "     \"or\": \"or\""}
{"id": 1222, "sentence": ["gather", "apple", "means", "that", "at", "any", "time", "visit", "house"], "tl": ["gather(apple)", "imply", "finally", "(", "visit(house)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "means", "that", "at", "any", "time", "visit", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "gather", "action_ref": "gather", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies prop_2) FINISH"}
{"id": 4035, "sentence": ["whenever", "obtain", "orange", "and", "capture", "orange"], "tl": ["finally", "(", "obtain(orange)", ")", "and", "capture(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "capture", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(G) and implies. The condition is \"obtain orange and capture orange,\" so we use prop_1 for \"obtain orange\" and prop_2 for \"capture orange.\" The formula is: globally ( (prop_1 and prop_2) implies (prop_1 and prop_2) )"}
{"id": 2952, "sentence": ["go", "by", "waste", "bin", "means", "that", "when", "possible", "present", "at", "flag"], "tl": ["go_by(waste_bin)", "imply", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "means", "that", "when", "possible", "present", "at", "flag", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 implies (F prop_2)) FINISH"}
{"id": 4011, "sentence": ["at", "some", "time", "venture", "to", "house", "or", "secure", "apple"], "tl": ["finally", "(", "venture_to(house)", ")", "or", "secure(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "secure", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 511, "sentence": ["hold", "pear", "or", "at", "some", "time", "go", "to", "home"], "tl": ["hold(pear)", "or", "finally", "(", "go_to(home)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or prop_2) FINISH"}
{"id": 6548, "sentence": ["whenever", "make", "contact", "flag", "or", "at", "some", "time", "be", "at", "house"], "tl": ["finally", "(", "make_contact(flag)", ")", "or", "finally", "(", "be_at(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "some", "time", "be", "at", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact", "action_ref": "make contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "be_at", "action_ref": "be at", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 763, "sentence": ["if", "when", "possible", "go", "visit", "house", ",", "when", "possible", "walk", "to", "flag"], "tl": ["finally", "(", "go_visit(house)", ")", "imply", "finally", "(", "walk_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "when", "possible", "prop_1", ",", "when", "possible", "walk", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (globally (prop_1 implies finally prop_2)) and (globally (prop_3 implies finally prop_4))"}
{"id": 2293, "sentence": ["whenever", "proceed", "to", "flag", "or", "whenever", "go", "to", "apple"], "tl": ["finally", "(", "proceed_to(flag)", ")", "or", "finally", "(", "go_to(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (globally (prop_1 implies true)) and (globally (prop_2 implies true)) FINISH"}
{"id": 516, "sentence": ["forever", "have", "apple", "and", "when", "possible", "travel", "by", "tree"], "tl": ["globally", "(", "have(apple)", ")", "and", "finally", "(", "travel_by(tree)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "and", "when", "possible", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "travel_by", "action_ref": "travel by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"when possible travel by tree\": \"globally(prop_2 implies finally(prop_3))\","}
{"id": 1389, "sentence": ["at", "some", "time", "touch", "tree", "or", "whenever", "pass", "by", "waste", "receptacle"], "tl": ["finally", "(", "touch(tree)", ")", "or", "finally", "(", "pass_by(waste_receptacle)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "whenever", "pass", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["waste_receptacle)"], "args_ref": ["waste receptacle)"]}}, "prediction": "(F prop_1), where prop_1 represents \"touch tree\". The phrase \"whenever pass by waste receptacle\" corresponds to \"globally (prop_2 implies ...)\", where prop_2 represents \"pass by waste receptacle\". The \"or\" connects these two conditions, so the overall formula is \"F prop_1 or G (prop_2 implies ... )\". Since the command does not specify what should happen whenever passing by the waste receptacle, we interpret it as \"whenever pass by waste receptacle\" alone, which is \"G prop_2\". But since the command is \"at some time touch tree or whenever pass by waste receptacle\", the simplest interpretation is \"F prop_1 or G prop_2\".\n\n2. *Explanation dictionary* \u2013 {\"at some time touch tree\": \"F prop_1\", \"whenever pass by waste receptacle\": \"G prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (F prop_1) or (G prop_2)"}
{"id": 4587, "sentence": ["whenever", "get", "hold", "orange", "and", "go", "to", "orange"], "tl": ["finally", "(", "get_hold(orange)", ")", "and", "go_to(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(get hold orange and go to orange) holds, it holds globally.\" To express \"whenever\" in LTL, we use globally (G) to say that always, if the condition holds, then the condition holds (tautology). More meaningfully, we can represent the condition as a proposition, say prop_1, representing \"get hold orange and go to orange.\" Since the command is just \"whenever get hold orange and go to orange,\" the formula is G(prop_1), meaning \"always, get hold orange and go to orange\" or \"whenever get hold orange and go to orange, it is true.\"\n\nAlternatively, if the command is interpreted as \"whenever get hold orange, then go to orange,\" then the formula is G(prop_1 implies prop_2)"}
{"id": 6224, "sentence": ["gather", "orange", "or", "whenever", "obtain", "orange"], "tl": ["gather(orange)", "or", "finally", "(", "obtain(orange)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "obtain", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "gather", "action_ref": "gather", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1) happens, then \"gather orange\" (prop_2) should follow. This can be expressed as globally (G), if prop_1 is true, then eventually (F) prop_2 will be true.\n\n2. *Explanation dictionary* \u2013 {\"obtain orange\": \"prop_1\", \"gather orange\": \"prop_2\", \"whenever obtain orange\": \"G (prop_1 implies F prop_2)\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 143, "sentence": ["when", "possible", "grab", "orange", "or", "pick", "up", "fruit"], "tl": ["finally", "(", "grab(orange)", ")", "or", "pick_up(fruit)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "or", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["fruit)"], "args_ref": ["fruit)"]}}, "prediction": "(finally) one of these actions should happen.\n\n2. *Explanation dictionary* \u2013 {\"grab orange\": \"prop_1\", \"pick up fruit\": \"prop_2\", \"grab orange or pick up fruit\": \"(prop_1 or prop_2)\", \"when possible\": \"F\"}\n\n3. *FINAL:* F (prop_1 or prop_2)"}
{"id": 5220, "sentence": ["at", "any", "time", "get", "apple", "and", "at", "any", "time", "get", "orange"], "tl": ["finally", "(", "get(apple)", ")", "and", "finally", "(", "get(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "any", "time", "get", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "get", "action_ref": "get", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"and\": \"and\""}
{"id": 1409, "sentence": ["whenever", "go", "to", "trash", "bin", "or", "whenever", "venture", "to", "waste", "basket"], "tl": ["finally", "(", "go_to(trash_bin)", ")", "or", "finally", "(", "venture_to(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "venture", "to", "waste", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(always) condition that if a certain proposition holds, then some property follows. Here, the propositions are \"go to trash bin\" and \"venture to waste basket\". Since the command does not specify what should happen after these events, we interpret it as stating that these events occur globally or that the system should always be ready for these events. To capture the \"whenever ... or whenever ...\" structure, we use globally (G) applied to the disjunction of the two propositions.\n\n2. *Explanation dictionary* \u2013\n{\n  \"whenever go to trash bin\": \"G prop_1\",\n  \"whenever venture to waste basket\": \"G prop_2\",\n  \"go to trash bin or whenever venture to waste basket\": \"G (prop_1 or prop_2)\"\n}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 2548, "sentence": ["move", "to", "trash", "can", "until", "at", "any", "time", "go", "by", "tree"], "tl": ["move_to(trash_can)", "until", "finally", "(", "go_by(tree)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "any", "time", "go", "by", "tree", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(finally) prop_2 (go by tree) will happen. The word \"until\" connects these two parts, so the system should keep \"move to trash can\" (prop_1) true until \"go by tree\" (prop_2) happens at some point in the future.\n\n2. *Explanation dictionary* \u2013 {\"move to trash can\": \"prop_1\", \"at any time go by tree\": \"F prop_2\", \"until\": \"U\"}\n\n3. *FINAL:* (prop_1) U (F prop_2)"}
{"id": 6461, "sentence": ["when", "possible", "obtain", "pear", "or", "whenever", "venture", "to", "flag"], "tl": ["finally", "(", "obtain(pear)", ")", "or", "finally", "(", "venture_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "whenever", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (F prop_1) or (G (prop_2 implies F prop_1)) FINISH"}
{"id": 4605, "sentence": ["when", "possible", "tax", "apple", "or", "whenever", "reach", "tree"], "tl": ["finally", "(", "tax(apple)", ")", "or", "finally", "(", "reach(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "whenever", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"tax apple\": \"(prop_1 and prop_2)\","}
{"id": 1490, "sentence": ["whenever", "go", "to", "home", "and", "when", "possible", "be", "near", "tree"], "tl": ["finally", "(", "go_to(home)", ")", "and", "finally", "(", "be_near(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "when", "possible", "be", "near", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* G (prop_1 implies (F prop_2 implies F prop_3)) FINISH"}
{"id": 1805, "sentence": ["repeatedly", "go", "to", "waste", "basket", "or", "never", "drop", "orange"], "tl": ["globally", "(", "finally", "(", "go_to(waste_basket)", ")", ")", "or", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "never", "drop", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or not prop_2) FINISH"}
{"id": 6419, "sentence": ["if", "hold", "pear", ",", "whenever", "start", "going", "to", "tree"], "tl": ["hold(pear)", "imply", "finally", "(", "start_going_to(tree)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "prop_1", ",", "whenever", "start", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(G) stating that whenever prop_2 is true, prop_1 is also true, i.e., G (prop_2 \u2192 prop_1).\n\n2. *Explanation dictionary* \u2013 {\"if hold pear\": \"prop_1\", \"whenever start going to tree\": \"G (prop_2 \u2192 prop_1)\"}\n\n3. *FINAL:* G (prop_2 implies prop_1)"}
{"id": 5097, "sentence": ["whenever", "journey", "by", "house", "or", "when", "possible", "get", "to", "cup"], "tl": ["finally", "(", "journey_by(house)", ")", "or", "finally", "(", "get_to(cup)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "get", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["cup)"], "args_ref": ["cup)"]}}, "prediction": "(prop_2). The \"whenever\" at the start implies a globally condition: whenever prop_1 holds, then eventually prop_2 should hold. Since \"or when possible get to cup\" is an alternative condition, we interpret the command as: globally, if journey by house occurs or if possible, then eventually get to cup.\n\n2. *Explanation dictionary* \u2013 {\"journey by house\": \"prop_1\", \"get to cup\": \"prop_2\", \"whenever journey by house or when possible get to cup\": \"G (prop_1 or F prop_2)\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 1790, "sentence": ["never", "drop", "apple", "or", "approach", "tree"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "or", "approach(tree)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "prop_2"], "grounded_sentence": ["never", "prop_1", "or", "approach", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (not (prop_1 or prop_2)) FINISH"}
{"id": 6973, "sentence": ["when", "whenever", "go", "home", ",", "collect", "pear"], "tl": ["finally", "(", "go(home)", ")", "imply", "collect(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["when", "whenever", "prop_1", ",", "collect", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_1) holds, then \"collect pear\" (prop_2) should eventually happen. This is captured by globally (G) stating that if prop_1 is true, then eventually (F) prop_2 will be true.\n\n2. *Explanation dictionary* \u2013 {\"whenever go home\": \"G (prop_1 implies F prop_2)\", \"collect pear\": \"prop_2\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 1982, "sentence": ["when", "possible", "walk", "to", "flag", "until", "when", "possible", "have", "possession", "of", "apple"], "tl": ["finally", "(", "walk_to(flag)", ")", "until", "finally", "(", "have_possession_of(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "until", "when", "possible", "have", "possession", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "have_possession_of", "action_ref": "have possession of", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_2). So, the formula states that globally, if it is possible to walk to the flag (prop_1), then walk to the flag until it is possible to have possession of the apple (prop_2).\n\n2. *Explanation dictionary* \u2013 {\"when possible walk to flag\": \"prop_1\", \"when possible have possession of apple\": \"prop_2\", \"walk to flag until have possession of apple\": \"prop_1 U prop_2\"}\n\n3. *FINAL:* G (prop_1 \u2192 (prop_1 U prop_2))"}
{"id": 1487, "sentence": ["at", "some", "time", "bring", "pear", "and", "venture", "towards", "house"], "tl": ["finally", "(", "bring(pear)", ")", "and", "venture_towards(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F), indicating that what follows should happen eventually. The phrase \"bring pear and venture towards house\" involves two actions combined with \"and,\" so we use the Boolean \"and\" operator to combine the propositions representing these actions. We assign \"bring pear\" to prop_1 and \"venture towards house\" to prop_2. Thus, the entire command translates to \"eventually (prop_1 and prop_2).\"\n\n2. *Explanation dictionary* \u2013 {\"at some time\": \"F\", \"bring pear\": \"prop_1\", \"venture towards house\": \"prop_2\", \"and\": \"and\"}\n\n3. *FINAL:* F (prop_1 and prop_2)"}
{"id": 3053, "sentence": ["never", "drop", "apple", "and", "move", "towards", "trash", "can"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "and", "move_towards(trash_can)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "and", "prop_2"], "grounded_sentence": ["never", "prop_1", "and", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "move_towards", "action_ref": "move towards", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) and prop_2 FINISH"}
{"id": 4997, "sentence": ["keep", "apple", "or", "when", "possible", "venture", "flag"], "tl": ["keep(apple)", "or", "finally", "(", "venture(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "venture", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "keep", "action_ref": "keep", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1). The phrase \"or when possible venture flag\" suggests that if \"apple\" is not kept, then eventually \"venture flag\" (prop_2) should happen. So the formula is: globally (prop_1) or finally (prop_2).\n\n2. *Explanation dictionary* \u2013 {\"keep apple\": \"G prop_1\", \"when possible venture flag\": \"F prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (G prop_1) or (F prop_2)"}
{"id": 5415, "sentence": ["when", "possible", "grab", "pear", "and", "whenever", "go", "to", "home"], "tl": ["finally", "(", "grab(pear)", ")", "and", "finally", "(", "go_to(home)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "3. *FINAL:* (finally prop_1) and (globally (prop_2 implies true)) FINISH"}
{"id": 5172, "sentence": ["visit", "tree", "and", "at", "some", "time", "haul", "pear"], "tl": ["visit(tree)", "and", "finally", "(", "haul(pear)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "haul", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "haul", "action_ref": "haul", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(finally) prop_2 (haul pear)"}
{"id": 5143, "sentence": ["when", "possible", "lay", "hold", "of", "apple", "or", "forever", "hold", "on", "pear"], "tl": ["finally", "(", "lay_hold_of(apple)", ")", "or", "globally", "(", "hold_on(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "forever", "hold", "on", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "lay_hold_of", "action_ref": "lay hold of", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "hold_on", "action_ref": "hold on", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (globally prop_2) FINISH"}
{"id": 5593, "sentence": ["at", "any", "time", "grab", "orange", "means", "that", "at", "any", "time", "seize", "orange"], "tl": ["finally", "(", "grab(orange)", ")", "imply", "finally", "(", "seize(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "means", "that", "at", "any", "time", "seize", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies prop_2) FINISH"}
{"id": 5049, "sentence": ["keep", "apple", "or", "at", "some", "time", "visit", "trash", "bin"], "tl": ["keep(apple)", "or", "finally", "(", "visit(trash_bin)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "visit", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "keep", "action_ref": "keep", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "3. *FINAL:* (globally prop_1) or (finally prop_2) FINISH"}
{"id": 3739, "sentence": ["grasp", "orange", "and", "travel", "to", "waste", "bin"], "tl": ["grasp(orange)", "and", "travel_to(waste_bin)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "travel", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "  \"and\": \"and\""}
{"id": 6480, "sentence": ["take", "to", "trash", "can", "and", "whenever", "have", "possession", "of", "apple"], "tl": ["take_to(trash_can)", "and", "finally", "(", "have_possession_of(apple)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "have", "possession", "of", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "have_possession_of", "action_ref": "have possession of", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* finally(prop_1) and globally(prop_2) FINISH"}
{"id": 1059, "sentence": ["move", "to", "trashcan", "or", "at", "some", "time", "snag", "orange"], "tl": ["move_to(trashcan)", "or", "finally", "(", "snag(orange)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "snag", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 5507, "sentence": ["grab", "hold", "pear", "and", "do", "not", "let", "go", "pear"], "tl": ["grab_hold(pear)", "and", "negation", "(", "let_go(pear)", ")"], "masked_tl": ["prop_1", "and", "negation", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "do", "not", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab_hold", "action_ref": "grab hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (F prop_1) and (G (not prop_2)) FINISH"}
{"id": 4055, "sentence": ["venture", "towards", "house", "and", "never", "drop", "apple"], "tl": ["venture_towards(house)", "and", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["prop_1", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 and globally (not prop_2)) FINISH"}
{"id": 197, "sentence": ["at", "some", "time", "withhold", "apple", "or", "at", "some", "time", "venture", "to", "house"], "tl": ["finally", "(", "withhold(apple)", ")", "or", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F), indicating that something eventually happens. The phrase \"withhold apple\" is represented by a proposition, say prop_1. The phrase \"venture to house\" is represented by another proposition, say prop_2. The command says \"at some time withhold apple or at some time venture to house,\" which translates to \"finally prop_1 or finally prop_2.\"\n\n2. *Explanation dictionary* \u2013 {\"at some time\": \"F\", \"withhold apple\": \"prop_1\", \"venture to house\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 3741, "sentence": ["whenever", "yield", "pear", "or", "always", "hold", "onto", "orange"], "tl": ["finally", "(", "yield(pear)", ")", "or", "globally", "(", "hold_onto(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "always", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "yield", "action_ref": "yield", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or globally prop_2) FINISH"}
{"id": 2715, "sentence": ["hold", "on", "to", "pear", "and", "whenever", "get", "to", "cup"], "tl": ["hold_on_to(pear)", "and", "finally", "(", "get_to(cup)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "get", "to", "cup", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold_on_to", "action_ref": "hold on to", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["cup)"], "args_ref": ["cup)"]}}, "prediction": "3. *FINAL:* (globally(prop_1) and globally(prop_2 implies prop_1)) FINISH"}
{"id": 3824, "sentence": ["grip", "apple", "and", "never", "drop", "orange"], "tl": ["grip(apple)", "and", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["prop_1", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grip", "action_ref": "grip", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 and globally (not prop_2)) FINISH"}
{"id": 3786, "sentence": ["drop", "orange", "and", "hold", "pear"], "tl": ["drop(orange)", "and", "hold(pear)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "hold", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (prop_1 and prop_2) FINISH"}
{"id": 4350, "sentence": ["at", "some", "time", "present", "at", "flag", "or", "secure", "apple"], "tl": ["finally", "(", "present_at(flag)", ")", "or", "secure(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "secure", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 5553, "sentence": ["when", "possible", "get", "close", "tree", "until", "at", "some", "time", "tax", "apple"], "tl": ["finally", "(", "get_close(tree)", ")", "until", "finally", "(", "tax(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "until", "at", "some", "time", "tax", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_2) happens. So, we want to express that we keep \"getting close tree\" until \"tax apple\" occurs at some point in the future.\n\n2. *Explanation dictionary* \u2013 {\"get close tree\": \"prop_1\", \"tax apple\": \"prop_2\", \"until at some time tax apple\": \"prop_1 U prop_2\"}\n\n3. *FINAL:* (prop_1 U prop_2)"}
{"id": 4014, "sentence": ["stop", "by", "flag", "until", "whenever", "go", "to", "tree"], "tl": ["stop_by(flag)", "until", "finally", "(", "go_to(tree)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "whenever", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"whenever go to tree\": \"G (prop_2 implies (prop_1 U (not prop_2)))\""}
{"id": 3875, "sentence": ["whenever", "touch", "house", "and", "at", "any", "time", "yield", "pear"], "tl": ["finally", "(", "touch(house)", ")", "and", "finally", "(", "yield(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "any", "time", "yield", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "yield", "action_ref": "yield", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(touch house) is true, something must follow. The phrase \"at any time yield pear\" means that eventually (at some future point) prop_2 (yield pear) must be true. Combining these, the formula states that globally, if prop_1 is true, then eventually prop_2 will be true.\n\n2. *Explanation dictionary* \u2013 {\"whenever touch house\": \"prop_1\", \"at any time yield pear\": \"F prop_2\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 4168, "sentence": ["at", "any", "time", "haul", "pear", "or", "at", "some", "time", "advance", "to", "house"], "tl": ["finally", "(", "haul(pear)", ")", "or", "finally", "(", "advance_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "some", "time", "advance", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "haul", "action_ref": "haul", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (globally(prop_1) or finally(prop_2)) FINISH"}
{"id": 5992, "sentence": ["acquire", "orange", "or", "at", "any", "time", "acquire", "pear"], "tl": ["acquire(orange)", "or", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "any", "time", "acquire", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 6678, "sentence": ["secure", "apple", "or", "whenever", "go", "by", "waste", "basket"], "tl": ["secure(apple)", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "- This can be expressed as: prop_1 or globally (prop_2 implies prop_1)."}
{"id": 2439, "sentence": ["go", "by", "waste", "bin", "or", "whenever", "go", "by", "waste", "basket"], "tl": ["go_by(waste_bin)", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "go", "by", "waste", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "3. *FINAL:* (prop_1) or (globally (prop_2 implies prop_1)) FINISH"}
{"id": 6978, "sentence": ["whenever", "show", "yourself", "near", "house", "and", "never", "drop", "apple"], "tl": ["finally", "(", "show_yourself_near(house)", ")", "and", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies globally (not prop_2)) FINISH"}
{"id": 581, "sentence": ["when", "possible", "get", "orange", "or", "when", "possible", "show", "yourself", "near", "house"], "tl": ["finally", "(", "get(orange)", ")", "or", "finally", "(", "show_yourself_near(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "show", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(finally). The actions \"get orange\" and \"show yourself near house\" are represented by propositions prop_1 and prop_2 respectively. The command says: eventually get orange or eventually show yourself near house.\n\n2. *Explanation dictionary* \u2013 {\"when possible get orange\": \"F prop_1\", \"when possible show yourself near house\": \"F prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 7055, "sentence": ["never", "drop", "apple", "or", "at", "any", "time", "go", "by", "waste", "basket"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) or (finally prop_2) FINISH"}
{"id": 6807, "sentence": ["never", "let", "go", "orange", "or", "at", "some", "time", "capture", "pear"], "tl": ["globally", "(", "negation", "(", "let_go(orange)", ")", ")", "or", "finally", "(", "capture(pear)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "some", "time", "capture", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* globally not (prop_1 or finally prop_2) FINISH"}
{"id": 300, "sentence": ["approach", "tree", "and", "repeatedly", "go", "to", "waste", "basket"], "tl": ["approach(tree)", "and", "globally", "(", "finally", "(", "go_to(waste_basket)", ")", ")"], "masked_tl": ["prop_1", "and", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "repeatedly", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "3. *FINAL:* (prop_1 and globally finally prop_2) FINISH"}
{"id": 434, "sentence": ["at", "any", "time", "get", "hold", "of", "orange", "or", "when", "possible", "stand", "by", "tree"], "tl": ["finally", "(", "get_hold_of(orange)", ")", "or", "finally", "(", "stand_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "stand", "by", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold_of", "action_ref": "get hold of", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "stand_by", "action_ref": "stand by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(G), indicating the property should hold at all times. \"get hold of orange or when possible stand by tree\" means either \"get hold of orange\" or \"stand by tree\" eventually. \"get hold of orange\" is represented by prop_1, \"stand by tree\" by prop_2. The phrase \"when possible\" suggests \"eventually\" (F) for standing by tree. So the formula is: globally (prop_1 or eventually prop_2).\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"G\", \"get hold of orange\": \"prop_1\", \"stand by tree\": \"prop_2\", \"when possible\": \"F\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 3833, "sentence": ["at", "some", "time", "scoop", "up", "apple", "and", "at", "some", "time", "journey", "by", "house"], "tl": ["finally", "(", "scoop_up(apple)", ")", "and", "finally", "(", "journey_by(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "some", "time", "journey", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (finally prop_1) and (finally prop_2) FINISH"}
{"id": 4032, "sentence": ["whenever", "go", "to", "house", "or", "do", "not", "pick", "up", "anything"], "tl": ["finally", "(", "go_to(house)", ")", "or", "negation", "(", "finally", "(", "pick_up(anything)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "negation", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "do", "not", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["anything)"], "args_ref": ["anything)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or (not prop_"}
{"id": 2880, "sentence": ["at", "any", "time", "go", "to", "transh", "can", "or", "at", "some", "time", "got", "to", "house"], "tl": ["finally", "(", "go_to(transh_can)", ")", "or", "finally", "(", "got_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "some", "time", "got", "to", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["transh_can)"], "args_ref": ["transh can)"]}, "prop_2": {"action_canon": "got_to", "action_ref": "got to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(always) prop_1 (representing \"go to transh can\") holds. The phrase \"or at some time got to house\" means that eventually prop_2 (representing \"go to house\") holds. The entire command is a disjunction (or) of these two temporal properties.\n\n2. *Explanation dictionary* \u2013 {\"at any time go to transh can\": \"G prop_1\", \"at some time got to house\": \"F prop_2\"}\n\n3. *FINAL:* (G prop_1) or (F prop_2)"}
{"id": 3428, "sentence": ["move", "to", "trash", "can", "and", "when", "possible", "make", "your", "way", "flag"], "tl": ["move_to(trash_can)", "and", "finally", "(", "make_your_way(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "make", "your", "way", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "     \"when possible make your way flag\": \"globally(prop_2 implies finally(prop_3))\""}
{"id": 1080, "sentence": ["at", "some", "time", "snag", "orange", "and", "travel", "to", "apple"], "tl": ["finally", "(", "snag(orange)", ")", "and", "travel_to(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* finally (prop_1 and prop_2) FINISH"}
{"id": 854, "sentence": ["at", "any", "time", "set", "out", "to", "house", "and", "at", "some", "time", "touch", "tree"], "tl": ["finally", "(", "set_out_to(house)", ")", "and", "finally", "(", "touch(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "touch", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "set_out_to", "action_ref": "set out to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (globally prop_1) and (finally prop_2) FINISH"}
{"id": 81, "sentence": ["forever", "have", "in", "orange", "until", "reach", "house"], "tl": ["globally", "(", "have_in(orange)", ")", "until", "reach(house)"], "masked_tl": ["globally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["forever", "prop_1", "until", "reach", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(prop_1) holds globally (always). The phrase \"until reach house\" means that this condition holds until the proposition \"reach house\" (prop_2) becomes true. So, the formula is: (globally prop_1) until prop_2, but since \"forever\" and \"until\" are combined, the correct interpretation is that \"in orange\" holds at every step until \"reach house\" occurs.\n\n2. *Explanation dictionary* \u2013 {\"forever have in orange\": \"G prop_1\", \"until reach house\": \"U prop_2\"}\n\n3. *FINAL:* (prop_1 U prop_2)"}
{"id": 3970, "sentence": ["at", "any", "time", "go", "to", "trash", "bin", "or", "at", "some", "time", "tax", "apple"], "tl": ["finally", "(", "go_to(trash_bin)", ")", "or", "finally", "(", "tax(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "some", "time", "tax", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(always) the proposition \"go to trash bin\" holds, so we use G prop_1. The phrase \"or at some time tax apple\" means that eventually (at some time) the proposition \"tax apple\" holds, so we use F prop_2. The entire command is a disjunction (or) of these two temporal statements.\n\n2. *Explanation dictionary* \u2013 {\"at any time go to trash bin\": \"G prop_1\", \"at some time tax apple\": \"F prop_2\"}\n\n3. *FINAL:* (G prop_1) or (F prop_2)"}
{"id": 5249, "sentence": ["at", "any", "time", "approach", "house", "and", "at", "some", "time", "show", "yourself", "near", "house"], "tl": ["finally", "(", "approach(house)", ")", "and", "finally", "(", "show_yourself_near(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "show", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(always) the proposition \"approach house\" (prop_1) holds. The phrase \"at some time show yourself near house\" means that eventually (finally) the proposition \"show yourself near house\" (prop_2) holds. The conjunction \"and\" connects these two temporal requirements.\n\n2. *Explanation dictionary* \u2013 {\"at any time approach house\": \"G prop_1\", \"at some time show yourself near house\": \"F prop_2\"}\n\n3. *FINAL:* (G prop_1) and (F prop_2)"}
{"id": 1579, "sentence": ["at", "some", "time", "snag", "orange", "or", "take", "to", "trashcan"], "tl": ["finally", "(", "snag(orange)", ")", "or", "take_to(trashcan)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 2750, "sentence": ["venture", "to", "trash", "can", "and", "at", "some", "time", "go", "near", "pear"], "tl": ["venture_to(trash_can)", "and", "finally", "(", "go_near(pear)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "go", "near", "pear", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(F) for each, combined with and.\n\n2. *Explanation dictionary* \u2013 {\"venture to trash can\": \"F prop_1\", \"at some time go near pear\": \"F prop_2\"}\n\n3. *FINAL:* (F prop_1) and (F prop_2)"}
{"id": 446, "sentence": ["when", "possible", "advance", "to", "house", "or", "at", "any", "time", "get", "close", "flag"], "tl": ["finally", "(", "advance_to(house)", ")", "or", "finally", "(", "get_close(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "get", "close", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1), then we should do so eventually (F prop_1). The phrase \"or at any time get close flag\" means that at any time, eventually get close to the flag (F prop_2). Combining these with \"or\" means either eventually advance to house when possible or eventually get close to the flag at any time.\n\n2. *Explanation dictionary* \u2013\n{\n  \"advance to house\": \"prop_1\",\n  \"get close flag\": \"prop_2\",\n  \"when possible advance to house\": \"F prop_1\",\n  \"at any time get close flag\": \"F prop_2\",\n  \"when possible advance to house or at any time get close flag\": \"F prop_1 or F prop_2\"\n}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 1137, "sentence": ["travel", "to", "apple", "or", "don't", "let", "go", "pear"], "tl": ["travel_to(apple)", "or", "negation", "(", "let_go(pear)", ")"], "masked_tl": ["prop_1", "or", "negation", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "don't", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (prop_1 or (not prop_2)) FINISH"}
{"id": 5995, "sentence": ["whenever", "venture", "to", "waste", "basket", "or", "when", "possible", "procure", "orange"], "tl": ["finally", "(", "venture_to(waste_basket)", ")", "or", "finally", "(", "procure(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "procure", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(venture to waste basket) holds, something should follow. The phrase \"or when possible procure orange\" suggests that either prop_1 holds or eventually prop_2 (procure orange) holds. The overall meaning is that globally, whenever prop_1 or eventually prop_2 holds, some condition is true. Since the command is about \"whenever ... or when possible ...\", the formula captures that globally, if prop_1 holds or eventually prop_2 holds, then something follows. Since the command is a command without a consequent, we interpret it as a requirement that whenever prop_1 or eventually prop_2 holds, that condition is true. The simplest interpretation is that globally, prop_1 or eventually prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"venture to waste basket\": \"prop_1\", \"procure orange\": \"prop_2\", \"whenever venture to waste basket or when possible procure orange\": \"G (prop_1 or F prop_2)\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 3737, "sentence": ["move", "to", "trashcan", "or", "when", "possible", "make", "to", "flag"], "tl": ["move_to(trashcan)", "or", "finally", "(", "make_to(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "make", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "make_to", "action_ref": "make to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 5554, "sentence": ["when", "possible", "move", "to", "flag", "or", "at", "any", "time", "walk", "near", "flag"], "tl": ["finally", "(", "move_to(flag)", ")", "or", "finally", "(", "walk_near(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "walk", "near", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "walk_near", "action_ref": "walk near", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1), then this should happen. The phrase \"or at any time walk near flag\" indicates that alternatively, \"walk near flag\" (prop_2) can happen at any time. So the formula states: if it is possible to move to the flag, then eventually move to the flag; otherwise, globally, it is allowed to walk near the flag.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible move to flag\": \"F prop_1\",\n  \"at any time walk near flag\": \"G prop_2\"\n}\n\n3. *FINAL:* (F prop_1) or (G prop_2)"}
{"id": 4578, "sentence": ["when", "repeatedly", "go", "to", "apple", "trashcan", ",", "grip", "apple"], "tl": ["globally", "(", "finally", "(", "go_to(apple_trashcan)", ")", ")", "imply", "grip(apple)"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "imply", "prop_2"], "grounded_sentence": ["when", "repeatedly", "prop_1", ",", "grip", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple_trashcan)"], "args_ref": ["apple trashcan)"]}, "prop_2": {"action_canon": "grip", "action_ref": "grip", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1) happens infinitely often, which can be expressed as \"globally finally prop_1\" (G F prop_1). The phrase \"grip apple\" (prop_2) should hold whenever this condition occurs, so \"globally (if prop_1 then prop_2)\" or G (prop_1 implies prop_2).\n\n2. *Explanation dictionary* \u2013 {\"go to apple trashcan\": \"prop_1\", \"repeatedly go to apple trashcan\": \"G F prop_1\", \"grip apple\": \"prop_2\", \"when repeatedly go to apple trashcan, grip apple\": \"G (prop_1 implies prop_2)\"}\n\n3. *FINAL:* G (F prop_1 implies prop_2)"}
{"id": 2981, "sentence": ["when", "possible", "go", "home", "and", "forever", "touch", "flag"], "tl": ["finally", "(", "go(home)", ")", "and", "globally", "(", "touch(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "forever", "touch", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(F prop_1) and (G prop_2)"}
{"id": 7387, "sentence": ["get", "to", "tree", "or", "approach", "trash", "can"], "tl": ["get_to(tree)", "or", "approach(trash_can)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "approach", "trash", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(F) operator.\n\n2. *Explanation dictionary* \u2013 {\"tree\": \"prop_1\", \"approach trash can\": \"prop_2\", \"or\": \"or\", \"get to\": \"F\"}\n\n3. *FINAL:* F (prop_1 or prop_2)"}
{"id": 3378, "sentence": ["at", "some", "time", "obtain", "orange", "and", "whenever", "stop", "by", "trash", "can"], "tl": ["finally", "(", "obtain(orange)", ")", "and", "finally", "(", "stop_by(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "whenever", "stop", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(F prop_1), where prop_1 represents \"obtain orange\". The phrase \"whenever stop by trash can\" means \"globally, if prop_2 then ...\", where prop_2 represents \"stop by trash can\". Since the command does not specify what should happen whenever stopping by the trash can, we interpret it as a condition that must hold whenever stopping by the trash can. To combine these, we say that eventually prop_1 holds, and globally, whenever prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"at some time obtain orange\": \"F prop_1\", \"whenever stop by trash can\": \"G (prop_2 implies ...)\"}\n\n3. *FINAL:* (F prop_1) and G (prop_2 implies true)"}
{"id": 901, "sentence": ["whenever", "proceed", "to", "flag", "or", "whenever", "approach", "flag"], "tl": ["finally", "(", "proceed_to(flag)", ")", "or", "finally", "(", "approach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "approach", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 7392, "sentence": ["whenever", "go", "by", "house", "and", "pick", "up", "pear"], "tl": ["finally", "(", "go_by(house)", ")", "and", "pick_up(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies prop_2) FINISH"}
{"id": 4972, "sentence": ["when", "possible", "proceed", "to", "house", "and", "when", "possible", "start", "going", "to", "tree"], "tl": ["finally", "(", "proceed_to(house)", ")", "and", "finally", "(", "start_going_to(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "start", "going", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(F), indicating eventuality. \"Proceed to house\" and \"start going to tree\" are represented by propositions prop_1 and prop_2 respectively. The command says: eventually proceed to house, and eventually start going to tree.\n\n2. *Explanation dictionary* \u2013 {\"when possible\": \"F\", \"proceed to house\": \"prop_1\", \"start going to tree\": \"prop_2\"}\n\n3. *FINAL:* (F prop_1) and (F prop_2)"}
{"id": 5217, "sentence": ["put", "in", "apple", "bucket", "and", "at", "any", "time", "travel", "to", "trash", "can"], "tl": ["put_in(apple_bucket)", "and", "finally", "(", "travel_to(trash_can)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "any", "time", "travel", "to", "trash", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["apple_bucket)"], "args_ref": ["apple bucket)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (prop_1 and finally prop_2) FINISH"}
{"id": 2456, "sentence": ["at", "any", "time", "seize", "orange", "or", "when", "possible", "acquire", "pear"], "tl": ["finally", "(", "seize(orange)", ")", "or", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "acquire", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(F) for prop_2.\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"G\", \"seize orange\": \"prop_1\", \"or\": \"or\", \"when possible acquire pear\": \"F prop_2\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 2870, "sentence": ["whenever", "let", "go", "apple", "or", "pick", "up", "fruit"], "tl": ["finally", "(", "let_go(apple)", ")", "or", "pick_up(fruit)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["fruit)"], "args_ref": ["fruit)"]}}, "prediction": "(G) condition. The condition is \"let go apple or pick up fruit,\" which is a disjunction (or) of two propositions: \"let go apple\" and \"pick up fruit.\" We assign prop_1 to \"let go apple\" and prop_2 to \"pick up fruit.\" The formula states that globally, if either prop_1 or prop_2 holds, then something follows. Since the command is just \"whenever\" followed by the condition, it implies that whenever the condition holds, it should hold (or some implicit consequence). Without further consequence, the formula is simply G (prop_1 or prop_2).\n\n2. *Explanation dictionary* \u2013 {\"let go apple\": \"prop_1\", \"pick up fruit\": \"prop_2\", \"let go apple or pick up fruit\": \"(prop_1 or prop_2)\", \"whenever let go apple or pick up fruit\": \"G (prop_1 or prop_2)\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 171, "sentence": ["when", "possible", "travel", "to", "house", "or", "whenever", "move", "past", "trash", "can"], "tl": ["finally", "(", "travel_to(house)", ")", "or", "finally", "(", "move_past(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "whenever", "move", "past", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_past", "action_ref": "move past", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(prop_1), then eventually either traveling to the house (prop_2) or moving past the trash can (prop_3) should happen. Additionally, whenever moving past the trash can (prop_3) occurs, some property (prop_4)"}
{"id": 5959, "sentence": ["go", "to", "bucket", "until", "when", "possible", "touch", "house"], "tl": ["go_to(bucket)", "until", "finally", "(", "touch(house)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "when", "possible", "touch", "house", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_1) U (prop_2) FINISH"}
{"id": 7182, "sentence": ["never", "let", "go", "apple", "until", "at", "some", "time", "collect", "orange"], "tl": ["globally", "(", "negation", "(", "let_go(apple)", ")", ")", "until", "finally", "(", "collect(orange)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "until", "at", "some", "time", "collect", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1) should never happen, so we use globally not prop_1: G not prop_1. The phrase \"until at some time collect orange\" means that this condition holds until eventually \"collect orange\" (prop_2) happens, so we use prop_1 until finally prop_2: (not prop_1) U (F prop_2). Combining these, \"never let go apple until at some time collect orange\" translates to \"not let go apple until eventually collect orange\": (not prop_1) U (F prop_2).\n\n2. *Explanation dictionary* \u2013 {\"never let go apple\": \"not prop_1\", \"at some time collect orange\": \"F prop_2\", \"never let go apple until at some time collect orange\": \"(not prop_1) U (F prop_2)\"}\n\n3. *FINAL:* (not prop_1) U (F prop_2)"}
{"id": 6703, "sentence": ["at", "some", "time", "stop", "by", "house", "or", "forever", "have", "in", "orange"], "tl": ["finally", "(", "stop_by(house)", ")", "or", "globally", "(", "have_in(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "forever", "have", "in", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(F prop_1), where prop_1 represents \"stop by house\". The phrase \"forever have in orange\" corresponds to \"globally prop_2\" (G prop_2), where prop_2 represents \"have in orange\". The \"or\" connects these two parts, so the full formula is \"F prop_1 or G prop_2\".\n\n2. *Explanation dictionary* \u2013 {\"at some time stop by house\": \"F prop_1\", \"forever have in orange\": \"G prop_2\"}\n\n3. *FINAL:* (F prop_1) or (G prop_2)"}
{"id": 49, "sentence": ["at", "some", "time", "grab", "pear", "and", "whenever", "pick", "up", "peach"], "tl": ["finally", "(", "grab(pear)", ")", "and", "finally", "(", "pick_up(peach)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "whenever", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["peach)"], "args_ref": ["peach)"]}}, "prediction": "3. *FINAL:* (F prop_1) and (G (prop_2 implies prop_"}
{"id": 6078, "sentence": ["never", "drop", "orange", "and", "move", "to", "tree"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "and", "move_to(tree)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "and", "prop_2"], "grounded_sentence": ["never", "prop_1", "and", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) and (finally prop_2) FINISH"}
{"id": 3893, "sentence": ["whenever", "grab", "apple", "and", "never", "drop", "orange"], "tl": ["finally", "(", "grab(apple)", ")", "and", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* G (prop_1 implies true) and G (not prop_2) FINISH"}
{"id": 3432, "sentence": ["whenever", "getting", "pear", "can", "infer", "that", "at", "any", "time", "go", "to", "house"], "tl": ["finally", "(", "getting(pear)", ")", "imply", "finally", "(", "go_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "can", "infer", "that", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "getting", "action_ref": "getting", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(getting pear) holds,\n- \"can infer that at any time go to house\" means that eventually (at any time in the future) prop_2 (go to house) will hold.\n- Combining these, we get: globally (if prop_1 then finally prop_2).\n\n2. Explanation dictionary:\n{\"whenever getting pear\": \"prop_1\", \"at any time go to house\": \"F prop_2\"}\n\n3. FINAL: G (prop_1 implies F prop_2)"}
{"id": 2403, "sentence": ["when", "possible", "go", "by", "waste", "basket", "and", "when", "possible", "go", "by", "waste", "basket"], "tl": ["finally", "(", "go_by(waste_basket)", ")", "and", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_2", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "go", "by", "waste", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "3. *FINAL:* (globally (prop_1 implies finally prop_2)) and (globally (prop_1 implies finally prop_2)) FINISH"}
{"id": 4795, "sentence": ["at", "some", "time", "withhold", "apple", "and", "at", "some", "time", "reach", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "some", "time", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (finally prop_1) and (finally prop_2) FINISH"}
{"id": 2809, "sentence": ["at", "any", "time", "start", "going", "to", "house", "or", "when", "possible", "start", "going", "to", "house"], "tl": ["finally", "(", "start_going_to(house)", ")", "or", "finally", "(", "start_going_to(house)", ")"], "masked_tl": ["finally", "(", "prop_2", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "start", "going", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (G F prop_1) or (G (prop_2 implies F prop_1)) FINISH"}
{"id": 6951, "sentence": ["venture", "towards", "house", "or", "whenever", "go", "by", "waste", "basket"], "tl": ["venture_towards(house)", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(prop_1 or prop_2)\"}\n\n3. *FINAL:* F (prop_1 or prop_2)"}
{"id": 3371, "sentence": ["always", "touch", "flag", "can", "infer", "that", "whenever", "go", "to", "apple"], "tl": ["globally", "(", "touch(flag)", ")", "imply", "finally", "(", "go_to(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "can", "infer", "that", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* globally (prop_2 implies prop_1) FINISH"}
{"id": 6901, "sentence": ["when", "possible", "come", "home", "means", "that", "pick", "up", "pear"], "tl": ["finally", "(", "come(home)", ")", "imply", "pick_up(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "means", "that", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "come", "action_ref": "come", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(F). \"Come home\" is represented by prop_1. \"Pick up pear\" is represented by prop_2. The phrase \"means that\" indicates an implication. So the command means: if it is possible to come home eventually, then eventually pick up the pear. This can be expressed as: finally prop_1 implies finally prop_2.\n\n2. *Explanation dictionary* \u2013 {\"when possible\": \"F\", \"come home\": \"prop_1\", \"pick up pear\": \"prop_2\", \"means that\": \"implies\"}\n\n3. *FINAL:* (F prop_1) implies (F prop_2)"}
{"id": 2217, "sentence": ["at", "any", "time", "go", "to", "tree", "until", "take", "apple"], "tl": ["finally", "(", "go_to(tree)", ")", "until", "take(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "until", "take", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(G), meaning the property holds at all times. The phrase \"go to tree until take apple\" maps to \"prop_1 until prop_2\", where prop_1 represents \"go to tree\" and prop_2 represents \"take apple\". Combining these, the formula states that globally, \"go to tree\" holds until \"take apple\" occurs.\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"globally\", \"go to tree\": \"prop_1\", \"take apple\": \"prop_2\", \"go to tree until take apple\": \"(prop_1 until prop_2)\"}\n\n3. *FINAL:* G (prop_1 until prop_2)"}
{"id": 1929, "sentence": ["at", "any", "time", "withhold", "apple", "and", "at", "some", "time", "present", "at", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "present", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (globally(not(prop_1)) and finally(prop_2)) FINISH"}
{"id": 6116, "sentence": ["at", "some", "time", "withhold", "apple", "and", "at", "any", "time", "present", "at", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "any", "time", "present", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(F prop_1) and (G prop_2)"}
{"id": 1794, "sentence": ["don't", "let", "go", "pear", "means", "that", "take", "pear"], "tl": ["negation", "(", "let_go(pear)", ")", "imply", "take(pear)"], "masked_tl": ["negation", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["don't", "prop_1", "means", "that", "take", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (not prop_1) implies prop_2 FINISH"}
{"id": 5394, "sentence": ["go", "to", "orange", "or", "pick", "up", "flag"], "tl": ["go_to(orange)", "or", "pick_up(flag)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 or prop_2) FINISH"}
{"id": 3055, "sentence": ["go", "to", "bucket", "and", "when", "possible", "procure", "orange"], "tl": ["go_to(bucket)", "and", "finally", "(", "procure(orange)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "procure", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(finally) the action \"procure orange\" (prop_2) should happen, but only after \"go to bucket\" has occurred. This is captured by \"prop_1 until finally prop_2\", meaning we stay in the state of going to the bucket until at some point in the future we procure the orange.\n\n2. *Explanation dictionary* \u2013 {\"go to bucket\": \"prop_1\", \"when possible procure orange\": \"F prop_2\"}\n\n3. *FINAL:* (prop_1 U F prop_2)"}
{"id": 64, "sentence": ["at", "any", "time", "bring", "pear", "or", "venture", "towards", "house"], "tl": ["finally", "(", "bring(pear)", ")", "or", "venture_towards(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(prop_1 or prop_2)\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 136, "sentence": ["whenever", "make", "to", "flag", "or", "drop", "pear"], "tl": ["finally", "(", "make_to(flag)", ")", "or", "drop(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "drop", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_to", "action_ref": "make to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 5779, "sentence": ["when", "possible", "walk", "to", "flag", "until", "pick", "up", "pear"], "tl": ["finally", "(", "walk_to(flag)", ")", "until", "pick_up(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "until", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* G (prop_1 implies (prop_1 U prop_2)) FINISH"}
{"id": 1702, "sentence": ["if", "at", "some", "time", "secure", "pear", ",", "whenever", "take", "possession", "of", "bear"], "tl": ["finally", "(", "secure(pear)", ")", "imply", "finally", "(", "take_possession_of(bear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "at", "some", "time", "prop_1", ",", "whenever", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}}, "prediction": "3. *FINAL:* (F prop_1) implies (G (prop_2 implies F prop_1)) FINISH"}
{"id": 1502, "sentence": ["when", "possible", "going", "to", "house", "and", "move", "towards", "trash", "can"], "tl": ["finally", "(", "going_to(house)", ")", "and", "move_towards(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "move", "towards", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_towards", "action_ref": "move towards", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* G((prop_1 and prop_2) implies F(prop_1 and prop_2)) FINISH"}
{"id": 1410, "sentence": ["at", "some", "time", "seize", "pear", "or", "at", "some", "time", "grab", "apple"], "tl": ["finally", "(", "seize(pear)", ")", "or", "finally", "(", "grab(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "grab", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 5643, "sentence": ["go", "by", "waste", "bin", "and", "when", "possible", "reach", "flag"], "tl": ["go_by(waste_bin)", "and", "finally", "(", "reach(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "reach", "flag", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"when possible reach flag\": \"(not G not prop_2) implies (finally prop_2)\""}
{"id": 1576, "sentence": ["at", "any", "time", "be", "at", "house", "means", "that", "when", "possible", "reach", "tree"], "tl": ["finally", "(", "be_at(house)", ")", "imply", "finally", "(", "reach(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "means", "that", "when", "possible", "reach", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_at", "action_ref": "be at", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(G), meaning always. \"be at house\" is represented by prop_1. \"means that\" indicates an implication (implies). \"when possible reach tree\" means that if it is possible to reach \"tree\" (prop_2), then eventually \"tree\" will be reached. This can be captured by \"finally prop_2\" (F prop_2). So the whole formula states: always, if at house, then eventually reach tree.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time\": \"globally\",\n  \"be at house\": \"prop_1\",\n  \"means that\": \"implies\",\n  \"when possible reach tree\": \"finally prop_2\"\n}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 5511, "sentence": ["don't", "let", "go", "orange", "and", "come", "to", "tree"], "tl": ["negation", "(", "let_go(orange)", ")", "and", "come_to(tree)"], "masked_tl": ["negation", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["don't", "prop_1", "and", "come", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "come_to", "action_ref": "come to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(G) and prop_1 for \"orange\" to express that \"orange\" is always true. The phrase \"and come to tree\" means that eventually (F) \"tree\" (prop_2) should become true. Combining these with \"and\" gives the full formula.\n\n2. *Explanation dictionary* \u2013 {\"don't let go orange\": \"G prop_1\", \"come to tree\": \"F prop_2\"}\n\n3. *FINAL:* (G prop_1) and (F prop_2)"}
{"id": 7437, "sentence": ["at", "any", "time", "capture", "pear", "or", "move", "to", "trash", "can"], "tl": ["finally", "(", "capture(pear)", ")", "or", "move_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 6715, "sentence": ["whenever", "make", "contact", "with", "house", "or", "when", "possible", "go", "near", "pear"], "tl": ["finally", "(", "make_contact_with(house)", ")", "or", "finally", "(", "go_near(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "go", "near", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "1. *Explanation* \u2013 The phrase \"whenever make contact with house\" indicates a condition that triggers a requirement. \"Make contact with house\" is represented as prop_1. The phrase \"or when possible go near pear\" introduces an alternative condition or action, where \"go near pear\" is represented as prop_2. The command implies that whenever either \"make contact with house\" or \"go near pear\" is true, some condition should hold. Since the command is a directive, it can be interpreted as \"whenever prop_1 or prop_2 happens, some property should hold.\" However, since no further property is specified, the simplest interpretation is that \"whenever prop_1 or prop_2 occurs, it should eventually be followed by prop_1 or prop_2\" or simply that \"prop_1 or prop_2\" should always be possible. Given the ambiguity, the best fit is to express that \"whenever prop_1 or prop_2 occurs, prop_1 or prop_2 holds,\" which is tautological. Alternatively, the command can be interpreted as \"always, if prop_1 or prop_2 is true, then prop_1 or prop_2 is true,\" which is trivial. To capture the"}
{"id": 2392, "sentence": ["pick", "up", "pear", "and", "when", "possible", "get", "apple"], "tl": ["pick_up(pear)", "and", "finally", "(", "get(apple)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "get", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "get", "action_ref": "get", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(where prop_1 = \"pick up pear\").\n   - \"when possible get apple\" means that as soon as it is possible to get the apple, it should be done. This can be interpreted as: eventually get apple (F prop_2), but only after it becomes possible. Since \"when possible\" implies that once the condition to get apple is true, the action should follow. We can model \"when possible\" as \"once it is possible (prop_3), then eventually get apple (prop_2)\". So, globally, if it becomes possible (prop_3), then eventually get apple (prop_2). This is G (prop_3 \u2192 F prop_2).\n\n2. *Explanation dictionary*:\n{\n  \"pick up pear\": \"prop_1\",\n  \"get apple\": \"prop_2\",\n  \"when possible\": \"prop_3\",\n  \"pick up pear eventually\": \"F prop_1\",\n  \"when possible get apple\": \"G (prop_3 implies F prop_2)"}
{"id": 2287, "sentence": ["at", "some", "time", "scoop", "up", "pear", "or", "never", "let", "go", "orange"], "tl": ["finally", "(", "scoop_up(pear)", ")", "or", "globally", "(", "negation", "(", "let_go(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "never", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or globally prop_2) FINISH"}
{"id": 782, "sentence": ["when", "possible", "approach", "flag", "and", "whenever", "obtain", "orange"], "tl": ["finally", "(", "approach(flag)", ")", "and", "finally", "(", "obtain(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "whenever", "obtain", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 implies finally prop_2) and globally (prop_3 implies true) FINISH"}
{"id": 7207, "sentence": ["at", "any", "time", "travel", "house", "or", "when", "possible", "journey", "to", "flag"], "tl": ["finally", "(", "travel(house)", ")", "or", "finally", "(", "journey_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "journey", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel", "action_ref": "travel", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(G), indicating the property should hold always. The phrase \"travel house or when possible journey to flag\" means either \"travel house\" or \"when possible journey to flag\". We interpret \"travel house\" as prop_1, \"journey to flag\" as prop_2, and \"when possible\" as \"implies\" or \"if possible\" meaning \"if prop_3 then prop_2\". Since \"when possible\" modifies \"journey to flag\", we can model \"when possible journey to flag\" as \"if possible then journey to flag\", i.e., prop_3 implies prop_2. The entire formula is that always (globally) either prop_1 holds or (prop_3 implies prop_2) holds.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time\": \"globally\",\n  \"travel house\": \"prop_1\",\n  \"when possible\": \"implies\",\n  \"journey to flag\": \"prop_2\",\n  \"possible\": \"prop_3\",\n  \"travel house or when possible journey to flag\": \"(prop_1 or (prop_3 implies prop_2))"}
{"id": 6828, "sentence": ["whenever", "spend", "time", "at", "tree", "and", "at", "some", "time", "move", "near", "tree"], "tl": ["finally", "(", "spend_time_at(tree)", ")", "and", "finally", "(", "move_near(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "some", "time", "move", "near", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "move_near", "action_ref": "move near", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 6481, "sentence": ["whenever", "going", "to", "house", "or", "at", "any", "time", "venture", "to", "flag"], "tl": ["finally", "(", "going_to(house)", ")", "or", "finally", "(", "venture_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (G (prop_1 implies F prop_2)) or (F prop_2) FINISH"}
{"id": 546, "sentence": ["whenever", "reach", "flag", "or", "go", "by", "waste", "bin"], "tl": ["finally", "(", "reach(flag)", ")", "or", "go_by(waste_bin)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "(G) condition. The condition \"reach flag or go by waste bin\" is a disjunction (or) of two propositions: \"reach flag\" and \"go by waste bin\". We assign prop_1 to \"reach flag\" and prop_2 to \"go by waste bin\". The formula states that globally, if either prop_1 or prop_2 holds, then some property should hold. Since the command does not specify what should happen after, we interpret it as the condition itself holding globally, i.e., \"whenever prop_1 or prop_2\".\n\n2. *Explanation dictionary* \u2013 {\"whenever\": \"globally (G)\", \"reach flag\": \"prop_1\", \"go by waste bin\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 1109, "sentence": ["at", "any", "time", "seize", "orange", "or", "go", "to", "bucket"], "tl": ["finally", "(", "seize(orange)", ")", "or", "go_to(bucket)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}}, "prediction": "(G), indicating the property must hold at all times. The action \"seize orange or go to bucket\" is a disjunction of two propositions, which we represent as prop_1 (seize orange) or prop_2 (go to bucket). Thus, the formula states that globally, either prop_1 or prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"globally\", \"seize orange\": \"prop_1\", \"go to bucket\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 5062, "sentence": ["whenever", "get", "orange", "and", "whenever", "let", "go", "apple"], "tl": ["finally", "(", "get(orange)", ")", "and", "finally", "(", "let_go(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "whenever", "let", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "G (prop_1 \u2192 prop_1) and G (prop_2 \u2192 prop_2)"}
{"id": 6779, "sentence": ["always", "have", "in", "orange", "or", "when", "possible", "be", "in", "house's", "vicinity"], "tl": ["globally", "(", "have_in(orange)", ")", "or", "finally", "(", "be_in(house's_vicinity)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "or", "when", "possible", "be", "in", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "be_in", "action_ref": "be in", "args_canon": ["house's_vicinity)"], "args_ref": ["house's vicinity)"]}}, "prediction": "(G), \"or\" as or, and \"when possible\" as allowing the alternative condition. We assign prop_1 to \"in orange\" and prop_2 to \"be in house's vicinity\". The formula is G (prop_1 or prop_2).\n\n2. *Explanation dictionary* \u2013 {\"always\": \"G\", \"have in orange\": \"prop_1\", \"be in house's vicinity\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 4873, "sentence": ["go", "by", "waste", "bin", "or", "never", "drop", "apple"], "tl": ["go_by(waste_bin)", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "or", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 or (globally (not prop_2))) FINISH"}
{"id": 2720, "sentence": ["hold", "pear", "or", "pick", "up", "flag"], "tl": ["hold(pear)", "or", "pick_up(flag)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "pick", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 or prop_2) FINISH"}
{"id": 2885, "sentence": ["hold", "pear", "and", "when", "possible", "get", "close", "tree"], "tl": ["hold(pear)", "and", "finally", "(", "get_close(tree)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "get", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (prop_1 and (F prop_2)) FINISH"}
{"id": 7316, "sentence": ["at", "some", "time", "start", "going", "to", "house", "means", "that", "repeatedly", "go", "to", "apple", "trashcan"], "tl": ["finally", "(", "start_going_to(house)", ")", "imply", "globally", "(", "finally", "(", "go_to(apple_trashcan)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "means", "that", "repeatedly", "go", "to", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple_trashcan)"], "args_ref": ["apple trashcan)"]}}, "prediction": "(F prop_1), where prop_1 represents \"start going to house.\" The phrase \"means that repeatedly go to apple trashcan\" corresponds to \"globally prop_2\" (G prop_2), where prop_2 represents \"go to apple trashcan.\" The word \"means\" indicates logical implication, so the entire formula is \"F prop_1 implies G prop_2.\"\n\n2. *Explanation dictionary* \u2013 {\"at some time start going to house\": \"F prop_1\", \"repeatedly go to apple trashcan\": \"G prop_2\", \"means\": \"implies\"}\n\n3. *FINAL:* (F prop_1) implies (G prop_2)"}
{"id": 4368, "sentence": ["whenever", "withhold", "apple", "or", "at", "any", "time", "go", "by", "waste", "basket"], "tl": ["finally", "(", "withhold(apple)", ")", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(prop_1 implies ...)\" where prop_1 represents \"withhold apple\". The phrase \"or at any time go by waste basket\" means that either the first condition holds or eventually \"go by waste basket\" happens; \"go by waste basket\" is represented by prop_2. The \"or at any time\" corresponds to \"or finally prop_2\".\n\n2. *Explanation dictionary* \u2013 {\"whenever withhold apple\": \"G (prop_1 implies ...)\", \"withhold apple\": \"prop_1\", \"go by waste basket\": \"prop_2\", \"or at any time go by waste basket\": \"or F prop_2\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 5298, "sentence": ["at", "any", "time", "scoop", "up", "apple", "and", "at", "any", "time", "seize", "pear"], "tl": ["finally", "(", "scoop_up(apple)", ")", "and", "finally", "(", "seize(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "any", "time", "seize", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(finally) the proposition representing \"scoop up apple\" (prop_1) will be true. Similarly, \"at any time seize pear\" means eventually (finally) the proposition representing \"seize pear\" (prop_2) will be true. The conjunction \"and\" connects these two eventualities, so both must eventually happen.\n\n2. *Explanation dictionary* \u2013 {\"at any time scoop up apple\": \"F prop_1\", \"at any time seize pear\": \"F prop_2\", \"and\": \"and\"}\n\n3. *FINAL:* (F prop_1) and (F prop_2)"}
{"id": 2977, "sentence": ["at", "any", "time", "got", "to", "house", "means", "that", "at", "some", "time", "venture", "flag"], "tl": ["finally", "(", "got_to(house)", ")", "imply", "finally", "(", "venture(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "means", "that", "at", "some", "time", "venture", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "got_to", "action_ref": "got to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 5472, "sentence": ["never", "drop", "orange", "or", "acquire", "apple"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "or", "acquire(apple)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "prop_2"], "grounded_sentence": ["never", "prop_1", "or", "acquire", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* globally (not (prop_1 or prop_2)) FINISH"}
{"id": 55, "sentence": ["go", "to", "bucket", "and", "take", "to", "tree"], "tl": ["go_to(bucket)", "and", "take_to(tree)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "take", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (F prop_1) and (F (prop_2 and F prop_3))"}
{"id": 5781, "sentence": ["approach", "tree", "can", "infer", "that", "when", "possible", "make", "your", "way", "flag"], "tl": ["approach(tree)", "imply", "finally", "(", "make_your_way(flag)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "can", "infer", "that", "when", "possible", "make", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_2). \"Approach tree\" can be represented as prop_1. So the command means: if it is possible to approach the tree (prop_1), then eventually make your way to the flag (prop_2). The \"can infer that\" phrase indicates this logical implication.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible\": \"prop_1\",\n  \"make your way flag\": \"F prop_2\",\n  \"can infer that\": \"implies\"\n}\n\n3. *FINAL:* (prop_1 implies F prop_2)"}
{"id": 4160, "sentence": ["secure", "apple", "and", "at", "some", "time", "go", "by", "waste", "basket"], "tl": ["secure(apple)", "and", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "3. *FINAL:* (prop_1 and finally prop_2) FINISH"}
{"id": 2320, "sentence": ["venture", "towards", "house", "and", "at", "some", "time", "go", "by", "waste", "basket"], "tl": ["venture_towards(house)", "and", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(prop_1 and F prop_2)"}
{"id": 653, "sentence": ["when", "possible", "venture", "to", "waste", "basket", "or", "at", "any", "time", "venture", "house"], "tl": ["finally", "(", "venture_to(waste_basket)", ")", "or", "finally", "(", "venture(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "venture", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 3030, "sentence": ["get", "hold", "of", "pear", "and", "whenever", "obtain", "apple"], "tl": ["get_hold_of(pear)", "and", "finally", "(", "obtain(apple)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "obtain", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold_of", "action_ref": "get hold of", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. FINAL: (prop_1 and G(prop_2)) FINISH"}
{"id": 2982, "sentence": ["when", "walk", ",", "at", "some", "time", "journey", "by", "house"], "tl": ["walk", "imply", "finally", "(", "journey_by(house)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "prop_1", ",", "at", "some", "time", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk", "action_ref": "walk", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(at some time) the journey by house occurs. Combining these, the formula states: whenever walk happens, eventually journey by house will happen.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when walk\" : \"prop_1\",\n  \"at some time journey by house\" : \"F prop_2\"\n}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 5513, "sentence": ["at", "some", "time", "make", "your", "way", "flag", "or", "whenever", "make", "your", "way", "flag"], "tl": ["finally", "(", "make_your_way(flag)", ")", "or", "finally", "(", "make_your_way(flag)", ")"], "masked_tl": ["finally", "(", "prop_2", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "whenever", "make", "your", "way", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(F prop_1), meaning prop_1 will be true at some point in the future. The phrase \"or whenever make your way flag\" means \"or globally prop_1\" (G prop_1), meaning prop_1 is always true. Combining these with \"or\" gives (F prop_1) or (G prop_1).\n\n2. *Explanation dictionary* \u2013 {\"at some time make your way flag\": \"F prop_1\", \"or whenever make your way flag\": \"G prop_1\"}\n\n3. *FINAL:* (F prop_1) or (G prop_1)"}
{"id": 6844, "sentence": ["when", "possible", "travel", "to", "house", "or", "at", "any", "time", "go", "to", "flag"], "tl": ["finally", "(", "travel_to(house)", ")", "or", "finally", "(", "go_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 5432, "sentence": ["when", "possible", "go", "by", "house", "or", "never", "let", "go", "apple"], "tl": ["finally", "(", "go_by(house)", ")", "or", "globally", "(", "negation", "(", "let_go(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "never", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 implies (prop_2 or globally (not prop_3))) FINISH"}
{"id": 4487, "sentence": ["whenever", "contact", "house", "or", "at", "any", "time", "get", "hold", "orange"], "tl": ["finally", "(", "contact(house)", ")", "or", "finally", "(", "get_hold(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "get", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (G (prop_1 implies F prop_2)) or F prop_2 FINISH"}
{"id": 4817, "sentence": ["travel", "to", "apple", "and", "at", "some", "time", "venture", "flag"], "tl": ["travel_to(apple)", "and", "finally", "(", "venture(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "venture", "flag", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(finally) prop_2 (venture flag) will be true. The conjunction \"and\" connects these two conditions, so both must hold: traveling to apple now and eventually venturing flag.\n\n2. *Explanation dictionary* \u2013 {\"travel to apple\": \"prop_1\", \"at some time venture flag\": \"F prop_2\"}\n\n3. *FINAL:* (prop_1 and F prop_2)"}
{"id": 980, "sentence": ["whenever", "go", "to", "home", "until", "when", "possible", "pass", "by", "trash", "bin"], "tl": ["finally", "(", "go_to(home)", ")", "until", "finally", "(", "pass_by(trash_bin)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "until", "when", "possible", "pass", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "3. *FINAL:* G (prop_1 implies (prop_1 U prop_2)) FINISH"}
{"id": 1032, "sentence": ["at", "some", "time", "move", "near", "tree", "and", "repeatedly", "go", "to", "apple", "trashcan"], "tl": ["finally", "(", "move_near(tree)", ")", "and", "globally", "(", "finally", "(", "go_to(apple_trashcan)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "repeatedly", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_near", "action_ref": "move near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple_trashcan)"], "args_ref": ["apple trashcan)"]}}, "prediction": "  \"and\": \"and\""}
{"id": 1994, "sentence": ["at", "any", "time", "travel", "to", "flag", "and", "stop", "by", "flag"], "tl": ["finally", "(", "travel_to(flag)", ")", "and", "stop_by(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "stop", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(G), meaning the property holds at all times. The phrase \"travel to flag\" can be represented by proposition prop_1 (e.g., \"traveling to flag\"). The phrase \"stop by flag\" can be represented by proposition prop_2 (e.g., \"stopping by flag\"). The conjunction \"and\" connects these two propositions. So, the formula states that globally, both traveling to the flag and stopping by the flag hold.\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"globally\", \"travel to flag\": \"prop_1\", \"stop by flag\": \"prop_2\", \"and\": \"and\"}\n\n3. *FINAL:* G (prop_1 and prop_2)"}
{"id": 6783, "sentence": ["at", "any", "time", "walk", "near", "flag", "or", "at", "any", "time", "get", "hold", "orange"], "tl": ["finally", "(", "walk_near(flag)", ")", "or", "finally", "(", "get_hold(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "any", "time", "get", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk_near", "action_ref": "walk near", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (G (prop_1 or prop_2)) FINISH"}
{"id": 6217, "sentence": ["visit", "tree", "and", "at", "any", "time", "show", "yourself", "near", "house"], "tl": ["visit(tree)", "and", "finally", "(", "show_yourself_near(house)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "any", "time", "show", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(tree) holds, so we use finally(prop_1). The phrase \"at any time show yourself near house\" means that globally (always) prop_2 (near house) holds. The conjunction \"and\" connects these two requirements.\n\n2. *Explanation dictionary* \u2013 {\"visit tree\": \"F prop_1\", \"at any time show yourself near house\": \"G prop_2\", \"and\": \"and\"}\n\n3. *FINAL:* (F prop_1) and (G prop_2)"}
{"id": 6152, "sentence": ["go", "to", "orange", "bin", "or", "come", "to", "tree"], "tl": ["go_to(orange_bin)", "or", "come_to(tree)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "come", "to", "tree", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange_bin)"], "args_ref": ["orange bin)"]}, "prop_2": {"action_canon": "come_to", "action_ref": "come to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (prop_1 or prop_2) FINISH"}
{"id": 5350, "sentence": ["secure", "apple", "or", "secure", "apple"], "tl": ["secure(apple)", "or", "secure(apple)"], "masked_tl": ["prop_2", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "secure", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 or prop_1) FINISH"}
{"id": 2509, "sentence": ["when", "possible", "go", "by", "waste", "basket", "and", "at", "any", "time", "reach", "flag"], "tl": ["finally", "(", "go_by(waste_basket)", ")", "and", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "any", "time", "reach", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1), then eventually go by waste basket (prop_2).\" The phrase \"at any time reach flag\" means that reaching the flag (prop_3) should eventually happen at some point, regardless of other conditions.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible\": \"prop_1\",\n  \"go by waste basket\": \"F prop_2\",\n  \"at any time reach flag\": \"F prop_3\"\n}\n\n3. *FINAL:* (prop_1 implies F prop_2)"}
{"id": 6656, "sentence": ["at", "some", "time", "show", "yourself", "near", "house", "or", "at", "some", "time", "pass", "by", "trash", "bin"], "tl": ["finally", "(", "show_yourself_near(house)", ")", "or", "finally", "(", "pass_by(trash_bin)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "pass", "by", "trash", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 7472, "sentence": ["snatch", "up", "pear", "and", "go", "to", "orange", "bin"], "tl": ["snatch_up(pear)", "and", "go_to(orange_bin)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch_up", "action_ref": "snatch up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange_bin)"], "args_ref": ["orange bin)"]}}, "prediction": "(snatching up the pear).\n   - \"go to orange bin\": represented by prop_2 (going to the orange bin).\n   The \"and\" indicates both actions should eventually happen. Since the command is about performing these actions, we use \"finally\" (F) to express that each action will eventually occur. The overall formula is the conjunction of these eventualities.\n\n2. *Explanation dictionary* \u2013\n{\n  \"snatch up pear\": \"F prop_1\",\n  \"go to orange bin\": \"F prop_2\",\n  \"snatch up pear and go to orange bin\": \"F prop_1 and F prop_2\"\n}\n\n3. *FINAL:* (F prop_1) and (F prop_2)"}
{"id": 5282, "sentence": ["put", "in", "bin", "or", "at", "any", "time", "gather", "pear"], "tl": ["put_in(bin)", "or", "finally", "(", "gather(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "any", "time", "gather", "pear", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}, "prop_2": {"action_canon": "gather", "action_ref": "gather", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 6373, "sentence": ["when", "drop", "orange", ",", "pick", "up", "fruit"], "tl": ["drop(orange)", "imply", "pick_up(fruit)"], "masked_tl": ["prop_1", "imply", "prop_2"], "grounded_sentence": ["when", "prop_1", ",", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["fruit)"], "args_ref": ["fruit)"]}}, "prediction": "(G) stating that if prop_1 is true, then finally (F) prop_2 will be true.\n\n2. *Explanation dictionary* \u2013 {\"drop orange\": \"prop_1\", \"pick up fruit\": \"prop_2\", \"when drop orange, pick up fruit\": \"G (prop_1 implies F prop_2)\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 5359, "sentence": ["if", "at", "some", "time", "take", "possession", "of", "bear", ",", "venture", "to", "trash", "can"], "tl": ["finally", "(", "take_possession_of(bear)", ")", "imply", "venture_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["if", "at", "some", "time", "prop_1", ",", "venture", "to", "trash", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(finally) the proposition \"take possession of bear\" (prop_1) becomes true. The phrase \"venture to trash can\" means that after that event, \"venture to trash can\" (prop_2) should happen. So, if eventually prop_1 happens, then eventually prop_2 should happen afterward. This can be expressed as: finally prop_1 implies finally prop_2.\n\n2. *Explanation dictionary* \u2013 {\"at some time take possession of bear\": \"F prop_1\", \"venture to trash can\": \"F prop_2\", \"if ... then ...\": \"F prop_1 implies F prop_2\"}\n\n3. *FINAL:* (F prop_1) implies (F prop_2)"}
{"id": 891, "sentence": ["collect", "pear", "or", "at", "any", "time", "contact", "house"], "tl": ["collect(pear)", "or", "finally", "(", "contact(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "any", "time", "contact", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 2105, "sentence": ["when", "possible", "go", "visit", "house", "and", "move", "to", "trash", "can"], "tl": ["finally", "(", "go_visit(house)", ")", "and", "move_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(go visit house and move to trash can).\"\n\n2. *Explanation dictionary* \u2013\n{\n  \"go visit house\": \"prop_1\",\n  \"move to trash can\": \"prop_2\",\n  \"go visit house and move to trash can\": \"(prop_1 and prop_2)\",\n  \"when possible\": \"F\"\n}\n\n3. *FINAL:* F (prop_1 and prop_2)"}
{"id": 5548, "sentence": ["at", "any", "time", "venture", "house", "and", "whenever", "visit", "house"], "tl": ["finally", "(", "venture(house)", ")", "and", "finally", "(", "visit(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "whenever", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (G prop_1) and (G (prop_2 implies prop_1)) FINISH"}
{"id": 2348, "sentence": ["never", "drop", "apple", "and", "go", "by", "waste", "bin"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "and", "go_by(waste_bin)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "and", "prop_2"], "grounded_sentence": ["never", "prop_1", "and", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) and prop_2 FINISH"}
{"id": 4701, "sentence": ["at", "some", "time", "seize", "orange", "and", "take", "pear"], "tl": ["finally", "(", "seize(orange)", ")", "and", "take(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(finally). The actions \"seize orange\" and \"take pear\" are represented by propositions prop_1 and prop_2 respectively. The conjunction \"and\" means both actions must happen. So, the formula states that eventually both prop_1 and prop_2 hold.\n\n2. *Explanation dictionary* \u2013 {\"at some time\": \"F\", \"seize orange\": \"prop_1\", \"take pear\": \"prop_2\", \"and\": \"and\"}\n\n3. *FINAL:* F (prop_1 and prop_2)"}
{"id": 3989, "sentence": ["at", "some", "time", "seize", "pear", "or", "hold", "on", "to", "pear"], "tl": ["finally", "(", "seize(pear)", ")", "or", "hold_on_to(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "hold_on_to", "action_ref": "hold on to", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 6649, "sentence": ["whenever", "withold", "apple", "or", "at", "any", "time", "reach", "tree"], "tl": ["finally", "(", "withold(apple)", ")", "or", "finally", "(", "reach(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withold", "action_ref": "withold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 365, "sentence": ["at", "any", "time", "advance", "to", "house", "or", "at", "any", "time", "touch", "tree"], "tl": ["finally", "(", "advance_to(house)", ")", "or", "finally", "(", "touch(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "any", "time", "touch", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 4126, "sentence": ["if", "when", "possible", "arrive", "at", "tree", ",", "take", "to", "trash", "can"], "tl": ["finally", "(", "arrive_at(tree)", ")", "imply", "take_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["if", "when", "possible", "prop_1", ",", "take", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "arrive_at", "action_ref": "arrive at", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 4223, "sentence": ["never", "drop", "orange", "or", "at", "any", "time", "spend", "time", "at", "tree"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "or", "finally", "(", "spend_time_at(tree)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "any", "time", "spend", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (G (not prop_1)) or (G prop_2) FINISH"}
{"id": 3192, "sentence": ["do", "not", "let", "go", "orange", "and", "get", "to", "tree"], "tl": ["negation", "(", "let_go(orange)", ")", "and", "get_to(tree)"], "masked_tl": ["negation", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["do", "not", "prop_1", "and", "get", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(G) and not (not) to express that \"orange\" is always true (prop_1 represents \"orange\"). The phrase \"and get to tree\" means that eventually (F) \"tree\" (prop_2) should become true. Combining these with \"and\" gives the full formula.\n\n2. *Explanation dictionary* \u2013 {\"do not let go orange\": \"G prop_1\", \"get to tree\": \"F prop_2\"}\n\n3. *FINAL:* (G prop_1) and (F prop_2)"}
{"id": 1104, "sentence": ["at", "any", "time", "go", "near", "flag", "or", "when", "possible", "go", "visit", "house"], "tl": ["finally", "(", "go_near(flag)", ")", "or", "finally", "(", "go_visit(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "go", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (globally prop_1) or (finally prop_2) FINISH"}
{"id": 3946, "sentence": ["when", "possible", "present", "at", "flag", "or", "never", "drop", "apple"], "tl": ["finally", "(", "present_at(flag)", ")", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. FINAL: (F prop_1) or (G (not prop_2)) FINISH"}
{"id": 4330, "sentence": ["secure", "apple", "or", "never", "drop", "apple"], "tl": ["secure(apple)", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 or (globally (not prop_2))) FINISH"}
{"id": 4510, "sentence": ["when", "possible", "start", "going", "to", "house", "can", "infer", "that", "when", "possible", "grab", "flag"], "tl": ["finally", "(", "start_going_to(house)", ")", "imply", "finally", "(", "grab(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "can", "infer", "that", "when", "possible", "grab", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1), then we can infer that \"when possible grab flag\" (prop_2). The phrase \"when possible\" is interpreted as \"eventually\" (finally), so \"when possible start going to house\" maps to F prop_1, and similarly \"when possible grab flag\" maps to F prop_2. The command implies an implication: if eventually start going to house, then eventually grab flag. So the formula is: (F prop_1) implies (F prop_2).\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible start going to house\": \"F prop_1\",\n  \"when possible grab flag\": \"F prop_2\"\n}\n\n3. *FINAL:* (F prop_1) implies (F prop_2)"}
{"id": 193, "sentence": ["at", "some", "time", "be", "near", "tree", "and", "at", "any", "time", "stop", "by", "trash", "can"], "tl": ["finally", "(", "be_near(tree)", ")", "and", "finally", "(", "stop_by(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "any", "time", "stop", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(F prop_1), where prop_1 represents \"be near tree\". The phrase \"at any time stop by trash can\" corresponds to \"globally prop_2\" (G prop_2), where prop_2 represents \"stop by trash can\". The conjunction \"and\" connects these two temporal requirements.\n\n2. *Explanation dictionary* \u2013 {\"at some time be near tree\": \"F prop_1\", \"at any time stop by trash can\": \"G prop_2\"}\n\n3. *FINAL:* (F prop_1) and (G prop_2)"}
{"id": 5422, "sentence": ["whenever", "visit", "house", "or", "never", "drop", "orange"], "tl": ["finally", "(", "visit(house)", ")", "or", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1) or (globally (not prop_2)) FINISH"}
{"id": 6425, "sentence": ["whenever", "migrate", "to", "tree", "or", "reach", "house"], "tl": ["finally", "(", "migrate_to(tree)", ")", "or", "reach(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "reach", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "migrate_to", "action_ref": "migrate to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(prop_1 or prop_2)\", \"whenever migrate to tree or reach house\": \"G(prop_1 or prop_2)\"}\n\n3. *FINAL:* G(prop_1 or prop_2)"}
{"id": 4407, "sentence": ["whenever", "be", "in", "house's", "vicinity", "or", "at", "any", "time", "snag", "orange"], "tl": ["finally", "(", "be_in(house's_vicinity)", ")", "or", "finally", "(", "snag(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "snag", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_in", "action_ref": "be in", "args_canon": ["house's_vicinity)"], "args_ref": ["house's vicinity)"]}, "prop_2": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(i.e., always), prop_2 should eventually happen.\n- Since \"or at any time\" means that snag orange should happen regardless of being in the house's vicinity, the formula simplifies to \"globally prop_2\" (snag orange always eventually happens)"}
{"id": 2820, "sentence": ["venture", "towards", "house", "or", "at", "some", "time", "present", "at", "flag"], "tl": ["venture_towards(house)", "or", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "present", "at", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 4469, "sentence": ["at", "some", "time", "go", "past", "house", "or", "repeatedly", "make", "way", "to", "house"], "tl": ["finally", "(", "go_past(house)", ")", "or", "globally", "(", "finally", "(", "make_way_to(house)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "repeatedly", "make", "way", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_past", "action_ref": "go past", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "make_way_to", "action_ref": "make way to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 5825, "sentence": ["when", "possible", "proceed", "to", "flag", "and", "at", "some", "time", "make", "contact", "with", "house"], "tl": ["finally", "(", "proceed_to(flag)", ")", "and", "finally", "(", "make_contact_with(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "some", "time", "make", "contact", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (F prop_1) implies (F prop_1) and (F prop_2) FINISH"}
{"id": 5358, "sentence": ["do", "not", "let", "go", "pear", "and", "at", "some", "time", "procure", "orange"], "tl": ["negation", "(", "let_go(pear)", ")", "and", "finally", "(", "procure(orange)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["do", "not", "prop_1", "and", "at", "some", "time", "procure", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) and (finally prop_2) FINISH"}
{"id": 4281, "sentence": ["at", "some", "time", "getting", "pear", "and", "hold", "orange"], "tl": ["finally", "(", "getting(pear)", ")", "and", "hold(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "getting", "action_ref": "getting", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* finally (prop_1 and prop_2) FINISH"}
{"id": 7452, "sentence": ["if", "at", "some", "time", "go", "to", "trash", "receptacle", ",", "grasp", "orange"], "tl": ["finally", "(", "go_to(trash_receptacle)", ")", "imply", "grasp(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["if", "at", "some", "time", "prop_1", ",", "grasp", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 0, 1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_receptacle)"], "args_ref": ["trash receptacle)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* ( (F prop_1) implies (F prop_2) ) FINISH"}
{"id": 2544, "sentence": ["when", "possible", "reach", "tree", "or", "whenever", "seize", "orange"], "tl": ["finally", "(", "reach(tree)", ")", "or", "finally", "(", "seize(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "whenever", "seize", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (finally prop_1)"}
{"id": 1277, "sentence": ["when", "possible", "visit", "flag", "and", "when", "possible", "go", "to", "trash", "bin"], "tl": ["finally", "(", "visit(flag)", ")", "and", "finally", "(", "go_to(trash_bin)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "3. *FINAL:* (G(F prop_1)) and (G(F prop_2)) FINISH"}
{"id": 2250, "sentence": ["get", "to", "tree", "or", "always", "hold", "on", "pear"], "tl": ["get_to(tree)", "or", "globally", "(", "hold_on(pear)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "always", "hold", "on", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "hold_on", "action_ref": "hold on", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (globally prop_2) FINISH"}
{"id": 4662, "sentence": ["never", "drop", "pear", "or", "whenever", "grasp", "pear"], "tl": ["globally", "(", "negation", "(", "drop(pear)", ")", ")", "or", "finally", "(", "grasp(pear)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "whenever", "grasp", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_2) to some condition. Since the command is \"never drop pear or whenever grasp pear\", it means either \"never drop pear\" holds or \"whenever grasp pear\" holds. The \"whenever grasp pear\" phrase is incomplete alone, but combined with \"never drop pear or whenever grasp pear\" suggests a disjunction between \"never drop pear\" and \"whenever grasp pear\". Since \"whenever grasp pear\" is a temporal condition, it can be interpreted as \"globally (grasp pear implies ...)\", but the command is ambiguous. Given the command, the best interpretation is: \"never drop pear\" or \"whenever grasp pear\" (i.e., \"globally (grasp pear implies something)\"), but since no consequent is given, we interpret \"whenever grasp pear\" as \"globally (grasp pear implies true)\", which is trivially true. Therefore, the formula reduces to \"globally not drop pear or globally (grasp pear implies true)"}
{"id": 6094, "sentence": ["when", "possible", "withdraw", "pear", "or", "always", "hold", "on", "pear"], "tl": ["finally", "(", "withdraw(pear)", ")", "or", "globally", "(", "hold_on(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "always", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withdraw", "action_ref": "withdraw", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "hold_on", "action_ref": "hold on", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(F prop_1) or (G prop_2)"}
{"id": 5274, "sentence": ["whenever", "secure", "pear", "or", "when", "possible", "go", "visit", "house"], "tl": ["finally", "(", "secure(pear)", ")", "or", "finally", "(", "go_visit(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(which we interpret as eventually), then \"go visit house\" should eventually happen.\n- \"when possible\" is interpreted as \"eventually\" (F).\n- So the condition is: (prop_1) or (F prop_2)\n- The command is: whenever this condition holds, eventually prop_2 should happen.\n- So, globally, if (prop_1 or F prop_2)"}
{"id": 5856, "sentence": ["repeatedly", "go", "to", "waste", "basket", "or", "at", "any", "time", "proceed", "to", "flag"], "tl": ["globally", "(", "finally", "(", "go_to(waste_basket)", ")", ")", "or", "finally", "(", "proceed_to(flag)", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "at", "any", "time", "proceed", "to", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (globally finally prop_1) or (globally finally prop_2) FINISH"}
{"id": 4755, "sentence": ["never", "let", "go", "orange", "or", "when", "possible", "have", "possession", "of", "apple"], "tl": ["globally", "(", "negation", "(", "let_go(orange)", ")", ")", "or", "finally", "(", "have_possession_of(apple)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "when", "possible", "have", "possession", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "have_possession_of", "action_ref": "have possession of", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "- So, globally not prop_1 and finally prop_2: G (not prop_1) and F (prop_2)."}
{"id": 2302, "sentence": ["whenever", "venture", "to", "waste", "basket", "or", "at", "any", "time", "tax", "apple"], "tl": ["finally", "(", "venture_to(waste_basket)", ")", "or", "finally", "(", "tax(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "tax", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1 implies ...)\", where prop_1 represents \"venture to waste basket\". The phrase \"or at any time tax apple\" means that either the first condition holds or \"tax apple\" holds at any time, so \"or prop_2\" where prop_2 represents \"tax apple\". Since \"at any time\" corresponds to \"globally\" or \"finally\", but here it means \"at any time\" as a condition, we interpret it as \"globally prop_2\". Combining these, the formula is \"globally (prop_1 or prop_2)\".\n\n2. *Explanation dictionary* \u2013 {\"venture to waste basket\": \"prop_1\", \"tax apple\": \"prop_2\", \"whenever venture to waste basket or at any time tax apple\": \"G (prop_1 or prop_2)\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 4022, "sentence": ["travel", "to", "tree", "and", "when", "possible", "approach", "flag"], "tl": ["travel_to(tree)", "and", "finally", "(", "approach(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "approach", "flag", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1) and (G (prop_2 implies F prop_3)) FINISH"}
{"id": 423, "sentence": ["whenever", "contact", "flag", "or", "at", "any", "time", "move", "past", "trash", "can"], "tl": ["finally", "(", "contact(flag)", ")", "or", "finally", "(", "move_past(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "move_past", "action_ref": "move past", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(prop_1 implies ...)\", where prop_1 represents \"contact flag\". The phrase \"or at any time move past trash can\" means that either the contact flag condition holds or eventually the action \"move past trash can\" happens. We represent \"move past trash can\" as prop_2. The \"or at any time\" suggests a disjunction between prop_1 and \"finally prop_2\". So the overall formula is \"globally (prop_1 or finally prop_2)\".\n\n2. *Explanation dictionary* \u2013 {\"contact flag\": \"prop_1\", \"move past trash can\": \"prop_2\", \"whenever contact flag or at any time move past trash can\": \"G (prop_1 or F prop_2)\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 3228, "sentence": ["drop", "pear", "or", "at", "some", "time", "clutch", "orange"], "tl": ["drop(pear)", "or", "finally", "(", "clutch(orange)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "clutch", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "clutch", "action_ref": "clutch", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 3685, "sentence": ["whenever", "withdraw", "pear", "or", "at", "some", "time", "move", "near", "tree"], "tl": ["finally", "(", "withdraw(pear)", ")", "or", "finally", "(", "move_near(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "some", "time", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withdraw", "action_ref": "withdraw", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "move_near", "action_ref": "move near", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(F prop_2).\n- \"withdraw pear or at some time move near tree\" is prop_1 or F prop_2.\n- \"whenever\" indicates a globally condition, so globally (prop_1 or F prop_2).\n\n2. *Explanation dictionary* \u2013 {\"withdraw pear\": \"prop_1\", \"move near tree\": \"prop_2\", \"at some time move near tree\": \"F prop_2\", \"withdraw pear or at some time move near tree\": \"prop_1 or F prop_2\", \"whenever withdraw pear or at some time move near tree\": \"G (prop_1 or F prop_2)\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 4316, "sentence": ["when", "possible", "go", "to", "trashcan", "and", "travel", "to", "apple"], "tl": ["finally", "(", "go_to(trashcan)", ")", "and", "travel_to(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 implies (F prop_2 and F prop_3)) FINISH"}
{"id": 4727, "sentence": ["when", "possible", "present", "at", "flag", "until", "when", "possible", "reach", "flag"], "tl": ["finally", "(", "present_at(flag)", ")", "until", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "until", "when", "possible", "reach", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(finally) prop_1 (present at flag) should hold. The phrase \"until when possible reach flag\" means that this condition should hold until it is possible to reach the flag (prop_2). So, the overall formula states: \"Eventually present at flag (prop_1) holds until eventually reach flag (prop_2) holds.\"\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible present at flag\": \"F prop_1\",\n  \"when possible reach flag\": \"F prop_2\",\n  \"until\": \"U\"\n}\n\n3. *FINAL:* (F prop_1) U (F prop_2)"}
{"id": 6051, "sentence": ["secure", "apple", "or", "venture", "towards", "house"], "tl": ["secure(apple)", "or", "venture_towards(house)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "venture", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (F (prop_1 or prop_2)) FINISH"}
{"id": 3453, "sentence": ["when", "possible", "reach", "flag", "can", "infer", "that", "when", "possible", "bring", "pear"], "tl": ["finally", "(", "reach(flag)", ")", "imply", "finally", "(", "bring(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "can", "infer", "that", "when", "possible", "bring", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_1 = reach flag). The phrase \"can infer that\" indicates implication. The phrase \"when possible bring pear\" again suggests \"eventually prop_2\" (prop_2 = bring pear). So the whole sentence means: if eventually reach flag, then eventually bring pear.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible reach flag\": \"F prop_1\",\n  \"when possible bring pear\": \"F prop_2\",\n  \"can infer that\": \"implies\"\n}\n\n3. *FINAL:* (F prop_1) implies (F prop_2)"}
{"id": 3222, "sentence": ["at", "any", "time", "go", "by", "waste", "basket", "or", "venture", "towards", "house"], "tl": ["finally", "(", "go_by(waste_basket)", ")", "or", "venture_towards(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "venture", "towards", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (globally (prop_1 or prop_2)) FINISH"}
{"id": 260, "sentence": ["go", "by", "waste", "bin", "until", "go", "by", "waste", "bin"], "tl": ["go_by(waste_bin)", "until", "go_by(waste_bin)"], "masked_tl": ["prop_2", "until", "prop_2"], "grounded_sentence": ["prop_1", "until", "go", "by", "waste", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "3. *FINAL:* (prop_1 until prop_1) FINISH"}
{"id": 2518, "sentence": ["at", "some", "time", "get", "hold", "apple", "or", "at", "some", "time", "seize", "orange"], "tl": ["finally", "(", "get_hold(apple)", ")", "or", "finally", "(", "seize(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "seize", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 2963, "sentence": ["forever", "moving", "or", "whenever", "venture", "flag"], "tl": ["globally", "(", "moving", ")", "or", "finally", "(", "venture(flag)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "whenever", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "moving", "action_ref": "moving", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (G prop_1) or (G (prop_2 implies prop_1)) FINISH"}
{"id": 5389, "sentence": ["at", "some", "time", "go", "by", "house", "and", "whenever", "grasp", "pear"], "tl": ["finally", "(", "go_by(house)", ")", "and", "finally", "(", "grasp(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "whenever", "grasp", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* ( (F prop_1) and (G prop_2) ) FINISH"}
{"id": 6293, "sentence": ["when", "possible", "venture", "flag", "or", "at", "any", "time", "stop", "by", "house"], "tl": ["finally", "(", "venture(flag)", ")", "or", "finally", "(", "stop_by(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "stop", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(if possible), or at any time stop by the house.\n\n2. *Explanation dictionary* \u2013\n{\n  \"venture flag\": \"prop_1\",\n  \"stop by house\": \"prop_2\",\n  \"when possible venture flag\": \"F prop_1\",\n  \"at any time stop by house\": \"G F prop_2\"\n}\n\n3. *FINAL:* (F prop_1) or (G F prop_2)"}
{"id": 4675, "sentence": ["travel", "to", "tree", "or", "at", "any", "time", "go", "home"], "tl": ["travel_to(tree)", "or", "finally", "(", "go(home)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "any", "time", "go", "home", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 3471, "sentence": ["at", "some", "time", "present", "at", "flag", "until", "at", "some", "time", "go", "by", "waste", "basket"], "tl": ["finally", "(", "present_at(flag)", ")", "until", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "at", "some", "time", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(F prop_1), where prop_1 represents \"present at flag.\" The phrase \"until at some time go by waste basket\" corresponds to \"until F prop_2,\" where prop_2 represents \"go by waste basket.\" Combining these, the entire command means \"present at flag holds until eventually go by waste basket,\" which is expressed as (prop_1 U F prop_2).\n\n2. *Explanation dictionary* \u2013 {\"at some time present at flag\": \"F prop_1\", \"at some time go by waste basket\": \"F prop_2\", \"present at flag until eventually go by waste basket\": \"(prop_1 U F prop_2)\"}\n\n3. *FINAL:* (prop_1 U F prop_2)"}
{"id": 347, "sentence": ["whenever", "show", "yourself", "near", "house", "and", "pick", "up", "orange"], "tl": ["finally", "(", "show_yourself_near(house)", ")", "and", "pick_up(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "pick", "up", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1 and prop_2) holds, something should follow. Since no explicit consequent is given, we interpret it as \"whenever the condition holds, it is true that the condition holds,\" which is tautological. More reasonably, the command likely means \"whenever you show yourself near the house, you pick up the orange,\" so \"whenever prop_1 then eventually prop_2.\" But the command says \"and,\" so both happen together. To capture \"whenever you show yourself near house and pick up orange,\" we can say globally (prop_1 and prop_2) holds. Alternatively, if the command is a trigger, \"whenever prop_1 then eventually prop_2\" is more natural. Since the command is \"whenever show yourself near house and pick up orange,\" it is likely a conjunction of two events that should always happen together. So the formula is globally (prop_1 and prop_2)"}
{"id": 3431, "sentence": ["when", "don't", "let", "go", "orange", ",", "when", "possible", "lay", "hold", "of", "apple"], "tl": ["negation", "(", "let_go(orange)", ")", "imply", "finally", "(", "lay_hold_of(apple)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "don't", "prop_1", ",", "when", "possible", "lay", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "lay_hold_of", "action_ref": "lay hold of", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* globally (implies (not prop_1) (finally prop_2)) FINISH"}
{"id": 2521, "sentence": ["capture", "orange", "or", "at", "some", "time", "secure", "pear"], "tl": ["capture(orange)", "or", "finally", "(", "secure(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "secure", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (F (prop_1 or prop_2)) FINISH"}
{"id": 3592, "sentence": ["at", "some", "time", "withhold", "apple", "and", "at", "some", "time", "reach", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "some", "time", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (finally prop_1) and (finally prop_2) FINISH"}
{"id": 3804, "sentence": ["keep", "apple", "until", "at", "any", "time", "start", "going", "to", "house"], "tl": ["keep(apple)", "until", "finally", "(", "start_going_to(house)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "any", "time", "start", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "keep", "action_ref": "keep", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_1 until (finally prop_2)) and (finally prop_2) FINISH"}
{"id": 5352, "sentence": ["at", "any", "time", "journey", "to", "flag", "or", "forever", "hold", "onto", "orange"], "tl": ["finally", "(", "journey_to(flag)", ")", "or", "globally", "(", "hold_onto(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "forever", "hold", "onto", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* globally ( (finally prop_1) or (globally prop_2) ) FINISH"}
{"id": 6684, "sentence": ["hold", "orange", "or", "go", "to", "bucket"], "tl": ["hold(orange)", "or", "go_to(bucket)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}}, "prediction": "3. *FINAL:* (prop_1 or prop_2) FINISH"}
{"id": 3940, "sentence": ["venture", "to", "trash", "can", "or", "hold", "pear"], "tl": ["venture_to(trash_can)", "or", "hold(pear)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "hold", "pear", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 4973, "sentence": ["snatch", "up", "pear", "and", "get", "to", "tree"], "tl": ["snatch_up(pear)", "and", "get_to(tree)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "get", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch_up", "action_ref": "snatch up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (finally prop_1) and (finally prop_2) FINISH"}
{"id": 6886, "sentence": ["at", "any", "time", "take", "possession", "of", "bear", "or", "when", "possible", "travel", "to", "house"], "tl": ["finally", "(", "take_possession_of(bear)", ")", "or", "finally", "(", "travel_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "travel", "to", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(G), meaning the property should hold at all times. The phrase \"take possession of bear or when possible travel to house\" is a disjunction (or) between two propositions: \"take possession of bear\" (prop_1) and \"when possible travel to house\" (prop_2). The entire command means that always, either prop_1 or prop_2 should hold.\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"G\", \"take possession of bear\": \"prop_1\", \"when possible travel to house\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 612, "sentence": ["do", "not", "let", "go", "pear", "or", "at", "any", "time", "venture", "flag"], "tl": ["negation", "(", "let_go(pear)", ")", "or", "finally", "(", "venture(flag)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["do", "not", "prop_1", "or", "at", "any", "time", "venture", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* globally (not (prop_1 or prop_2)) FINISH"}
{"id": 1739, "sentence": ["at", "any", "time", "set", "out", "to", "house", "or", "go", "visit", "flag"], "tl": ["finally", "(", "set_out_to(house)", ")", "or", "go_visit(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "go", "visit", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "set_out_to", "action_ref": "set out to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(G), meaning the property must hold at all times. The phrase \"set out to house or go visit flag\" corresponds to the disjunction \"prop_1 or prop_2\", where prop_1 represents \"set out to house\" and prop_2 represents \"go visit flag\". Combining these, the formula states that globally, either prop_1 or prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"globally\", \"set out to house\": \"prop_1\", \"go visit flag\": \"prop_2\", \"set out to house or go visit flag\": \"(prop_1 or prop_2)\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 3961, "sentence": ["at", "some", "time", "go", "to", "trashcan", "or", "keep", "apple"], "tl": ["finally", "(", "go_to(trashcan)", ")", "or", "keep(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "keep", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "keep", "action_ref": "keep", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 7433, "sentence": ["if", "always", "have", "in", "orange", ",", "at", "any", "time", "journey", "by", "flag"], "tl": ["globally", "(", "have_in(orange)", ")", "imply", "finally", "(", "journey_by(flag)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "always", "prop_1", ",", "at", "any", "time", "journey", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (globally prop_1) implies (finally prop_2) FINISH"}
{"id": 3580, "sentence": ["when", "possible", "go", "to", "trash", "can", "and", "at", "any", "time", "journey", "to", "flag"], "tl": ["finally", "(", "go_to(trash_can)", ")", "and", "finally", "(", "journey_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "any", "time", "journey", "to", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 implies finally prop_2) and (globally finally prop_3) FINISH"}
{"id": 1776, "sentence": ["at", "some", "time", "have", "pear", "or", "at", "any", "time", "start", "going", "to", "house"], "tl": ["finally", "(", "have(pear)", ")", "or", "finally", "(", "start_going_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "any", "time", "start", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F prop_1), where prop_1 represents \"have pear\". The phrase \"or\" is the logical or. The phrase \"at any time start going to house\" corresponds to \"globally prop_2\" (G prop_2), where prop_2 represents \"start going to house\". Combining these, the formula is (F prop_1) or (G prop_2).\n\n2. *Explanation dictionary* \u2013 {\"at some time have pear\": \"F prop_1\", \"or\": \"or\", \"at any time start going to house\": \"G prop_2\"}\n\n3. *FINAL:* (F prop_1) or (G prop_2)"}
{"id": 3071, "sentence": ["secure", "apple", "or", "at", "some", "time", "withhold", "apple"], "tl": ["secure(apple)", "or", "finally", "(", "withhold(apple)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "withhold", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 53, "sentence": ["always", "touch", "flag", "or", "at", "any", "time", "go", "to", "trash", "bin"], "tl": ["globally", "(", "touch(flag)", ")", "or", "finally", "(", "go_to(trash_bin)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "or", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "3. *FINAL:* (globally prop_1) or (finally prop_2) FINISH"}
{"id": 3691, "sentence": ["at", "any", "time", "lay", "hold", "of", "apple", "or", "go", "to", "orange", "bin"], "tl": ["finally", "(", "lay_hold_of(apple)", ")", "or", "go_to(orange_bin)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "go", "to", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "lay_hold_of", "action_ref": "lay hold of", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange_bin)"], "args_ref": ["orange bin)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 4782, "sentence": ["at", "any", "time", "snag", "orange", "and", "approach", "trash", "can"], "tl": ["finally", "(", "snag(orange)", ")", "and", "approach(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "approach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* globally (prop_1 and prop_2) FINISH"}
{"id": 7024, "sentence": ["at", "some", "time", "travel", "to", "trash", "can", "or", "at", "any", "time", "get", "hold", "apple"], "tl": ["finally", "(", "travel_to(trash_can)", ")", "or", "finally", "(", "get_hold(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "any", "time", "get", "hold", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(F prop_1), meaning that at some point in the future, prop_1 (travel to trash can) will be true. The phrase \"or\" corresponds to the Boolean \"or\" operator. The phrase \"at any time get hold apple\" corresponds to \"globally prop_2\" (G prop_2), meaning that at all times prop_2 (get hold apple) holds.\n\n2. *Explanation dictionary* \u2013 {\"at some time travel to trash can\": \"F prop_1\", \"or\": \"or\", \"at any time get hold apple\": \"G prop_2\"}\n\n3. *FINAL:* (F prop_1) or (G prop_2)"}
{"id": 361, "sentence": ["at", "some", "time", "withhold", "apple", "or", "at", "some", "time", "present", "at", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "or", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "present", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(F), indicating that something will happen eventually. The phrase \"withhold apple\" is represented by a proposition, say prop_1. The phrase \"present at flag\" is represented by another proposition, say prop_2. The command states \"at some time withhold apple or at some time present at flag,\" which translates to \"finally prop_1 or finally prop_2.\"\n\n2. *Explanation dictionary* \u2013 {\"at some time\": \"F\", \"withhold apple\": \"prop_1\", \"present at flag\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 6586, "sentence": ["move", "to", "trashcan", "or", "when", "possible", "migrate", "to", "tree"], "tl": ["move_to(trashcan)", "or", "finally", "(", "migrate_to(tree)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "migrate", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "migrate_to", "action_ref": "migrate to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 2331, "sentence": ["never", "let", "go", "or", "at", "any", "time", "go", "to", "tree"], "tl": ["globally", "(", "negation", "(", "let_go", ")", ")", "or", "finally", "(", "go_to(tree)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (G (not prop_1)) or (F prop_2) FINISH"}
{"id": 6639, "sentence": ["when", "possible", "show", "yourself", "near", "house", "and", "when", "possible", "pick", "up", "apple"], "tl": ["finally", "(", "show_yourself_near(house)", ")", "and", "finally", "(", "pick_up(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "pick", "up", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(finally, F). \"show yourself near house\" is represented by prop_1. \"pick up apple\" is represented by prop_2. The command says: eventually show yourself near house, and eventually pick up apple.\n\n2. *Explanation dictionary* \u2013 {\"when possible\": \"F\", \"show yourself near house\": \"prop_1\", \"pick up apple\": \"prop_2\"}\n\n3. *FINAL:* (F prop_1) and (F prop_2)"}
{"id": 5343, "sentence": ["reach", "house", "or", "when", "possible", "journey", "by", "flag"], "tl": ["reach(house)", "or", "finally", "(", "journey_by(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "journey", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 5509, "sentence": ["come", "to", "tree", "or", "forever", "have", "in", "orange"], "tl": ["come_to(tree)", "or", "globally", "(", "have_in(orange)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "forever", "have", "in", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "come_to", "action_ref": "come to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (globally prop_2) FINISH"}
{"id": 2727, "sentence": ["approach", "tree", "or", "whenever", "make", "way", "for", "tree"], "tl": ["approach(tree)", "or", "finally", "(", "make_way_for(tree)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "make", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "make_way_for", "action_ref": "make way for", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (prop_1 or (globally (prop_2 implies prop_1))) FINISH"}
{"id": 5477, "sentence": ["at", "any", "time", "withhold", "apple", "or", "whenever", "present", "at", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "or", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "whenever", "present", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(G), indicating the property must hold at all times. The phrase \"withhold apple or whenever present at flag\" means that either \"apple\" is withheld (represented by prop_1) or \"present at flag\" (represented by prop_2) holds. The \"or\" connects these two conditions. So the formula states that globally, either prop_1 (withhold apple) or prop_2 (present at flag) is true.\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"G\", \"withhold apple\": \"prop_1\", \"present at flag\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 6082, "sentence": ["at", "some", "time", "get", "apple", "or", "take", "orange"], "tl": ["finally", "(", "get(apple)", ")", "or", "take(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or prop_2) FINISH"}
{"id": 1246, "sentence": ["at", "some", "time", "make", "to", "flag", "or", "come", "to", "tree"], "tl": ["finally", "(", "make_to(flag)", ")", "or", "come_to(tree)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "come", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_to", "action_ref": "make to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "come_to", "action_ref": "come to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or prop_2) FINISH"}
{"id": 2732, "sentence": ["go", "to", "orange", "bin", "until", "whenever", "migrate", "to", "tree"], "tl": ["go_to(orange_bin)", "until", "finally", "(", "migrate_to(tree)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "whenever", "migrate", "to", "tree", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange_bin)"], "args_ref": ["orange bin)"]}, "prop_2": {"action_canon": "migrate_to", "action_ref": "migrate to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_2 implies (prop_1 until prop_2)) FINISH"}
{"id": 2199, "sentence": ["when", "possible", "journey", "by", "flag", "and", "at", "some", "time", "spend", "time", "at", "tree"], "tl": ["finally", "(", "journey_by(flag)", ")", "and", "finally", "(", "spend_time_at(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "some", "time", "spend", "time", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (prop_1 implies finally prop_2) FINISH"}
{"id": 3938, "sentence": ["whenever", "show", "yourself", "near", "house", "and", "when", "possible", "take", "possession", "of", "bear"], "tl": ["finally", "(", "show_yourself_near(house)", ")", "and", "finally", "(", "take_possession_of(bear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "when", "possible", "take", "possession", "of", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}}, "prediction": "(show yourself near house) holds, then something follows.\n- \"and when possible take possession of bear\" means: if it is possible to take possession of bear, then eventually prop_2 (take possession of bear) should happen.\n- Combining these: globally, if prop_1 holds, then eventually prop_2 should hold.\n\n2. Explanation dictionary:\n{\"show yourself near house\": \"prop_1\", \"take possession of bear\": \"prop_2\", \"whenever ... and ...\": \"globally (prop_1 implies finally prop_2)\"}\n\n3. FINAL: G (prop_1 implies F prop_2)"}
{"id": 2541, "sentence": ["procure", "apple", "and", "pick", "up", "orange"], "tl": ["procure(apple)", "and", "pick_up(orange)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "pick", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 and prop_2) FINISH"}
{"id": 5634, "sentence": ["at", "any", "time", "go", "near", "house", "and", "at", "any", "time", "grab", "flag"], "tl": ["finally", "(", "go_near(house)", ")", "and", "finally", "(", "grab(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "any", "time", "grab", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (globally(prop_1) and globally(prop_2)) FINISH"}
{"id": 3909, "sentence": ["always", "have", "apple", "and", "at", "some", "time", "acquire", "pear"], "tl": ["globally", "(", "have(apple)", ")", "and", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "and", "at", "some", "time", "acquire", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(G prop_1) and (F prop_2)"}
{"id": 6198, "sentence": ["grasp", "orange", "or", "at", "some", "time", "getting", "pear"], "tl": ["grasp(orange)", "or", "finally", "(", "getting(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "getting", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "getting", "action_ref": "getting", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or prop_2) FINISH"}
{"id": 3269, "sentence": ["whenever", "steal", "apple", "or", "go", "to", "bucket"], "tl": ["finally", "(", "steal(apple)", ")", "or", "go_to(bucket)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "steal", "action_ref": "steal", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}}, "prediction": "(assuming prop_1 = steal apple, prop_2 = go to bucket). The \"whenever\" maps to globally (G).\n\n2. *Explanation dictionary* \u2013 {\"steal apple\": \"prop_1\", \"go to bucket\": \"prop_2\", \"steal apple or go to bucket\": \"(prop_1 or prop_2)\", \"whenever steal apple or go to bucket\": \"G(prop_1 or prop_2)\"}\n\n3. *FINAL:* G(prop_1 or prop_2)"}
{"id": 2095, "sentence": ["when", "possible", "secure", "pear", "or", "never", "drop", "apple"], "tl": ["finally", "(", "secure(pear)", ")", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (globally (not prop_2)) FINISH"}
{"id": 343, "sentence": ["hold", "apple", "and", "at", "any", "time", "obtain", "apple"], "tl": ["hold(apple)", "and", "finally", "(", "obtain(apple)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "any", "time", "obtain", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 and finally prop_2) FINISH"}
{"id": 4393, "sentence": ["when", "possible", "withold", "apple", "or", "when", "possible", "get", "apple"], "tl": ["finally", "(", "withold(apple)", ")", "or", "finally", "(", "get(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "get", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withold", "action_ref": "withold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "get", "action_ref": "get", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(or) of these two parts.\n\n2. *Explanation dictionary*:\n{\n  \"when possible withhold apple\": \"(F prop_2) implies (F prop_1)\",\n  \"withhold apple\": \"prop_1\",\n  \"possible to withhold apple\": \"prop_2\",\n  \"when possible get apple\": \"(F prop_4)"}
{"id": 865, "sentence": ["at", "any", "time", "secure", "pear", "until", "visit", "tree"], "tl": ["finally", "(", "secure(pear)", ")", "until", "visit(tree)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "until", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 until prop_2) FINISH"}
{"id": 3649, "sentence": ["whenever", "grab", "apple", "until", "at", "any", "time", "grasp", "apple"], "tl": ["finally", "(", "grab(apple)", ")", "until", "finally", "(", "grasp(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "until", "at", "any", "time", "grasp", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1) holds, something must follow. The phrase \"until at any time grasp apple\" means that this condition holds until at some future point \"grasp apple\" (prop_2) occurs. \"At any time\" corresponds to \"eventually\" (F). So the formula states that whenever prop_1 holds, it continues to hold until eventually prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"whenever grab apple\": \"prop_1\", \"until\": \"U\", \"at any time grasp apple\": \"F prop_2\"}\n\n3. *FINAL:* G (prop_1 \u2192 (prop_1 U F prop_2))"}
{"id": 627, "sentence": ["at", "any", "time", "travel", "to", "house", "and", "when", "possible", "travel", "house"], "tl": ["finally", "(", "travel_to(house)", ")", "and", "finally", "(", "travel(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "when", "possible", "travel", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel", "action_ref": "travel", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (G prop_1) and (G (prop_2 implies prop_3)) FINISH"}
{"id": 1569, "sentence": ["repeatedly", "go", "to", "pear", "and", "put", "in", "bin"], "tl": ["globally", "(", "finally", "(", "go_to(pear)", ")", ")", "and", "put_in(bin)"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "and", "prop_2"], "grounded_sentence": ["repeatedly", "prop_1", "and", "put", "in", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}}, "prediction": "(prop_1 and prop_2). \"Repeatedly\" means this should happen infinitely often, which is captured by globally finally: G F (prop_1 and prop_2).\n\n2. *Explanation dictionary* \u2013 {\"go to pear\": \"prop_1\", \"put in bin\": \"prop_2\", \"go to pear and put in bin\": \"(prop_1 and prop_2)\", \"repeatedly\": \"G F\"}\n\n3. *FINAL:* G F (prop_1 and prop_2)"}
{"id": 1040, "sentence": ["hold", "on", "to", "pear", "or", "whenever", "reach", "tree"], "tl": ["hold_on_to(pear)", "or", "finally", "(", "reach(tree)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "reach", "tree", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold_on_to", "action_ref": "hold on to", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (globally(prop_1) or globally(prop_2 implies prop_1)) FINISH"}
{"id": 568, "sentence": ["whenever", "tax", "apple", "or", "when", "possible", "go", "to", "apple"], "tl": ["finally", "(", "tax(apple)", ")", "or", "finally", "(", "go_to(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* G((prop_1 or prop_2) implies F prop_3) FINISH"}
{"id": 7086, "sentence": ["repeatedly", "go", "to", "pear", "or", "whenever", "procure", "pear"], "tl": ["globally", "(", "finally", "(", "go_to(pear)", ")", ")", "or", "finally", "(", "procure(pear)", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "whenever", "procure", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (globally finally prop_1) or (globally (prop_2 implies next prop_1)) FINISH"}
{"id": 6475, "sentence": ["do", "not", "let", "go", "pear", "and", "repeatedly", "grab", "tree"], "tl": ["negation", "(", "let_go(pear)", ")", "and", "globally", "(", "finally", "(", "grab(tree)", ")", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "and", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["do", "not", "prop_1", "and", "repeatedly", "grab", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(prop_1) should never become false once held, so we use globally (G) and not (not) to express \"never let go pear\": G(prop_1). The phrase \"repeatedly grab tree\" means that \"tree\" (prop_2) should happen infinitely often, which can be expressed as \"globally finally prop_2\" (G F prop_2).\n\n2. *Explanation dictionary* \u2013\n{\n  \"do not let go pear\": \"G(prop_1)\",\n  \"repeatedly grab tree\": \"G F prop_2\"\n}\n\n3. *FINAL:* (G(prop_1) and G F prop_2)"}
{"id": 3083, "sentence": ["whenever", "venture", "flag", "or", "travel", "to", "apple"], "tl": ["finally", "(", "venture(flag)", ")", "or", "travel_to(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(G) condition. The condition is \"venture flag or travel to apple,\" which can be represented as (prop_1 or prop_2). The formula states that globally, if (venture flag or travel to apple) holds, then some property should hold. Since the command is incomplete about what should happen after, we interpret it as \"whenever (venture flag or travel to apple) happens,\" so the formula is simply G(prop_1 or prop_2).\n\n2. *Explanation dictionary* \u2013 {\"whenever\": \"G\", \"venture flag\": \"prop_1\", \"travel to apple\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G(prop_1 or prop_2)"}
{"id": 6294, "sentence": ["put", "in", "bucket", "or", "at", "any", "time", "go", "to", "tree"], "tl": ["put_in(bucket)", "or", "finally", "(", "go_to(tree)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "any", "time", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(F) operator on each proposition and combine them with or.\n\n2. *Explanation dictionary* \u2013 {\"put in bucket\": \"prop_1\", \"go to tree\": \"prop_2\", \"or\": \"or\", \"at any time\": \"F\"}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 2139, "sentence": ["whenever", "visit", "house", "or", "whenever", "start", "going", "to", "tree"], "tl": ["finally", "(", "visit(house)", ")", "or", "finally", "(", "start_going_to(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "start", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (globally (prop_1)) or (globally (prop_2)) FINISH"}
{"id": 3045, "sentence": ["whenever", "contact", "house", "or", "stop", "by", "flag"], "tl": ["finally", "(", "contact(house)", ")", "or", "stop_by(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "stop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* G(prop_1 or prop_2)"}
{"id": 186, "sentence": ["when", "possible", "withhold", "apple", "and", "when", "possible", "withhold", "apple"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "finally", "(", "withhold(apple)", ")"], "masked_tl": ["finally", "(", "prop_2", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "withhold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1 \u2192 F prop_1)\"}\n\n3. *FINAL:* G (prop_1 \u2192 F prop_1) and G (prop_1 \u2192 F prop_1)"}
{"id": 3661, "sentence": ["at", "any", "time", "walk", "to", "flag", "or", "never", "let", "go", "apple"], "tl": ["finally", "(", "walk_to(flag)", ")", "or", "globally", "(", "negation", "(", "let_go(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "never", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* G (prop_1 or G (not prop_2)) FINISH"}
{"id": 5291, "sentence": ["when", "when", "possible", "let", "go", "apple", ",", "at", "some", "time", "move", "to", "flag"], "tl": ["finally", "(", "let_go(apple)", ")", "imply", "finally", "(", "move_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "when", "possible", "prop_1", ",", "at", "some", "time", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(let go apple) leads to eventually prop_2 (move to flag).\n\n2. *Explanation dictionary* \u2013\n{\n  \"possible\": \"F prop_1\",\n  \"let go apple\": \"prop_1\",\n  \"at some time move to flag\": \"F prop_2\",\n  \"when possible let go apple\": \"F prop_1\",\n  \"when when possible let go apple, at some time move to flag\": \"F prop_1 implies F prop_2\"\n}\n\n3. *FINAL:* (F prop_1) implies (F prop_2)"}
{"id": 4919, "sentence": ["never", "let", "go", "apple", "or", "approach", "tree"], "tl": ["globally", "(", "negation", "(", "let_go(apple)", ")", ")", "or", "approach(tree)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "prop_2"], "grounded_sentence": ["never", "prop_1", "or", "approach", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (not (prop_1 or prop_2)) FINISH"}
{"id": 6710, "sentence": ["at", "any", "time", "approach", "flag", "or", "put", "in", "apple", "bucket"], "tl": ["finally", "(", "approach(flag)", ")", "or", "put_in(apple_bucket)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "put", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["apple_bucket)"], "args_ref": ["apple bucket)"]}}, "prediction": "(G), meaning the property must hold at all times. The phrase \"approach flag or put in apple bucket\" corresponds to \"prop_1 or prop_2\", where prop_1 represents \"approach flag\" and prop_2 represents \"put in apple bucket\". Combining these, the formula states that globally, either prop_1 or prop_2 must hold.\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"globally\", \"approach flag\": \"prop_1\", \"put in apple bucket\": \"prop_2\", \"approach flag or put in apple bucket\": \"(prop_1 or prop_2)\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 2394, "sentence": ["when", "possible", "get", "close", "tree", "or", "at", "any", "time", "grab", "orange"], "tl": ["finally", "(", "get_close(tree)", ")", "or", "finally", "(", "grab(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "grab", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(finally) the proposition prop_1 (\"get close tree\") should hold if possible. The phrase \"or at any time grab orange\" means that at any time (globally) prop_2 (\"grab orange\") can hold. Combining these with \"or\" means either eventually get close tree or always grab orange.\n\n2. *Explanation dictionary* \u2013 {\"when possible get close tree\": \"F prop_1\", \"at any time grab orange\": \"G prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (F prop_1) or (G prop_2)"}
{"id": 6256, "sentence": ["when", "possible", "be", "near", "tree", "and", "at", "some", "time", "procure", "orange"], "tl": ["finally", "(", "be_near(tree)", ")", "and", "finally", "(", "procure(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "some", "time", "procure", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(we interpret this as \"not globally not prop_1,\" i.e., not always not prop_1)"}
{"id": 1829, "sentence": ["approach", "tree", "or", "at", "some", "time", "acquire", "pear"], "tl": ["approach(tree)", "or", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "acquire", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(finally) prop_2 (acquire pear) will be true. The \"or\" connects these two conditions, so the formula states that either prop_1 is true now or eventually prop_2 will be true.\n\n2. *Explanation dictionary* \u2013 {\"approach tree\": \"prop_1\", \"at some time acquire pear\": \"F prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (prop_1 or F prop_2)"}
{"id": 7284, "sentence": ["always", "have", "apple", "or", "whenever", "go", "to", "flag"], "tl": ["globally", "(", "have(apple)", ")", "or", "finally", "(", "go_to(flag)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "or", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(apple) is true globally: G prop_1.\n- \"whenever go to flag\" means that whenever prop_2 (go to flag) occurs, some condition holds. Since the command is \"always have apple or whenever go to flag,\" it suggests that either apple is always present, or whenever we go to flag, some condition holds.\n- The phrase \"always have apple or whenever go to flag\" can be interpreted as: globally, either apple is true, or whenever we go to flag, something holds.\n- Since the command is ambiguous about what happens \"whenever go to flag,\" the simplest interpretation is that \"always have apple or whenever go to flag\" means: globally, (apple) or (go to flag).\n- But \"whenever go to flag\" is a temporal condition, so \"whenever go to flag\" can be expressed as: G (prop_2 \u2192 ...). Since no further condition is specified, we can interpret the command as: G (prop_1 or prop_2)"}
{"id": 6252, "sentence": ["pick", "up", "flag", "or", "always", "hold", "onto", "orange"], "tl": ["pick_up(flag)", "or", "globally", "(", "hold_onto(orange)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "always", "hold", "onto", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 or (globally prop_2)) FINISH"}
{"id": 724, "sentence": ["when", "possible", "touch", "tree", "and", "reach", "trash", "can"], "tl": ["finally", "(", "touch(tree)", ")", "and", "reach(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (F (prop_1 and prop_2)) implies (F prop_1 and F prop_2) FINISH"}
{"id": 3121, "sentence": ["when", "possible", "reach", "flag", "and", "venture", "towards", "house"], "tl": ["finally", "(", "reach(flag)", ")", "and", "venture_towards(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(eventually prop_1), then eventually prop_1 happens, and after that, eventually prop_2 happens.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible reach flag\": \"F prop_1\",\n  \"venture towards house\": \"F prop_2\"\n}\n\n3. *FINAL:* (F prop_1) and (F prop_2)"}
{"id": 2991, "sentence": ["at", "some", "time", "go", "near", "house", "or", "keep", "apple"], "tl": ["finally", "(", "go_near(house)", ")", "or", "keep(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "keep", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "keep", "action_ref": "keep", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 784, "sentence": ["at", "some", "time", "go", "by", "waste", "basket", "and", "whenever", "reach", "flag"], "tl": ["finally", "(", "go_by(waste_basket)", ")", "and", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "whenever", "reach", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"whenever reach flag\": \"globally (prop_2 implies ...)\","}
{"id": 3362, "sentence": ["whenever", "advance", "to", "house", "or", "at", "some", "time", "take", "possession", "of", "bear"], "tl": ["finally", "(", "advance_to(house)", ")", "or", "finally", "(", "take_possession_of(bear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "some", "time", "take", "possession", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}}, "prediction": "(G) with an implication. The phrase \"or at some time take possession of bear\" means either the first condition or eventually take possession of bear (prop_2). So the formula states: globally, if prop_1 holds, or eventually prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"advance to house\": \"prop_1\", \"take possession of bear\": \"prop_2\", \"whenever advance to house\": \"G (prop_1 \u2192 ...)\", \"at some time take possession of bear\": \"F prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 1912, "sentence": ["never", "let", "go", "or", "whenever", "grab", "orange"], "tl": ["globally", "(", "negation", "(", "let_go", ")", ")", "or", "finally", "(", "grab(orange)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "whenever", "grab", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* globally (or (not prop_1) prop_2) FINISH"}
{"id": 2889, "sentence": ["whenever", "go", "to", "trash", "can", "or", "take", "apple"], "tl": ["finally", "(", "go_to(trash_can)", ")", "or", "take(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "take", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(always) condition. The condition is \"go to trash can or take apple,\" which is a disjunction of two propositions: prop_1 for \"go to trash can\" and prop_2 for \"take apple.\" So, the formula states that globally, if prop_1 or prop_2 holds, then something should follow. Since the command is just \"whenever\" without a consequent, we interpret it as \"whenever prop_1 or prop_2 happens,\" which is simply globally (prop_1 or prop_2).\n\n2. *Explanation dictionary* \u2013 {\"whenever\": \"globally\", \"go to trash can\": \"prop_1\", \"take apple\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 6174, "sentence": ["forever", "have", "apple", "or", "at", "any", "time", "travel", "to", "flag"], "tl": ["globally", "(", "have(apple)", ")", "or", "finally", "(", "travel_to(flag)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "at", "any", "time", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1 or F prop_2).\n\n2. *Explanation dictionary* \u2013 {\"forever\": \"G\", \"have apple\": \"prop_1\", \"or\": \"or\", \"at any time\": \"F\", \"travel to flag\": \"prop_2\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 3048, "sentence": ["when", "possible", "grasp", "pear", "can", "infer", "that", "whenever", "go", "to", "flag"], "tl": ["finally", "(", "grasp(pear)", ")", "imply", "finally", "(", "go_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "can", "infer", "that", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 implies (globally prop_2)) FINISH"}
{"id": 2998, "sentence": ["at", "some", "time", "scoop", "up", "pear", "or", "whenever", "travel", "by", "tree"], "tl": ["finally", "(", "scoop_up(pear)", ")", "or", "finally", "(", "travel_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "whenever", "travel", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "travel_by", "action_ref": "travel by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(F prop_1), where prop_1 represents \"scoop up pear\". The phrase \"whenever travel by tree\" corresponds to \"globally (prop_2 implies ...)\", where prop_2 represents \"travel by tree\". Since the command uses \"or\" between these two parts, the overall formula is the disjunction of these two subformulas: (F prop_1) or (G (prop_2 implies ...)). The phrase \"whenever travel by tree\" is incomplete alone, but since it is connected by \"or\" to the first part, we interpret it as \"whenever travel by tree\" holds, something else holds. Since no further condition is given, we interpret \"whenever travel by tree\" as a condition that must hold globally, so the formula is (F prop_1) or (G prop_2)"}
{"id": 7219, "sentence": ["seize", "apple", "or", "forever", "touch", "flag"], "tl": ["seize(apple)", "or", "globally", "(", "touch(flag)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "forever", "touch", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 or globally prop_2) FINISH"}
{"id": 1775, "sentence": ["at", "some", "time", "obtain", "apple", "and", "visit", "tree"], "tl": ["finally", "(", "obtain(apple)", ")", "and", "visit(tree)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* finally (prop_1 and prop_2) FINISH"}
{"id": 7250, "sentence": ["when", "possible", "procure", "orange", "and", "at", "any", "time", "pick", "up", "peach"], "tl": ["finally", "(", "procure(orange)", ")", "and", "finally", "(", "pick_up(peach)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "any", "time", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["peach)"], "args_ref": ["peach)"]}}, "prediction": "(finally). So \"when possible procure orange\" maps to \"finally prop_1\" where prop_1 = procure orange. The phrase \"at any time pick up peach\" means that at all times, pick up peach is possible, so \"globally prop_2\" where prop_2 = pick up peach. The conjunction \"and\" connects these two parts.\n\n2. *Explanation dictionary* \u2013 {\"when possible procure orange\": \"F prop_1\", \"procure orange\": \"prop_1\", \"at any time pick up peach\": \"G prop_2\", \"pick up peach\": \"prop_2\", \"and\": \"and\"}\n\n3. *FINAL:* (F prop_1) and (G prop_2)"}
{"id": 6054, "sentence": ["whenever", "go", "near", "pear", "and", "move", "to", "tree"], "tl": ["finally", "(", "go_near(pear)", ")", "and", "move_to(tree)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 and prop_2) FINISH"}
{"id": 2549, "sentence": ["at", "any", "time", "pass", "by", "trash", "bin", "and", "whenever", "go", "by", "tree"], "tl": ["finally", "(", "pass_by(trash_bin)", ")", "and", "finally", "(", "go_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "whenever", "go", "by", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (globally prop_1) and (globally prop_2) FINISH"}
{"id": 2487, "sentence": ["at", "any", "time", "grab", "pear", "or", "when", "possible", "shift", "to", "flag"], "tl": ["finally", "(", "grab(pear)", ")", "or", "finally", "(", "shift_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "shift", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "shift_to", "action_ref": "shift to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(G), indicating the property should hold always. The phrase \"grab pear or when possible shift to flag\" is a disjunction (or) between two actions: \"grab pear\" and \"shift to flag\". \"grab pear\" is represented by prop_1, and \"shift to flag\" by prop_2. The phrase \"when possible\" suggests that shifting to flag should eventually happen if possible, so we use \"finally\" (F) for prop_2. Combining these, the formula states that always (G), either prop_1 holds or eventually (F) prop_2 holds.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time\": \"globally\",\n  \"grab pear\": \"prop_1\",\n  \"shift to flag\": \"prop_2\",\n  \"when possible\": \"finally\",\n  \"grab pear or when possible shift to flag\": \"(prop_1 or finally prop_2)\"\n}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 2918, "sentence": ["at", "any", "time", "go", "near", "pear", "and", "never", "let", "go", "apple"], "tl": ["finally", "(", "go_near(pear)", ")", "and", "globally", "(", "negation", "(", "let_go(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "never", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(G), meaning the property holds always. \"go near pear\" is represented by prop_1. \"never let go apple\" means \"not eventually let go apple,\" so \"never let go apple\" is \"not finally prop_2.\" The entire command is \"globally (prop_1 and not finally prop_2).\"\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"globally\", \"go near pear\": \"prop_1\", \"never let go apple\": \"not finally prop_2\"}\n\n3. *FINAL:* G (prop_1 and not F prop_2)"}
{"id": 3010, "sentence": ["when", "possible", "stand", "by", "tree", "until", "at", "any", "time", "walk", "to", "flag"], "tl": ["finally", "(", "stand_by(tree)", ")", "until", "finally", "(", "walk_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "until", "at", "any", "time", "walk", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "stand_by", "action_ref": "stand by", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1 U prop_2)"}
{"id": 4397, "sentence": ["whenever", "proceed", "to", "tree", "or", "gather", "apple"], "tl": ["finally", "(", "proceed_to(tree)", ")", "or", "gather(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "gather", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "gather", "action_ref": "gather", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1 or prop_2)\", \"whenever proceed to tree or gather apple\": \"G(prop_1 or prop_2)\"}\n\n3. *FINAL:* G(prop_1 or prop_2)"}
{"id": 2699, "sentence": ["when", "whenever", "go", "visit", "house", ",", "move", "to", "house"], "tl": ["finally", "(", "go_visit(house)", ")", "imply", "move_to(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["when", "whenever", "prop_1", ",", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(representing \"go visit house\") holds, something else must follow. The phrase \"move to house\" is the consequent action, represented by prop_2. Thus, the formula states that globally (always), if prop_1 is true, then eventually prop_2 will be true.\n\n2. *Explanation dictionary* \u2013 {\"whenever go visit house\": \"prop_1\", \"move to house\": \"prop_2\", \"whenever ... then eventually ...\": \"G (prop_1 implies F prop_2)\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 2211, "sentence": ["whenever", "make", "contact", "flag", "and", "go", "visit", "flag"], "tl": ["finally", "(", "make_contact(flag)", ")", "and", "go_visit(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "go", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact", "action_ref": "make contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* globally (prop_1 and prop_2) FINISH"}
{"id": 2863, "sentence": ["hold", "on", "to", "pear", "or", "go", "to", "orange"], "tl": ["hold_on_to(pear)", "or", "go_to(orange)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "go", "to", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold_on_to", "action_ref": "hold on to", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 or prop_2) FINISH"}
{"id": 1828, "sentence": ["at", "any", "time", "come", "home", "until", "never", "let", "go", "orange"], "tl": ["finally", "(", "come(home)", ")", "until", "globally", "(", "negation", "(", "let_go(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "until", "never", "let", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "come", "action_ref": "come", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(G), meaning always in the future. \"Come home\" is represented by prop_1. \"Until\" indicates the use of the until operator (U). \"Never let go orange\" means that \"let go orange\" (prop_2) never happens, so \"not prop_2\" always holds. Thus, the formula states that \"come home\" holds until \"let go orange\" never happens, which means \"come home\" holds forever because \"let go orange\" never occurs.\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"globally\", \"come home\": \"prop_1\", \"until\": \"until\", \"never let go orange\": \"not prop_2\"}\n\n3. *FINAL:* G (prop_1 U (not prop_2))"}
{"id": 7096, "sentence": ["when", "possible", "go", "near", "flag", "or", "move", "towards", "trash", "can"], "tl": ["finally", "(", "go_near(flag)", ")", "or", "move_towards(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "or", "move", "towards", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "move_towards", "action_ref": "move towards", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* G (prop_3 implies F (prop_1 or prop_2)) FINISH"}
{"id": 108, "sentence": ["forever", "hold", "onto", "orange", "or", "at", "some", "time", "make", "contact", "with", "house"], "tl": ["globally", "(", "hold_onto(orange)", ")", "or", "finally", "(", "make_contact_with(house)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "at", "some", "time", "make", "contact", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (globally(prop_1) or finally(prop_2)) FINISH"}
{"id": 1308, "sentence": ["whenever", "get", "hold", "apple", "or", "travel", "to", "waste", "bin"], "tl": ["finally", "(", "get_hold(apple)", ")", "or", "travel_to(waste_bin)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "(G) applying to the condition \"get hold apple or travel to waste bin\". We map \"get hold apple\" to prop_1 and \"travel to waste bin\" to prop_2. The phrase \"whenever ... or ...\" translates to globally (G) of (prop_1 or prop_2).\n\n2. *Explanation dictionary* \u2013 {\"get hold apple\": \"prop_1\", \"travel to waste bin\": \"prop_2\", \"whenever get hold apple or travel to waste bin\": \"G (prop_1 or prop_2)\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 1927, "sentence": ["at", "some", "time", "track", "towards", "tree", "and", "grip", "apple"], "tl": ["finally", "(", "track_towards(tree)", ")", "and", "grip(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "grip", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "track_towards", "action_ref": "track towards", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "grip", "action_ref": "grip", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* finally (prop_1 and prop_2) FINISH"}
{"id": 4155, "sentence": ["at", "some", "time", "going", "to", "house", "and", "at", "some", "time", "be", "near", "tree"], "tl": ["finally", "(", "going_to(house)", ")", "and", "finally", "(", "be_near(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "some", "time", "be", "near", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (finally prop_1) and (finally prop_2) FINISH"}
{"id": 1341, "sentence": ["at", "some", "time", "steal", "apple", "and", "when", "possible", "move", "to", "flag"], "tl": ["finally", "(", "steal(apple)", ")", "and", "finally", "(", "move_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "when", "possible", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "steal", "action_ref": "steal", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (F prop_1) and (G (prop_2 implies F prop_3)) FINISH"}
{"id": 3625, "sentence": ["when", "possible", "bring", "pear", "until", "whenever", "go", "by", "waste", "basket"], "tl": ["finally", "(", "bring(pear)", ")", "until", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "until", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(F prop_1)"}
{"id": 5755, "sentence": ["go", "to", "orange", "and", "don't", "pick", "up", "anything"], "tl": ["go_to(orange)", "and", "negation", "(", "finally", "(", "pick_up(anything)", ")", ")"], "masked_tl": ["prop_1", "and", "negation", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "don't", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["anything)"], "args_ref": ["anything)"]}}, "prediction": "3. *FINAL:* (F prop_1) and (G not prop_2) FINISH"}
{"id": 5496, "sentence": ["never", "drop", "orange", "or", "at", "some", "time", "seize", "pear"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "or", "finally", "(", "seize(pear)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "some", "time", "seize", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (G (not prop_1)) or (F prop_2) FINISH"}
{"id": 1455, "sentence": ["never", "drop", "orange", "and", "when", "possible", "acquire", "pear"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "and", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "and", "when", "possible", "acquire", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* globally (not prop_1) and globally (prop_2 implies finally prop_2) FINISH"}
{"id": 3985, "sentence": ["whenever", "contact", "flag", "and", "at", "any", "time", "move", "to", "flag"], "tl": ["finally", "(", "contact(flag)", ")", "and", "finally", "(", "move_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "any", "time", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 6755, "sentence": ["when", "possible", "get", "pear", "or", "at", "any", "time", "approach", "flag"], "tl": ["finally", "(", "get(pear)", ")", "or", "finally", "(", "approach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "approach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 1505, "sentence": ["at", "any", "time", "move", "forward", "trash", "can", "or", "whenever", "getting", "pear"], "tl": ["finally", "(", "move_forward(trash_can)", ")", "or", "finally", "(", "getting(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "whenever", "getting", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_forward", "action_ref": "move forward", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "getting", "action_ref": "getting", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (globally prop_1) or (globally (prop_2 implies prop_1)) FINISH"}
{"id": 5479, "sentence": ["at", "any", "time", "grasp", "pear", "and", "at", "some", "time", "tax", "apple"], "tl": ["finally", "(", "grasp(pear)", ")", "and", "finally", "(", "tax(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "tax", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (globally prop_1) and (finally prop_2) FINISH"}
{"id": 718, "sentence": ["forever", "have", "apple", "or", "at", "some", "time", "grab", "apple"], "tl": ["globally", "(", "have(apple)", ")", "or", "finally", "(", "grab(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "at", "some", "time", "grab", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(or) between \"have apple\" (prop_1) and \"at some time grab apple\" (finally prop_2). So the formula is G (prop_1 or F prop_2).\n\n2. *Explanation dictionary* \u2013 {\"forever\": \"G\", \"have apple\": \"prop_1\", \"or\": \"or\", \"at some time grab apple\": \"F prop_2\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 5860, "sentence": ["go", "to", "bucket", "or", "whenever", "stand", "by", "tree"], "tl": ["go_to(bucket)", "or", "finally", "(", "stand_by(tree)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "stand", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "stand_by", "action_ref": "stand by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 1334, "sentence": ["at", "any", "time", "go", "to", "trash", "can", "or", "pick", "up", "flag"], "tl": ["finally", "(", "go_to(trash_can)", ")", "or", "pick_up(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "pick", "up", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(G), meaning the property holds at all times. The phrase \"go to trash can or pick up flag\" corresponds to the disjunction \"prop_1 or prop_2\", where prop_1 represents \"go to trash can\" and prop_2 represents \"pick up flag\". Combining these, the formula states that globally, either prop_1 or prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"globally\", \"go to trash can\": \"prop_1\", \"pick up flag\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 6752, "sentence": ["forever", "move", "or", "whenever", "obtain", "apple"], "tl": ["globally", "(", "move", ")", "or", "finally", "(", "obtain(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "whenever", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move", "action_ref": "move", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(if obtain apple then true),\" but since \"whenever\" is used with \"obtain apple\" alone, it suggests that whenever \"obtain apple\" happens, the condition is true, so the entire formula is \"G (move or obtain apple)\".\n\n2. *Explanation dictionary* \u2013 {\"forever\": \"G\", \"move\": \"prop_1\", \"obtain apple\": \"prop_2\", \"move or whenever obtain apple\": \"(prop_1 or prop_2)\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 3716, "sentence": ["when", "possible", "be", "near", "tree", "or", "at", "some", "time", "go", "past", "flag"], "tl": ["finally", "(", "be_near(tree)", ")", "or", "finally", "(", "go_past(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "some", "time", "go", "past", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go_past", "action_ref": "go past", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(F) the system should go past the flag. The overall meaning is: if it is possible to be near a tree (i.e., eventually be near a tree), then eventually go past the flag.\n\n2. *Explanation dictionary* \u2013 {\"be near tree\": \"prop_1\", \"go past flag\": \"prop_2\", \"possible\": \"F prop_1\", \"at some time\": \"F prop_2\", \"when possible ... go past flag\": \"F prop_1 implies F prop_2\"}\n\n3. *FINAL:* (F prop_1) implies (F prop_2)"}
{"id": 3935, "sentence": ["whenever", "go", "past", "flag", "or", "always", "hold", "onto", "orange"], "tl": ["finally", "(", "go_past(flag)", ")", "or", "globally", "(", "hold_onto(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "always", "hold", "onto", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_past", "action_ref": "go past", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (globally prop_1) or (globally prop_2) FINISH"}
{"id": 2090, "sentence": ["whenever", "withdraw", "pear", "or", "never", "drop", "orange"], "tl": ["finally", "(", "withdraw(pear)", ")", "or", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withdraw", "action_ref": "withdraw", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "- \"whenever\" indicates a globally condition on the implication: whenever (prop_1 or G (not prop_2)) holds, so globally (prop_1 or G (not prop_2))."}
{"id": 2789, "sentence": ["drop", "orange", "or", "whenever", "contact", "house"], "tl": ["drop(orange)", "or", "finally", "(", "contact(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "contact", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(implying an alternative), but only one alternative is given, we interpret \"drop orange or\" as \"drop orange or something else,\" but since no other alternative is specified, we treat it as \"drop orange\" or \"something else\" is not specified, so we consider \"drop orange\" as the main action. The command likely means: \"Whenever contact house occurs, drop orange or do something else,\" but since only \"drop orange\" is specified, we interpret it as \"Whenever contact house occurs, drop orange or (some other condition) holds.\" Since no other condition is given, we interpret it as \"Whenever contact house occurs, drop orange or (some other condition) holds,\" but to be precise, we can write: \"Whenever contact house occurs, drop orange or (some other condition) holds,\" but since no other condition is given, we can write: \"Whenever contact house occurs, drop orange or (some other condition)"}
{"id": 6669, "sentence": ["pick", "up", "pear", "or", "forever", "have", "apple"], "tl": ["pick_up(pear)", "or", "globally", "(", "have(apple)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "forever", "have", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 or globally prop_2) FINISH"}
{"id": 5928, "sentence": ["when", "venture", "towards", "house", ",", "at", "some", "time", "venture", "to", "house"], "tl": ["venture_towards(house)", "imply", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "prop_1", ",", "at", "some", "time", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (finally prop_1) implies (finally prop_2) FINISH"}
{"id": 2621, "sentence": ["when", "possible", "scoop", "up", "pear", "or", "when", "possible", "capture", "pear"], "tl": ["finally", "(", "scoop_up(pear)", ")", "or", "finally", "(", "capture(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "capture", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (F (prop_1 or prop_2)) FINISH"}
{"id": 6192, "sentence": ["whenever", "venture", "to", "house", "until", "whenever", "bring", "pear"], "tl": ["finally", "(", "venture_to(house)", ")", "until", "finally", "(", "bring(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "until", "whenever", "bring", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* G (prop_1 implies (not prop_2 until prop_2)) FINISH"}
{"id": 4044, "sentence": ["visit", "tree", "until", "acquire", "apple"], "tl": ["visit(tree)", "until", "acquire(apple)"], "masked_tl": ["prop_1", "until", "prop_2"], "grounded_sentence": ["prop_1", "until", "acquire", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(U). So the command \"visit tree until acquire apple\" translates to \"prop_1 until prop_2\".\n\n2. *Explanation dictionary* \u2013 {\"visit tree\": \"prop_1\", \"acquire apple\": \"prop_2\", \"until\": \"U\"}\n\n3. *FINAL:* (prop_1 U prop_2)"}
{"id": 352, "sentence": ["when", "never", "drop", "apple", ",", "secure", "apple"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "imply", "secure(apple)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "imply", "prop_2"], "grounded_sentence": ["when", "never", "prop_1", ",", "secure", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) implies (globally prop_2) FINISH"}
{"id": 3088, "sentence": ["always", "have", "apple", "and", "at", "some", "time", "get", "hold", "apple"], "tl": ["globally", "(", "have(apple)", ")", "and", "finally", "(", "get_hold(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "and", "at", "some", "time", "get", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (globally prop_1) and (finally prop_2) FINISH"}
{"id": 5000, "sentence": ["when", "possible", "pass", "by", "house", "or", "at", "some", "time", "travel", "to", "trash", "can"], "tl": ["finally", "(", "pass_by(house)", ")", "or", "finally", "(", "travel_to(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "some", "time", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (finally (prop_1)) implies (finally (prop_2)) FINISH"}
{"id": 6725, "sentence": ["at", "any", "time", "be", "in", "house's", "vicinity", "or", "repeatedly", "grab", "tree"], "tl": ["finally", "(", "be_in(house's_vicinity)", ")", "or", "globally", "(", "finally", "(", "grab(tree)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "repeatedly", "grab", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_in", "action_ref": "be in", "args_canon": ["house's_vicinity)"], "args_ref": ["house's vicinity)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or (globally finally prop_2)) FINISH"}
{"id": 700, "sentence": ["repeatedly", "make", "way", "to", "house", "or", "do", "not", "let", "go", "pear"], "tl": ["globally", "(", "finally", "(", "make_way_to(house)", ")", ")", "or", "negation", "(", "let_go(pear)", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "negation", "(", "prop_2", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "do", "not", "let", "go", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_way_to", "action_ref": "make way to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 2285, "sentence": ["at", "any", "time", "go", "to", "trash", "bin", "or", "when", "possible", "go", "near", "flag"], "tl": ["finally", "(", "go_to(trash_bin)", ")", "or", "finally", "(", "go_near(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "go", "near", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or finally prop_2) FINISH"}
{"id": 2384, "sentence": ["acquire", "apple", "or", "whenever", "grab", "pear"], "tl": ["acquire(apple)", "or", "finally", "(", "grab(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "grab", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"acquire apple or whenever grab pear\": \"prop_1 or globally (prop_2 implies prop_1)\""}
{"id": 1833, "sentence": ["at", "any", "time", "take", "possession", "of", "bear", "and", "hold", "on", "to", "pear"], "tl": ["finally", "(", "take_possession_of(bear)", ")", "and", "hold_on_to(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "hold", "on", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}, "prop_2": {"action_canon": "hold_on_to", "action_ref": "hold on to", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (globally (prop_1 and prop_2)) FINISH"}
{"id": 5763, "sentence": ["secure", "apple", "until", "whenever", "bring", "pear"], "tl": ["secure(apple)", "until", "finally", "(", "bring(pear)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "whenever", "bring", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* G (prop_2 implies (prop_1 U prop_2)) FINISH"}
{"id": 4451, "sentence": ["when", "possible", "advance", "to", "house", "or", "whenever", "travel", "to", "house"], "tl": ["finally", "(", "advance_to(house)", ")", "or", "finally", "(", "travel_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "whenever", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_1 implies finally prop_2) or globally (prop_3 implies prop_2) FINISH"}
{"id": 5902, "sentence": ["whenever", "be", "in", "house's", "vicinity", "or", "when", "possible", "go", "to", "trashcan"], "tl": ["finally", "(", "be_in(house's_vicinity)", ")", "or", "finally", "(", "go_to(trashcan)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "go", "to", "trashcan", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_in", "action_ref": "be in", "args_canon": ["house's_vicinity)"], "args_ref": ["house's vicinity)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 115, "sentence": ["go", "by", "waste", "bin", "and", "secure", "apple"], "tl": ["go_by(waste_bin)", "and", "secure(apple)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "secure", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 and prop_2) FINISH"}
{"id": 6544, "sentence": ["if", "move", "to", "house", ",", "at", "some", "time", "travel", "by", "tree"], "tl": ["move_to(house)", "imply", "finally", "(", "travel_by(tree)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "prop_1", ",", "at", "some", "time", "travel", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_by", "action_ref": "travel by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 2901, "sentence": ["drop", "orange", "and", "when", "possible", "go", "by", "flag"], "tl": ["drop(orange)", "and", "finally", "(", "go_by(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 and finally prop_2) FINISH"}
{"id": 6550, "sentence": ["forever", "have", "in", "orange", "or", "when", "possible", "lay", "hold", "of", "apple"], "tl": ["globally", "(", "have_in(orange)", ")", "or", "finally", "(", "lay_hold_of(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "when", "possible", "lay", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "lay_hold_of", "action_ref": "lay hold of", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1 or prop_2)"}
{"id": 6731, "sentence": ["whenever", "walk", "near", "flag", "and", "at", "any", "time", "travel", "by", "tree"], "tl": ["finally", "(", "walk_near(flag)", ")", "and", "finally", "(", "travel_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "any", "time", "travel", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk_near", "action_ref": "walk near", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "travel_by", "action_ref": "travel by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 2706, "sentence": ["if", "whenever", "make", "way", "waste", "basket", ",", "at", "any", "time", "spend", "time", "at", "tree"], "tl": ["finally", "(", "make_way(waste_basket)", ")", "imply", "finally", "(", "spend_time_at(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "whenever", "prop_1", ",", "at", "any", "time", "spend", "time", "at", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_way", "action_ref": "make way", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 3470, "sentence": ["travel", "to", "apple", "or", "always", "have", "in", "orange"], "tl": ["travel_to(apple)", "or", "globally", "(", "have_in(orange)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "always", "have", "in", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"or\": \"or\""}
