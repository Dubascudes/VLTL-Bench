{"id": 5390, "sentence": ["travel", "to", "waste", "bin", "or", "drop", "orange"], "tl": ["travel_to(waste_bin)", "or", "drop(orange)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "drop", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 or prop_2) FINISH"}
{"id": 5999, "sentence": ["at", "any", "time", "scoop", "up", "apple", "until", "when", "possible", "move", "past", "trash", "can"], "tl": ["finally", "(", "scoop_up(apple)", ")", "until", "finally", "(", "move_past(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "until", "when", "possible", "move", "past", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "move_past", "action_ref": "move past", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(G), indicating the property holds always. \"scoop up apple\" is represented by a proposition, say prop_1. The phrase \"until when possible move past trash can\" indicates that \"scoop up apple\" holds until \"move past trash can\" becomes possible, represented by prop_2. So the formula is: globally (prop_1 until prop_2).\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"globally\", \"scoop up apple\": \"prop_1\", \"when possible move past trash can\": \"prop_2\", \"until\": \"until\"}\n\n3. *FINAL:* G (prop_1 U prop_2)"}
{"id": 3757, "sentence": ["at", "any", "time", "touch", "house", "or", "capture", "orange"], "tl": ["finally", "(", "touch(house)", ")", "or", "capture(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "capture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 5730, "sentence": ["at", "some", "time", "present", "at", "flag", "or", "whenever", "bring", "pear"], "tl": ["finally", "(", "present_at(flag)", ")", "or", "finally", "(", "bring(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "whenever", "bring", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (globally prop_2) FINISH"}
{"id": 6450, "sentence": ["move", "to", "house", "and", "put", "in", "bucket"], "tl": ["move_to(house)", "and", "put_in(bucket)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "put", "in", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}}, "prediction": "     \"and\": \"and\""}
{"id": 6506, "sentence": ["at", "any", "time", "pick", "up", "peach", "and", "drop", "orange"], "tl": ["finally", "(", "pick_up(peach)", ")", "and", "drop(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "drop", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["peach)"], "args_ref": ["peach)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1) and dropping orange (prop_2). Thus, the entire command translates to \"globally (pick up peach and drop orange)\".\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"globally\", \"pick up peach\": \"prop_1\", \"drop orange\": \"prop_2\", \"pick up peach and drop orange\": \"(prop_1 and prop_2)\"}\n\n3. *FINAL:* G (prop_1 and prop_2)"}
{"id": 1893, "sentence": ["never", "drop", "orange", "or", "at", "some", "time", "move", "forward", "trash", "can"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "or", "finally", "(", "move_forward(trash_can)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "some", "time", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "move_forward", "action_ref": "move forward", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (G (not prop_1)) or (F prop_2) FINISH"}
{"id": 6221, "sentence": ["at", "any", "time", "visit", "trash", "bin", "or", "when", "possible", "journey", "by", "flag"], "tl": ["finally", "(", "visit(trash_bin)", ")", "or", "finally", "(", "journey_by(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "journey", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or finally prop_2) FINISH"}
{"id": 5253, "sentence": ["hold", "pear", "and", "at", "any", "time", "venture", "to", "waste", "basket"], "tl": ["hold(pear)", "and", "finally", "(", "venture_to(waste_basket)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "any", "time", "venture", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "3. *FINAL:* (prop_1) and (G (prop_2 implies prop_1)) FINISH"}
{"id": 4059, "sentence": ["at", "some", "time", "get", "close", "flag", "or", "at", "some", "time", "walk", "to", "flag"], "tl": ["finally", "(", "get_close(flag)", ")", "or", "finally", "(", "walk_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "walk", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 4803, "sentence": ["at", "some", "time", "proceed", "to", "house", "and", "whenever", "go", "to", "tree"], "tl": ["finally", "(", "proceed_to(house)", ")", "and", "finally", "(", "go_to(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "whenever", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(finally) the proposition prop_1 (proceed to house) will be true, so we use F prop_1. The phrase \"whenever go to tree\" means that globally (always), if prop_2 (go to tree) is true, then something follows. Since the command is incomplete after \"whenever go to tree,\" we interpret it as \"whenever go to tree, something happens,\" but since no further action is specified, we assume the command is \"whenever go to tree\" alone, which is incomplete. However, the original command is \"at some time proceed to house and whenever go to tree,\" which likely means \"at some time proceed to house, and whenever go to tree, do something.\" Since no action is specified after \"whenever go to tree,\" we interpret it as \"whenever go to tree, proceed to house\" or \"whenever go to tree, something holds.\" But since the command is ambiguous, the best interpretation is \"at some time proceed to house and globally (whenever)"}
{"id": 5583, "sentence": ["whenever", "withhold", "apple", "until", "venture", "towards", "house"], "tl": ["finally", "(", "withhold(apple)", ")", "until", "venture_towards(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "until", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(prop_1 \u2192 (prop_1 U prop_2))\",\n  \"withhold apple\": \"prop_1\",\n  \"venture towards house\": \"prop_2\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 (prop_1 U prop_2))"}
{"id": 1035, "sentence": ["whenever", "secure", "pear", "and", "whenever", "travel", "to", "house"], "tl": ["finally", "(", "secure(pear)", ")", "and", "finally", "(", "travel_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "whenever", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (G(prop_1) and G(prop_2)) FINISH"}
{"id": 968, "sentence": ["hold", "pear", "until", "when", "possible", "get", "apple"], "tl": ["hold(pear)", "until", "finally", "(", "get(apple)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "when", "possible", "get", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "get", "action_ref": "get", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1) U (prop_2) FINISH"}
{"id": 1439, "sentence": ["at", "some", "time", "snatch", "pear", "means", "that", "go", "visit", "flag"], "tl": ["finally", "(", "snatch(pear)", ")", "imply", "go_visit(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "means", "that", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch", "action_ref": "snatch", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(F), indicating that something will happen eventually. \"snatch pear\" is represented by a proposition, say prop_1. The phrase \"means that\" corresponds to logical implication (implies). The phrase \"go visit flag\" is represented by another proposition, say prop_2. So the entire sentence means: if at some time \"snatch pear\" happens, then \"go visit flag\" must happen.\n\n2. *Explanation dictionary* \u2013 {\"at some time snatch pear\": \"F prop_1\", \"means that\": \"implies\", \"go visit flag\": \"prop_2\"}\n\n3. *FINAL:* (F prop_1)"}
{"id": 2835, "sentence": ["take", "orange", "and", "at", "any", "time", "go", "near", "pear"], "tl": ["take(orange)", "and", "finally", "(", "go_near(pear)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take", "action_ref": "take", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (prop_1 and finally prop_2) FINISH"}
{"id": 501, "sentence": ["when", "possible", "journey", "by", "house", "or", "when", "possible", "stand", "by", "tree"], "tl": ["finally", "(", "journey_by(house)", ")", "or", "finally", "(", "stand_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "stand", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "stand_by", "action_ref": "stand by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 5202, "sentence": ["at", "some", "time", "pass", "by", "house", "or", "move", "to", "trash", "can"], "tl": ["finally", "(", "pass_by(house)", ")", "or", "move_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 52, "sentence": ["secure", "apple", "until", "secure", "apple"], "tl": ["secure(apple)", "until", "secure(apple)"], "masked_tl": ["prop_2", "until", "prop_2"], "grounded_sentence": ["prop_1", "until", "secure", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(represented as prop_1) holds continuously until it holds again. Since both phrases are the same, the formula is prop_1 U prop_1, which simplifies to just prop_1.\n\n2. *Explanation dictionary* \u2013 {\"secure apple\": \"prop_1\", \"secure apple until secure apple\": \"prop_1 U prop_1\"}\n\n3. *FINAL:* (prop_1 U prop_1)"}
{"id": 7171, "sentence": ["travel", "to", "waste", "bin", "or", "pick", "up", "orange"], "tl": ["travel_to(waste_bin)", "or", "pick_up(orange)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "pick", "up", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(F) operator on each and combine them with or.\n\n2. *Explanation dictionary* \u2013 {\"travel to waste bin\": \"F prop_1\", \"pick up orange\": \"F prop_2\"}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 5547, "sentence": ["put", "in", "bucket", "until", "at", "some", "time", "obtain", "orange"], "tl": ["put_in(bucket)", "until", "finally", "(", "obtain(orange)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "some", "time", "obtain", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 until prop_2) FINISH"}
{"id": 1429, "sentence": ["at", "some", "time", "get", "orange", "means", "that", "at", "any", "time", "proceed", "to", "house"], "tl": ["finally", "(", "get(orange)", ")", "imply", "finally", "(", "proceed_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "means", "that", "at", "any", "time", "proceed", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F prop_1) implies (G prop_2).\n\n2. *Explanation dictionary* \u2013 {\"at some time get orange\": \"F prop_1\", \"at any time proceed to house\": \"G prop_2\", \"means that\": \"implies\"}\n\n3. *FINAL:* (F prop_1) implies (G prop_2)"}
{"id": 1408, "sentence": ["pick", "up", "fruit", "until", "at", "any", "time", "go", "past", "flag"], "tl": ["pick_up(fruit)", "until", "finally", "(", "go_past(flag)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "any", "time", "go", "past", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["fruit)"], "args_ref": ["fruit)"]}, "prop_2": {"action_canon": "go_past", "action_ref": "go past", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 until prop_2) FINISH"}
{"id": 431, "sentence": ["whenever", "spend", "time", "at", "tree", "and", "never", "drop", "orange"], "tl": ["finally", "(", "spend_time_at(tree)", ")", "and", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "never", "drop", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies globally (not prop_2)) FINISH"}
{"id": 1430, "sentence": ["at", "any", "time", "be", "near", "tree", "and", "at", "some", "time", "getting", "pear"], "tl": ["finally", "(", "be_near(tree)", ")", "and", "finally", "(", "getting(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "getting", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "getting", "action_ref": "getting", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (globally prop_1) and (finally prop_2) FINISH"}
{"id": 5678, "sentence": ["put", "in", "bin", "or", "seize", "apple"], "tl": ["put_in(bin)", "or", "seize(apple)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "seize", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(finally) either prop_1 or prop_2 will be true.\n\n2. *Explanation dictionary* \u2013 {\"put in bin\": \"prop_1\", \"seize apple\": \"prop_2\", \"or\": \"or\", \"eventually\": \"F\"}\n\n3. *FINAL:* F (prop_1 or prop_2)"}
{"id": 3015, "sentence": ["if", "at", "any", "time", "present", "at", "flag", ",", "never", "drop", "apple"], "tl": ["finally", "(", "present_at(flag)", ")", "imply", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["if", "at", "any", "time", "prop_1", ",", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* G (prop_1 implies G (not prop_2)) FINISH"}
{"id": 1949, "sentence": ["at", "some", "time", "arrive", "at", "tree", "or", "at", "any", "time", "journey", "to", "house"], "tl": ["finally", "(", "arrive_at(tree)", ")", "or", "finally", "(", "journey_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "any", "time", "journey", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "arrive_at", "action_ref": "arrive at", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F prop_1), where prop_1 represents \"arrive at tree\". The phrase \"or at any time journey to house\" corresponds to \"globally prop_2\" (G prop_2), where prop_2 represents \"journey to house\". The entire command is the disjunction of these two parts: (F prop_1) or (G prop_2).\n\n2. *Explanation dictionary* \u2013 {\"at some time arrive at tree\": \"F prop_1\", \"at any time journey to house\": \"G prop_2\"}\n\n3. *FINAL:* (F prop_1) or (G prop_2)"}
{"id": 3250, "sentence": ["when", "secure", "apple", ",", "at", "some", "time", "present", "at", "flag"], "tl": ["secure(apple)", "imply", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "prop_1", ",", "at", "some", "time", "present", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 5502, "sentence": ["whenever", "stop", "by", "house", "and", "move", "to", "trashcan"], "tl": ["finally", "(", "stop_by(house)", ")", "and", "move_to(trashcan)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "(G) to say \"always,\" and implies (\u2192) to say \"if stop by house then eventually move to trashcan.\" The \"eventually\" operator is finally (F).\n\n2. *Explanation dictionary* \u2013 {\"stop by house\": \"prop_1\", \"move to trashcan\": \"prop_2\", \"whenever stop by house and move to trashcan\": \"G (prop_1 implies F prop_2)\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 3955, "sentence": ["when", "possible", "stop", "by", "house", "and", "whenever", "venture", "flag"], "tl": ["finally", "(", "stop_by(house)", ")", "and", "finally", "(", "venture(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "whenever", "venture", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* G (prop_2 implies (prop_1 implies F prop_1)) FINISH"}
{"id": 2188, "sentence": ["never", "drop", "apple", "and", "never", "drop", "apple"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "and", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_2", ")", ")", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["never", "prop_1", "and", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (G not prop_1) and (G not prop_1) FINISH"}
{"id": 725, "sentence": ["at", "some", "time", "grab", "apple", "and", "when", "possible", "capture", "pear"], "tl": ["finally", "(", "grab(apple)", ")", "and", "finally", "(", "capture(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "when", "possible", "capture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (F prop_1) and (G (prop_3 implies prop_2)) FINISH"}
{"id": 46, "sentence": ["when", "possible", "lay", "hold", "of", "apple", "and", "drop", "pear"], "tl": ["finally", "(", "lay_hold_of(apple)", ")", "and", "drop(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "drop", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "lay_hold_of", "action_ref": "lay hold of", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(possible to lay hold of apple), then eventually prop_2 should also be true (drop pear).\n\n2. *Explanation dictionary* \u2013 {\"when possible\": \"F prop_1\", \"lay hold of apple\": \"prop_1\", \"drop pear\": \"prop_2\", \"and\": \"and\"}\n\n3. *FINAL:* (F prop_1) implies (F prop_2)"}
{"id": 3574, "sentence": ["at", "some", "time", "tax", "apple", "can", "infer", "that", "whenever", "advance", "to", "house"], "tl": ["finally", "(", "tax(apple)", ")", "imply", "finally", "(", "advance_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "can", "infer", "that", "whenever", "advance", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F), indicating that something eventually happens. The phrase \"tax apple can infer that whenever advance to house\" means that whenever \"advance to house\" (prop_2) holds, \"tax apple\" (prop_1) can be inferred, so \"advance to house\" implies \"tax apple\". Combining these, we get that eventually, it is true that \"advance to house\" implies \"tax apple\".\n\n2. *Explanation dictionary* \u2013 {\"at some time\": \"F\", \"tax apple\": \"prop_1\", \"advance to house\": \"prop_2\", \"whenever advance to house\": \"prop_2 implies prop_1\"}\n\n3. *FINAL:* F (prop_2 implies prop_1)"}
{"id": 2585, "sentence": ["never", "drop", "pear", "until", "at", "any", "time", "collect", "apple"], "tl": ["globally", "(", "negation", "(", "drop(pear)", ")", ")", "until", "finally", "(", "collect(apple)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "until", "at", "any", "time", "collect", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(not prop_1) U prop_2\n\n2. *Explanation dictionary* \u2013 {\"never drop pear\": \"not prop_1\", \"at any time collect apple\": \"prop_2\", \"never drop pear until at any time collect apple\": \"(not prop_1) U prop_2\"}\n\n3. *FINAL:* (not prop_1)"}
{"id": 4452, "sentence": ["at", "any", "time", "get", "close", "flag", "or", "at", "any", "time", "capture", "pear"], "tl": ["finally", "(", "get_close(flag)", ")", "or", "finally", "(", "capture(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "any", "time", "capture", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (globally (prop_1 or prop_2)) FINISH"}
{"id": 4906, "sentence": ["hold", "orange", "or", "pick", "up", "pear"], "tl": ["hold(orange)", "or", "pick_up(pear)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "pick", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or prop_2) FINISH"}
{"id": 3746, "sentence": ["when", "possible", "arrive", "at", "tree", "and", "pick", "up", "orange"], "tl": ["finally", "(", "arrive_at(tree)", ")", "and", "pick_up(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "arrive_at", "action_ref": "arrive at", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (F (prop_1 and prop_2)) FINISH"}
{"id": 4932, "sentence": ["when", "possible", "pass", "by", "waste", "receptacle", "and", "when", "possible", "take", "possession", "of", "bear"], "tl": ["finally", "(", "pass_by(waste_receptacle)", ")", "and", "finally", "(", "take_possession_of(bear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "take", "possession", "of", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["waste_receptacle)"], "args_ref": ["waste receptacle)"]}, "prop_2": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}}, "prediction": "3. *FINAL:* (finally prop_1) and (finally prop_2) FINISH"}
{"id": 7345, "sentence": ["when", "possible", "obtain", "orange", "or", "take", "to", "tree"], "tl": ["finally", "(", "obtain(orange)", ")", "or", "take_to(tree)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "or", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(obtain orange) or prop_2 (take to tree). The word \"when possible\" can be interpreted as \"if it is possible, then eventually,\" which in temporal logic can be expressed as \"globally, if it is possible, then finally (obtain orange or take to tree).\" Since \"possible\" is not explicitly defined, we treat the entire condition as \"if possible\" meaning \"if the opportunity arises,\" so we can model this as \"globally, if possible, then finally (prop_1 or prop_2).\" Without a proposition for \"possible,\" we can interpret \"when possible\" as a condition that the action should eventually happen if it can, so the simplest interpretation is \"finally (prop_1 or prop_2)"}
{"id": 473, "sentence": ["drop", "by", "and", "never", "let", "go", "orange"], "tl": ["drop_by", "and", "globally", "(", "negation", "(", "let_go(orange)", ")", ")"], "masked_tl": ["prop_1", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "never", "let", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop_by", "action_ref": "drop by", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (F prop_1) and (G not prop_2) FINISH"}
{"id": 2877, "sentence": ["come", "to", "tree", "or", "at", "some", "time", "stop", "by", "house"], "tl": ["come_to(tree)", "or", "finally", "(", "stop_by(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "stop", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "come_to", "action_ref": "come to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F) operator.\n- The \"or\" connects the two possibilities: either \"come to tree\" happens now or \"stop by house\" happens eventually.\n\n2. *Explanation dictionary*:\n{\"come to tree\": \"prop_1\", \"stop by house\": \"prop_2\", \"at some time stop by house\": \"F prop_2\", \"come to tree or at some time stop by house\": \"prop_1 or F prop_2\"}\n\n3. *FINAL:* (prop_1 or F prop_2)"}
{"id": 3313, "sentence": ["at", "some", "time", "make", "contact", "with", "house", "and", "travel", "to", "waste", "bin"], "tl": ["finally", "(", "make_contact_with(house)", ")", "and", "travel_to(waste_bin)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "travel", "to", "waste", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "(finally). \"Make contact with house\" is represented by prop_1. \"Travel to waste bin\" is represented by prop_2. The conjunction \"and\" connects these two propositions. So, the formula states that eventually, both prop_1 and prop_2 hold simultaneously.\n\n2. *Explanation dictionary* \u2013 {\"at some time\": \"F\", \"make contact with house\": \"prop_1\", \"travel to waste bin\": \"prop_2\", \"and\": \"and\"}\n\n3. *FINAL:* F (prop_1 and prop_2)"}
{"id": 5898, "sentence": ["at", "any", "time", "venture", "to", "house", "or", "never", "drop", "apple"], "tl": ["finally", "(", "venture_to(house)", ")", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* G (prop_1 or G (not prop_2)) FINISH"}
{"id": 515, "sentence": ["at", "some", "time", "pass", "by", "house", "or", "whenever", "stand", "by", "tree"], "tl": ["finally", "(", "pass_by(house)", ")", "or", "finally", "(", "stand_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "whenever", "stand", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "stand_by", "action_ref": "stand by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(F), meaning eventually. The \"or\" connects two conditions: \"pass by house\" and \"whenever stand by tree.\" The \"whenever\" suggests that whenever \"stand by tree\" occurs, some condition holds, but since no further condition is specified, we interpret it as \"stand by tree\" can happen at any time. So the formula is the disjunction of \"finally pass by house\" and \"globally (stand by tree implies stand by tree),\" which simplifies to \"finally pass by house or globally true,\" but since \"stand by tree\" is a proposition, we interpret \"whenever stand by tree\" as \"globally (stand by tree implies stand by tree)"}
{"id": 4616, "sentence": ["at", "some", "time", "go", "to", "tree", "or", "at", "some", "time", "grasp", "apple"], "tl": ["finally", "(", "go_to(tree)", ")", "or", "finally", "(", "grasp(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "grasp", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(F prop_1), where prop_1 represents \"go to tree\". The phrase \"at some time grasp apple\" corresponds to \"eventually prop_2\" (F prop_2), where prop_2 represents \"grasp apple\". The word \"or\" connects these two eventualities with a disjunction.\n\n2. *Explanation dictionary* \u2013 {\"at some time go to tree\": \"F prop_1\", \"at some time grasp apple\": \"F prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 1713, "sentence": ["never", "drop", "apple", "or", "at", "any", "time", "reach", "flag"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "or", "finally", "(", "reach(flag)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "any", "time", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) or (finally prop_2) FINISH"}
{"id": 3627, "sentence": ["when", "possible", "contact", "house", "or", "when", "possible", "pass", "by", "house"], "tl": ["finally", "(", "contact(house)", ")", "or", "finally", "(", "pass_by(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "pass", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F) operator. The actions \"contact house\" and \"pass by house\" are represented by propositions prop_1 and prop_2 respectively. The command says to eventually contact the house or eventually pass by the house, so we use \"finally prop_1 or finally prop_2\".\n\n2. *Explanation dictionary* \u2013 {\"when possible contact house\": \"F prop_1\", \"when possible pass by house\": \"F prop_2\"}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 6960, "sentence": ["at", "some", "time", "go", "near", "house", "or", "move", "to", "trashcan"], "tl": ["finally", "(", "go_near(house)", ")", "or", "move_to(trashcan)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 7050, "sentence": ["at", "some", "time", "make", "contact", "flag", "or", "venture", "to", "trash", "can"], "tl": ["finally", "(", "make_contact(flag)", ")", "or", "venture_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact", "action_ref": "make contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (F (prop_1 or prop_2)) FINISH"}
{"id": 7289, "sentence": ["at", "some", "time", "move", "past", "trash", "can", "and", "at", "any", "time", "procure", "pear"], "tl": ["finally", "(", "move_past(trash_can)", ")", "and", "finally", "(", "procure(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "any", "time", "procure", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_past", "action_ref": "move past", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(finally) the proposition representing \"move past trash can\" (prop_1) will be true, so we use F prop_1. The phrase \"at any time procure pear\" means that globally (always) the proposition representing \"procure pear\" (prop_2) holds, so we use G prop_2. The entire command is a conjunction of these two requirements.\n\n2. *Explanation dictionary* \u2013 {\"at some time move past trash can\": \"F prop_1\", \"at any time procure pear\": \"G prop_2\"}\n\n3. *FINAL:* (F prop_1) and (G prop_2)"}
{"id": 4923, "sentence": ["drop", "orange", "or", "when", "possible", "collect", "apple"], "tl": ["drop(orange)", "or", "finally", "(", "collect(apple)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "collect", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_2), then eventually the apple will be collected (prop_2). The phrase \"drop orange or ...\" indicates a choice between dropping an orange (prop_1) or the action described next. So the overall formula expresses that either the orange is dropped now or eventually the apple is collected when possible.\n\n2. *Explanation dictionary* \u2013 {\"drop orange\": \"prop_1\", \"possible collect apple\": \"F prop_2\"}\n\n3. *FINAL:* (prop_1 or F prop_2)"}
{"id": 2894, "sentence": ["acquire", "orange", "or", "never", "drop", "apple"], "tl": ["acquire(orange)", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 or globally (not prop_2)) FINISH"}
{"id": 1873, "sentence": ["snatch", "up", "pear", "and", "when", "possible", "move", "near", "tree"], "tl": ["snatch_up(pear)", "and", "finally", "(", "move_near(tree)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "move", "near", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch_up", "action_ref": "snatch up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "move_near", "action_ref": "move near", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (prop_1 and finally prop_2) FINISH"}
{"id": 3481, "sentence": ["when", "secure", "apple", ",", "go", "by", "waste", "bin"], "tl": ["secure(apple)", "imply", "go_by(waste_bin)"], "masked_tl": ["prop_1", "imply", "prop_2"], "grounded_sentence": ["when", "prop_1", ",", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "(prop_1 implies F prop_2)"}
{"id": 4698, "sentence": ["at", "some", "time", "visit", "waste", "basket", "until", "at", "any", "time", "venture", "to", "flag"], "tl": ["finally", "(", "visit(waste_basket)", ")", "until", "finally", "(", "venture_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "at", "any", "time", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 until prop_2) FINISH"}
{"id": 2263, "sentence": ["go", "visit", "flag", "and", "when", "possible", "go", "home"], "tl": ["go_visit(flag)", "and", "finally", "(", "go(home)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "go", "home", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "3. *FINAL:* (F prop_1) and (G (prop_2 implies F prop_3)) FINISH"}
{"id": 6535, "sentence": ["when", "possible", "touch", "tree", "or", "never", "drop", "apple"], "tl": ["finally", "(", "touch(tree)", ")", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (F prop_1) implies (F prop_1) and (not (F prop_1)) implies (G (not prop_2)) FINISH"}
{"id": 6595, "sentence": ["go", "to", "bucket", "and", "when", "possible", "obtain", "orange"], "tl": ["go_to(bucket)", "and", "finally", "(", "obtain(orange)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "obtain", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(finally) the orange should be obtained (prop_2), but only after going to the bucket. So, after prop_1 becomes true, eventually prop_2 should become true. This can be expressed as: prop_1 holds until prop_2 happens, and eventually prop_2 happens after prop_1.\n\n2. *Explanation dictionary* \u2013 {\"go to bucket\": \"prop_1\", \"when possible obtain orange\": \"F prop_2\"}\n\n3. *FINAL:* (not prop_2)"}
{"id": 167, "sentence": ["put", "in", "bin", "until", "whenever", "scoop", "up", "pear"], "tl": ["put_in(bin)", "until", "finally", "(", "scoop_up(pear)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "whenever", "scoop", "up", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}, "prop_2": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "1. *Explanation* \u2013 The phrase \"whenever scoop up pear\" indicates a condition that triggers the requirement, so it maps to an implication with \"scoop up pear\" as the antecedent. The phrase \"put in bin until\" indicates that \"put in bin\" must hold continuously until some condition, which here is the occurrence of \"scoop up pear\". However, since \"until\" is used in the command as \"put in bin until whenever scoop up pear,\" it suggests that \"put in bin\" should hold until the event \"scoop up pear\" happens, and this should happen whenever \"scoop up pear\" occurs. To capture this, we interpret it as: whenever \"scoop up pear\" happens, \"put in bin\" holds until that event. But since \"scoop up pear\" is the triggering event, the formula is: globally, if \"scoop up pear\" happens, then \"put in bin\" holds until that event. Because \"scoop up pear\" is the event, the until operator is used with the same event as the right operand, which is a tautology. To make sense, we interpret the command as: whenever \"scoop up pear\" happens, \"put in bin\" holds until the"}
{"id": 4769, "sentence": ["at", "any", "time", "snatch", "pear", "and", "at", "some", "time", "pass", "by", "house"], "tl": ["finally", "(", "snatch(pear)", ")", "and", "finally", "(", "pass_by(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "pass", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch", "action_ref": "snatch", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(always) the proposition representing \"snatch pear\" (prop_1) holds. The phrase \"at some time pass by house\" means that eventually (finally) the proposition representing \"pass by house\" (prop_2) holds. The conjunction \"and\" connects these two temporal requirements.\n\n2. *Explanation dictionary* \u2013 {\"at any time snatch pear\": \"G prop_1\", \"at some time pass by house\": \"F prop_2\"}\n\n3. *FINAL:* (G prop_1) and (F prop_2)"}
{"id": 2378, "sentence": ["drop", "orange", "or", "when", "possible", "go", "to", "trash", "bin"], "tl": ["drop(orange)", "or", "finally", "(", "go_to(trash_bin)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 7440, "sentence": ["move", "towards", "trash", "can", "or", "approach", "tree"], "tl": ["move_towards(trash_can)", "or", "approach(tree)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "approach", "tree", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_towards", "action_ref": "move towards", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 4225, "sentence": ["hold", "apple", "and", "repeatedly", "go", "to", "pear"], "tl": ["hold(apple)", "and", "globally", "(", "finally", "(", "go_to(pear)", ")", ")"], "masked_tl": ["prop_1", "and", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "repeatedly", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (globally prop_1) and (globally finally prop_2) FINISH"}
{"id": 1529, "sentence": ["when", "possible", "take", "possession", "of", "bear", "or", "when", "possible", "go", "home"], "tl": ["finally", "(", "take_possession_of(bear)", ")", "or", "finally", "(", "go(home)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "go", "home", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}, "prop_2": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "(finally) either \"take possession of bear\" (prop_1) or \"go home\" (prop_2) should happen.\n\n2. *Explanation dictionary* \u2013 {\"when possible\": \"F\", \"take possession of bear\": \"prop_1\", \"go home\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 5085, "sentence": ["at", "some", "time", "migrate", "to", "tree", "until", "travel", "to", "apple"], "tl": ["finally", "(", "migrate_to(tree)", ")", "until", "travel_to(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "migrate_to", "action_ref": "migrate to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(F). The action \"migrate to tree\" is represented by prop_1, and \"travel to apple\" by prop_2. The phrase \"migrate to tree until travel to apple\" translates to \"prop_1 until prop_2\". Since the command says \"at some time migrate to tree until travel to apple,\" it means that eventually, the condition \"migrate to tree until travel to apple\" holds.\n\n2. *Explanation dictionary* \u2013 {\"at some time\": \"F\", \"migrate to tree\": \"prop_1\", \"travel to apple\": \"prop_2\", \"migrate to tree until travel to apple\": \"prop_1 U prop_2\"}\n\n3. *FINAL:* F (prop_1 U prop_2)"}
{"id": 3188, "sentence": ["visit", "tree", "or", "whenever", "touch", "house"], "tl": ["visit(tree)", "or", "finally", "(", "touch(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "touch", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"visit tree or whenever touch house\": \"(F prop_1) or (G (prop_2 implies F prop_1))\""}
{"id": 1591, "sentence": ["travel", "to", "apple", "and", "when", "possible", "visit", "trash", "bin"], "tl": ["travel_to(apple)", "and", "finally", "(", "visit(trash_bin)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "visit", "trash", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "3. *FINAL:* (prop_1) and (F prop_2) FINISH"}
{"id": 5488, "sentence": ["when", "possible", "make", "contact", "with", "house", "or", "never", "let", "go", "orange"], "tl": ["finally", "(", "make_contact_with(house)", ")", "or", "globally", "(", "negation", "(", "let_go(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "never", "let", "go", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (F (prop_1 or prop_2)) implies (F (prop_1 or prop_2)) and G (not prop_2) FINISH"}
{"id": 335, "sentence": ["take", "pear", "and", "whenever", "grab", "apple"], "tl": ["take(pear)", "and", "finally", "(", "grab(apple)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "grab", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take", "action_ref": "take", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* prop_1 and G (prop_2 implies prop_1) FINISH"}
{"id": 6869, "sentence": ["whenever", "visit", "trash", "bin", "and", "move", "to", "trashcan"], "tl": ["finally", "(", "visit(trash_bin)", ")", "and", "move_to(trashcan)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "3. *FINAL:* globally (prop_1 and prop_2) FINISH"}
{"id": 3376, "sentence": ["at", "some", "time", "withhold", "apple", "and", "secure", "apple"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "secure(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "secure", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 and prop_2)) FINISH"}
{"id": 5586, "sentence": ["don't", "let", "go", "pear", "or", "when", "possible", "snag", "orange"], "tl": ["negation", "(", "let_go(pear)", ")", "or", "finally", "(", "snag(orange)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["don't", "prop_1", "or", "when", "possible", "snag", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"don't let go pear or when possible snag orange\": \"globally (not prop_1) or globally (prop_2 implies finally prop_3)\""}
{"id": 5396, "sentence": ["at", "some", "time", "make", "contact", "flag", "and", "at", "any", "time", "seize", "pear"], "tl": ["finally", "(", "make_contact(flag)", ")", "and", "finally", "(", "seize(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "any", "time", "seize", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact", "action_ref": "make contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(finally) the proposition prop_1 (representing \"make contact flag\") will be true, so we use F prop_1. The phrase \"at any time seize pear\" means that globally (always) the proposition prop_2 (representing \"seize pear\") holds, so we use G prop_2. The entire command requires both conditions to hold, so we combine them with and.\n\n2. *Explanation dictionary* \u2013 {\"at some time make contact flag\": \"F prop_1\", \"at any time seize pear\": \"G prop_2\"}\n\n3. *FINAL:* (F prop_1) and (G prop_2)"}
{"id": 3187, "sentence": ["whenever", "travel", "to", "trash", "can", "can", "infer", "that", "whenever", "approach", "house"], "tl": ["finally", "(", "travel_to(trash_can)", ")", "imply", "finally", "(", "approach(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "can", "can", "infer", "that", "whenever", "approach", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(travel to trash can) holds, something follows. The phrase \"can infer that whenever approach house\" means that whenever prop_2 (approach house) holds, the previous condition holds. So the formula states: globally, if prop_2 holds, then globally, if prop_1 holds.\n\n2. *Explanation dictionary* \u2013\n{\n  \"whenever travel to trash can\": \"G (prop_1 \u2192 ...)\",\n  \"whenever approach house\": \"G (prop_2 \u2192 ...)\",\n  \"can infer that\": \"implies\"\n}\n\n3. *FINAL:* G (prop_2 \u2192 G (prop_1))"}
{"id": 2058, "sentence": ["going", "to", "tree", "or", "at", "some", "time", "go", "near", "pear"], "tl": ["going_to(tree)", "or", "finally", "(", "go_near(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "go", "near", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 2505, "sentence": ["venture", "towards", "house", "and", "go", "by", "waste", "bin"], "tl": ["venture_towards(house)", "and", "go_by(waste_bin)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "3. *FINAL:* (finally(prop_1) and finally(prop_2)) FINISH"}
{"id": 5018, "sentence": ["at", "some", "time", "move", "past", "trash", "can", "or", "repeatedly", "go", "to", "pear"], "tl": ["finally", "(", "move_past(trash_can)", ")", "or", "globally", "(", "finally", "(", "go_to(pear)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "repeatedly", "go", "to", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_past", "action_ref": "move past", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (globally finally prop_2) FINISH"}
{"id": 1645, "sentence": ["if", "whenever", "go", "home", ",", "at", "some", "time", "travel", "by", "tree"], "tl": ["finally", "(", "go(home)", ")", "imply", "finally", "(", "travel_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "whenever", "prop_1", ",", "at", "some", "time", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "travel_by", "action_ref": "travel by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 1762, "sentence": ["hold", "apple", "or", "hold", "orange"], "tl": ["hold(apple)", "or", "hold(orange)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "hold", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 or prop_2) FINISH"}
{"id": 1758, "sentence": ["at", "any", "time", "secure", "pear", "or", "whenever", "set", "out", "to", "house"], "tl": ["finally", "(", "secure(pear)", ")", "or", "finally", "(", "set_out_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "whenever", "set", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "set_out_to", "action_ref": "set out to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 1383, "sentence": ["whenever", "go", "by", "waste", "basket", "or", "at", "some", "time", "venture", "to", "house"], "tl": ["finally", "(", "go_by(waste_basket)", ")", "or", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "some", "time", "venture", "to", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(go by waste basket) holds, then something follows.\n- \"or at some time venture to house\" means either the previous condition or eventually prop_2 (venture to house).\n- So the entire formula states: globally, if prop_1 holds, or eventually prop_2 holds.\n\n2. *Explanation dictionary* \u2013\n{\n  \"go by waste basket\": \"prop_1\",\n  \"venture to house\": \"prop_2\",\n  \"whenever go by waste basket\": \"G (prop_1 \u2192 ...)\",\n  \"at some time venture to house\": \"F prop_2\",\n  \"whenever go by waste basket or at some time venture to house\": \"G (prop_1) or F prop_2\"\n}\n\n3. *FINAL:* (G prop_1) or (F prop_2)"}
{"id": 1701, "sentence": ["move", "towards", "trash", "can", "or", "whenever", "go", "home"], "tl": ["move_towards(trash_can)", "or", "finally", "(", "go(home)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "go", "home", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_towards", "action_ref": "move towards", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "3. *FINAL:* (prop_1 or globally (prop_2 implies prop_1)) FINISH"}
{"id": 6789, "sentence": ["at", "some", "time", "travel", "to", "trash", "can", "and", "at", "any", "time", "go", "near", "flag"], "tl": ["finally", "(", "travel_to(trash_can)", ")", "and", "finally", "(", "go_near(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "any", "time", "go", "near", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(finally) the proposition prop_1 (travel to trash can) will be true, so we use F prop_1. The phrase \"at any time go near flag\" means that always (globally) the proposition prop_2 (go near flag) holds, so we use G prop_2. The entire command is a conjunction of these two requirements.\n\n2. *Explanation dictionary* \u2013 {\"at some time travel to trash can\": \"F prop_1\", \"at any time go near flag\": \"G prop_2\"}\n\n3. *FINAL:* (F prop_1) and (G prop_2)"}
{"id": 4240, "sentence": ["approach", "trash", "can", "and", "whenever", "get", "to", "flag"], "tl": ["approach(trash_can)", "and", "finally", "(", "get_to(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "get", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"whenever get to flag\": \"globally (prop_2 implies finally prop_1)\","}
{"id": 5862, "sentence": ["when", "possible", "get", "close", "flag", "and", "go", "visit", "flag"], "tl": ["finally", "(", "get_close(flag)", ")", "and", "go_visit(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "go", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(i.e., it can eventually happen), then eventually both actions should happen in order: first get close the flag, then go visit the flag. This can be expressed as: if eventually prop_1 is possible, then eventually prop_1 happens and then eventually prop_2 happens after prop_1.\n\n2. *Explanation dictionary* \u2013\n{\n  \"possible get close flag\": \"F prop_1\",\n  \"get close flag\": \"prop_1\",\n  \"go visit flag\": \"prop_2\",\n  \"when possible get close flag and go visit flag\": \"F prop_1 implies (F prop_1 and F prop_2)\"\n}\n\n3. *FINAL:* (F prop_1)"}
{"id": 559, "sentence": ["never", "drop", "orange", "until", "put", "in", "bin"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "until", "put_in(bin)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "until", "prop_2"], "grounded_sentence": ["never", "prop_1", "until", "put", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}}, "prediction": "3. *FINAL:* (not prop_1) until prop_2 FINISH"}
{"id": 1216, "sentence": ["at", "any", "time", "be", "near", "tree", "or", "whenever", "going", "to", "house"], "tl": ["finally", "(", "be_near(tree)", ")", "or", "finally", "(", "going_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "whenever", "going", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 2050, "sentence": ["whenever", "secure", "pear", "and", "when", "possible", "scoop", "up", "pear"], "tl": ["finally", "(", "secure(pear)", ")", "and", "finally", "(", "scoop_up(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "when", "possible", "scoop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies (prop_2 implies finally prop_2)) FINISH"}
{"id": 6976, "sentence": ["at", "some", "time", "journey", "by", "flag", "until", "grab", "hold", "pear"], "tl": ["finally", "(", "journey_by(flag)", ")", "until", "grab_hold(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "grab", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "grab_hold", "action_ref": "grab hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(finally). The action \"journey by flag\" is represented by a proposition, say prop_1. The phrase \"until grab hold pear\" indicates that prop_1 holds until another proposition, say prop_2, becomes true. So, the formula is \"finally (prop_1 until prop_2)\".\n\n2. *Explanation dictionary* \u2013 {\"at some time\": \"F\", \"journey by flag\": \"prop_1\", \"until grab hold pear\": \"prop_1 U prop_2\"}\n\n3. *FINAL:* F (prop_1 U prop_2)"}
{"id": 2388, "sentence": ["whenever", "travel", "to", "house", "or", "at", "some", "time", "go", "by", "tree"], "tl": ["finally", "(", "travel_to(house)", ")", "or", "finally", "(", "go_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "some", "time", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 6457, "sentence": ["at", "some", "time", "reach", "flag", "means", "that", "at", "some", "time", "venture", "to", "house"], "tl": ["finally", "(", "reach(flag)", ")", "imply", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "means", "that", "at", "some", "time", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F prop_1), meaning that at some point in the future, prop_1 (reaching the flag) will be true. The phrase \"at some time venture to house\" corresponds to \"eventually prop_2\" (F prop_2), meaning that at some point in the future, prop_2 (venturing to the house) will be true. The word \"means\" indicates logical implication, so the entire sentence means \"if eventually prop_1 then eventually prop_2\", or (F prop_1) implies (F prop_2).\n\n2. *Explanation dictionary* \u2013\n{\n  \"at some time reach flag\": \"F prop_1\",\n  \"at some time venture to house\": \"F prop_2\",\n  \"means\": \"implies\"\n}\n\n3. *FINAL:* (F prop_1) implies (F prop_2)"}
{"id": 6361, "sentence": ["at", "some", "time", "make", "to", "flag", "until", "forever", "have", "in", "orange"], "tl": ["finally", "(", "make_to(flag)", ")", "until", "globally", "(", "have_in(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "globally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "forever", "have", "in", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_to", "action_ref": "make to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(F), indicating that something will eventually happen. The phrase \"make to flag\" is interpreted as achieving or setting \"prop_1\" (flag). The phrase \"until forever have in orange\" means that \"prop_2\" (orange) holds globally (forever). So the formula states: eventually prop_1 holds, and prop_2 holds globally.\n\n2. *Explanation dictionary* \u2013\n{\n  \"at some time\": \"F\",\n  \"make to flag\": \"prop_1\",\n  \"until forever have in orange\": \"G prop_2\"\n}\n\n3. *FINAL:* (F prop_1) and (G prop_2)"}
{"id": 5064, "sentence": ["repeatedly", "grab", "tree", "or", "forever", "hold", "on", "pear"], "tl": ["globally", "(", "finally", "(", "grab(tree)", ")", ")", "or", "globally", "(", "hold_on(pear)", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "forever", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "hold_on", "action_ref": "hold on", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (globally (finally prop_1)) or (globally prop_2) FINISH"}
{"id": 410, "sentence": ["hold", "orange", "or", "at", "some", "time", "go", "to", "trash", "can"], "tl": ["hold(orange)", "or", "finally", "(", "go_to(trash_can)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(F) operator over the disjunction.\n\n2. *Explanation dictionary* \u2013 {\"hold orange\": \"prop_1\", \"go to trash can\": \"prop_2\", \"or\": \"or\", \"at some time\": \"finally\"}\n\n3. *FINAL:* F (prop_1 or prop_2)"}
{"id": 2642, "sentence": ["at", "some", "time", "bring", "pear", "until", "when", "possible", "reach", "flag"], "tl": ["finally", "(", "bring(pear)", ")", "until", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "when", "possible", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(F), indicating that something will happen eventually. \"bring pear\" is represented by prop_1. The phrase \"until when possible reach flag\" means that \"bring pear\" should hold until \"possible reach flag\" becomes true. \"possible reach flag\" is represented by prop_2. So, the formula is: prop_1 holds until prop_2 becomes true, and this should happen eventually.\n\n2. *Explanation dictionary* \u2013 {\"at some time\": \"F\", \"bring pear\": \"prop_1\", \"possible reach flag\": \"prop_2\", \"bring pear until possible reach flag\": \"prop_1 U prop_2\"}\n\n3. *FINAL:* F (prop_1 U prop_2)"}
{"id": 3419, "sentence": ["when", "possible", "make", "your", "way", "flag", "or", "always", "have", "apple"], "tl": ["finally", "(", "make_your_way(flag)", ")", "or", "globally", "(", "have(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "always", "have", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"when possible\": \"finally prop_1 or globally prop_2\""}
{"id": 5250, "sentence": ["acquire", "orange", "or", "whenever", "make", "your", "way", "flag"], "tl": ["acquire(orange)", "or", "finally", "(", "make_your_way(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "make", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* G (prop_1 implies F (prop_2)) or G (prop_1 implies F (prop_3)) FINISH"}
{"id": 6740, "sentence": ["at", "some", "time", "travel", "house", "or", "never", "drop", "orange"], "tl": ["finally", "(", "travel(house)", ")", "or", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel", "action_ref": "travel", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* F (prop_1 or G (not prop_2)) FINISH"}
{"id": 2017, "sentence": ["move", "to", "house", "or", "when", "possible", "get", "to", "cup"], "tl": ["move_to(house)", "or", "finally", "(", "get_to(cup)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "get", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["cup)"], "args_ref": ["cup)"]}}, "prediction": "(prop_1), or if not immediately possible, eventually get to the cup (prop_2). The word \"or\" indicates a disjunction between these two eventualities. \"When possible\" suggests that getting to the cup is an alternative eventual goal. So the formula expresses that either eventually prop_1 holds, or eventually prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"move to house\": \"F prop_1\", \"get to cup\": \"F prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 1300, "sentence": ["at", "any", "time", "scoop", "up", "apple", "and", "capture", "orange"], "tl": ["finally", "(", "scoop_up(apple)", ")", "and", "capture(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "capture", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* globally (prop_1 and prop_2) FINISH"}
{"id": 3815, "sentence": ["at", "any", "time", "get", "to", "cup", "or", "at", "any", "time", "grasp", "pear"], "tl": ["finally", "(", "get_to(cup)", ")", "or", "finally", "(", "grasp(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "any", "time", "grasp", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["cup)"], "args_ref": ["cup)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(finally) the proposition representing \"get to cup\" (prop_1) will be true. Similarly, \"at any time grasp pear\" means eventually (finally) the proposition representing \"grasp pear\" (prop_2) will be true. The \"or\" connects these two eventualities, so the overall formula states that eventually either prop_1 or prop_2 will be true.\n\n2. *Explanation dictionary* \u2013 {\"at any time get to cup\": \"F prop_1\", \"at any time grasp pear\": \"F prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 954, "sentence": ["venture", "towards", "house", "or", "when", "possible", "bring", "pear"], "tl": ["venture_towards(house)", "or", "finally", "(", "bring(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "bring", "pear", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 4757, "sentence": ["whenever", "venture", "to", "house", "and", "at", "some", "time", "go", "by", "waste", "basket"], "tl": ["finally", "(", "venture_to(house)", ")", "and", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "some", "time", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(venture to house) holds, something else must eventually happen. The phrase \"at some time go by waste basket\" means that eventually prop_2 (go by waste basket) must occur. Combining these, we get: globally, if prop_1 holds, then eventually prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"whenever venture to house\": \"prop_1\", \"at some time go by waste basket\": \"F prop_2\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 3152, "sentence": ["always", "touch", "flag", "or", "when", "possible", "approach", "house"], "tl": ["globally", "(", "touch(flag)", ")", "or", "finally", "(", "approach(house)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "or", "when", "possible", "approach", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"always touch flag or when possible approach house\": \"globally (prop_1 or (prop_2 implies finally prop_3))\""}
{"id": 6491, "sentence": ["always", "moving", "until", "take", "to", "trashcan"], "tl": ["globally", "(", "moving", ")", "until", "take_to(trashcan)"], "masked_tl": ["globally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["always", "prop_1", "until", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "moving", "action_ref": "moving", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "(G prop_1)"}
{"id": 196, "sentence": ["whenever", "travel", "to", "house", "means", "that", "when", "possible", "move", "forward", "trash", "can"], "tl": ["finally", "(", "travel_to(house)", ")", "imply", "finally", "(", "move_forward(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "means", "that", "when", "possible", "move", "forward", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_forward", "action_ref": "move forward", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies (prop_2 implies finally prop_3)) FINISH"}
{"id": 3118, "sentence": ["repeatedly", "go", "to", "waste", "basket", "or", "whenever", "venture", "house"], "tl": ["globally", "(", "finally", "(", "go_to(waste_basket)", ")", ")", "or", "finally", "(", "venture(house)", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "whenever", "venture", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 3870, "sentence": ["capture", "orange", "and", "at", "some", "time", "go", "by", "house"], "tl": ["capture(orange)", "and", "finally", "(", "go_by(house)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_1 and finally prop_2) FINISH"}
{"id": 6876, "sentence": ["walk", "and", "put", "in", "bin"], "tl": ["walk", "and", "put_in(bin)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "prop_2"], "lifted_sentence_prop_ids": [1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk", "action_ref": "walk", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}}, "prediction": "(F) to indicate eventual occurrence, the formula states that eventually prop_1 happens and eventually prop_2 happens.\n\n2. *Explanation dictionary* \u2013 {\"walk\": \"F prop_1\", \"put in bin\": \"F prop_2\", \"and\": \"and\"}\n\n3. *FINAL:* (F prop_1) and (F prop_2)"}
{"id": 275, "sentence": ["at", "any", "time", "start", "going", "to", "tree", "or", "whenever", "acquire", "pear"], "tl": ["finally", "(", "start_going_to(tree)", ")", "or", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "whenever", "acquire", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(always) it is true that \"start going to tree\" holds. We represent \"start going to tree\" as prop_1. The phrase \"or whenever acquire pear\" means that whenever \"acquire pear\" (prop_2) holds, the formula should also hold. Since \"whenever\" implies an implication from \"acquire pear\" to the rest, we combine these with an or. So the formula is: globally prop_1 or (prop_2 implies something). But since the command is \"at any time start going to tree or whenever acquire pear\", it can be interpreted as \"always start going to tree or whenever acquire pear\", so the formula is: G (prop_1) or G (prop_2). However, \"whenever\" is usually interpreted as \"if prop_2 then ...\", so the formula is G (prop_1) or (G (prop_2) or (prop_2 implies ...)). Since the command is ambiguous, the simplest interpretation is: globally (start going to tree) or globally (acquire pear). So the formula is: (globally prop_1)"}
{"id": 5248, "sentence": ["drop", "pear", "until", "at", "some", "time", "go", "to", "transh", "can"], "tl": ["drop(pear)", "until", "finally", "(", "go_to(transh_can)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["transh_can)"], "args_ref": ["transh can)"]}}, "prediction": "3. *FINAL:* (prop_1 until prop_2) FINISH"}
{"id": 5030, "sentence": ["at", "some", "time", "contact", "flag", "or", "at", "some", "time", "go", "past", "flag"], "tl": ["finally", "(", "contact(flag)", ")", "or", "finally", "(", "go_past(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_past", "action_ref": "go past", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 3133, "sentence": ["do", "not", "let", "go", "pear", "or", "at", "some", "time", "spend", "time", "at", "tree"], "tl": ["negation", "(", "let_go(pear)", ")", "or", "finally", "(", "spend_time_at(tree)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["do", "not", "prop_1", "or", "at", "some", "time", "spend", "time", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) or (finally prop_2) FINISH"}
{"id": 6408, "sentence": ["whenever", "journey", "to", "house", "or", "whenever", "travel", "to", "flag"], "tl": ["finally", "(", "journey_to(house)", ")", "or", "finally", "(", "travel_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(G) the implication that if either prop_1 or prop_2 holds, then something follows. Since no consequent is given, we can represent the formula as globally (prop_1 or prop_2) to capture the occurrence of these events whenever they happen.\n\n2. *Explanation dictionary* \u2013\n{\n  \"journey to house\": \"prop_1\",\n  \"travel to flag\": \"prop_2\",\n  \"whenever journey to house or whenever travel to flag\": \"G (prop_1 or prop_2)\"\n}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 1333, "sentence": ["get", "hold", "of", "pear", "and", "hold", "pear"], "tl": ["get_hold_of(pear)", "and", "hold(pear)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "hold", "pear", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold_of", "action_ref": "get hold of", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "{\"get hold of pear\" : \"finally(prop_1)\", \"and\" : \"and\", \"hold pear\" : \"globally(prop_2)\"}"}
{"id": 5607, "sentence": ["put", "in", "bin", "or", "at", "some", "time", "journey", "to", "house"], "tl": ["put_in(bin)", "or", "finally", "(", "journey_to(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "journey", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}, "prop_2": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 4827, "sentence": ["at", "any", "time", "clutch", "orange", "or", "repeatedly", "grab", "tree"], "tl": ["finally", "(", "clutch(orange)", ")", "or", "globally", "(", "finally", "(", "grab(tree)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "repeatedly", "grab", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "clutch", "action_ref": "clutch", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(G), meaning the property holds always. The phrase \"clutch orange or repeatedly grab tree\" is a disjunction of two conditions. \"clutch orange\" is represented by prop_1, and \"grab tree\" by prop_2. \"repeatedly grab tree\" means that \"grab tree\" happens infinitely often, which can be expressed as \"globally finally prop_2\" (G F prop_2). So the entire formula is: globally (prop_1 or globally finally prop_2).\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time\": \"G\",\n  \"clutch orange\": \"prop_1\",\n  \"grab tree\": \"prop_2\",\n  \"repeatedly grab tree\": \"G F prop_2\",\n  \"clutch orange or repeatedly grab tree\": \"(prop_1 or G F prop_2)\"\n}\n\n3. *FINAL:* G (prop_1 or G F prop_2)"}
{"id": 5715, "sentence": ["whenever", "track", "towards", "tree", "and", "at", "some", "time", "get", "near", "flag"], "tl": ["finally", "(", "track_towards(tree)", ")", "and", "finally", "(", "get_near(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "some", "time", "get", "near", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "track_towards", "action_ref": "track towards", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "get_near", "action_ref": "get near", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(track towards tree) holds, something must follow. The phrase \"at some time get near flag\" means that eventually prop_2 (get near flag) must hold. Combining these, the formula states that globally, if prop_1 is true, then eventually prop_2 will be true.\n\n2. *Explanation dictionary* \u2013 {\"whenever track towards tree\": \"prop_1\", \"at some time get near flag\": \"F prop_2\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 1999, "sentence": ["secure", "apple", "or", "at", "some", "time", "withhold", "apple"], "tl": ["secure(apple)", "or", "finally", "(", "withhold(apple)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "withhold", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 1465, "sentence": ["at", "some", "time", "make", "contact", "with", "house", "and", "when", "possible", "obtain", "orange"], "tl": ["finally", "(", "make_contact_with(house)", ")", "and", "finally", "(", "obtain(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "when", "possible", "obtain", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (F prop_1) and (G (prop_2 implies prop_3)) FINISH"}
{"id": 1183, "sentence": ["whenever", "make", "contact", "with", "house", "or", "when", "possible", "procure", "pear"], "tl": ["finally", "(", "make_contact_with(house)", ")", "or", "finally", "(", "procure(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "procure", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 4713, "sentence": ["when", "forever", "go", "by", "trash", "can", ",", "whenever", "get", "hold", "apple"], "tl": ["globally", "(", "go_by(trash_can)", ")", "imply", "finally", "(", "get_hold(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "forever", "prop_1", ",", "whenever", "get", "hold", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(go by trash can) holds globally (always), so G prop_1. The phrase \"whenever get hold apple\" means that whenever prop_2 (get hold apple) occurs, something follows. Since the command is \"when forever go by trash can, whenever get hold apple,\" it implies that whenever prop_2 happens, it must be during the time that prop_1 is always true. So the entire formula states that if prop_1 is always true, then whenever prop_2 happens, it is under that condition. This can be expressed as G prop_1 implies G (prop_2 implies prop_1), but since prop_1 is globally true, the implication is trivial. Alternatively, the command can be interpreted as: \"If you always go by the trash can, then whenever you get hold of an apple, ...\" which suggests that whenever prop_2 happens, prop_1 is true at that time. So the formula is G (prop_2 implies prop_1)"}
{"id": 3479, "sentence": ["when", "possible", "obtain", "orange", "and", "take", "pear"], "tl": ["finally", "(", "obtain(orange)", ")", "and", "take(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (F prop_1) implies (F (prop_1 and prop_2)) FINISH"}
{"id": 6390, "sentence": ["pick", "up", "flag", "until", "at", "any", "time", "pick", "up", "apple"], "tl": ["pick_up(flag)", "until", "finally", "(", "pick_up(apple)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "any", "time", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(U). The phrase \"at any time\" means that eventually (finally, F) the \"pick up apple\" action will occur. So the formula states that \"pick up flag\" holds until \"pick up apple\" happens at some time in the future.\n\n2. *Explanation dictionary* \u2013 {\"pick up flag\": \"prop_1\", \"pick up apple\": \"prop_2\", \"until\": \"U\", \"at any time\": \"F\"}\n\n3. *FINAL:* (prop_1 U prop_2)"}
{"id": 1396, "sentence": ["always", "go", "by", "trash", "can", "or", "at", "any", "time", "go", "to", "peach"], "tl": ["globally", "(", "go_by(trash_can)", ")", "or", "finally", "(", "go_to(peach)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "or", "at", "any", "time", "go", "to", "peach", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["peach)"], "args_ref": ["peach)"]}}, "prediction": "(prop_1) or \"at any time go to peach\" (F prop_2). Since \"at any time\" means eventually, we use finally (F) for \"go to peach\". The entire formula states that globally, either prop_1 holds or eventually prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"always\": \"G\", \"go by trash can\": \"prop_1\", \"at any time go to peach\": \"F prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 909, "sentence": ["always", "hold", "onto", "orange", "until", "when", "possible", "get", "close", "tree"], "tl": ["globally", "(", "hold_onto(orange)", ")", "until", "finally", "(", "get_close(tree)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "until", "when", "possible", "get", "close", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(prop_1) should be true globally (G). The phrase \"until when possible get close tree\" means that this should hold until the proposition \"getting close to tree\" (prop_2) becomes true. So, the entire formula is \"prop_1 until prop_2\", and since \"hold onto orange\" should always hold until \"get close tree\" is possible, we use globally (G) to enforce that the until condition applies at all times.\n\n2. *Explanation dictionary* \u2013 {\"always hold onto orange\": \"G prop_1\", \"until when possible get close tree\": \"prop_1 U prop_2\"}\n\n3. *FINAL:* G (prop_1 U prop_2)"}
{"id": 4180, "sentence": ["whenever", "procure", "orange", "until", "when", "possible", "shift", "to", "flag"], "tl": ["finally", "(", "procure(orange)", ")", "until", "finally", "(", "shift_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "until", "when", "possible", "shift", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "shift_to", "action_ref": "shift to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* G (prop_1 implies (prop_1 U prop_2)) FINISH"}
{"id": 4284, "sentence": ["move", "to", "house", "until", "at", "some", "time", "travel", "to", "trash", "can"], "tl": ["move_to(house)", "until", "finally", "(", "travel_to(trash_can)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "some", "time", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(U). The phrase \"at some time\" implies that eventually (F) the \"travel to trash can\" action will occur. So, the formula states that \"move to house\" holds until eventually \"travel to trash can\" happens.\n\n2. *Explanation dictionary* \u2013 {\"move to house\": \"prop_1\", \"travel to trash can\": \"prop_2\", \"until\": \"U\", \"at some time\": \"F\"}\n\n3. *FINAL:* (prop_1 U F prop_2)"}
{"id": 7308, "sentence": ["whenever", "reach", "flag", "or", "go", "by", "waste", "bin"], "tl": ["finally", "(", "reach(flag)", ")", "or", "go_by(waste_bin)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "(G) condition. The condition \"reach flag or go by waste bin\" is a disjunction (or) of two propositions: \"reach flag\" and \"go by waste bin\". We assign prop_1 to \"reach flag\" and prop_2 to \"go by waste bin\". The entire formula states that globally, if either prop_1 or prop_2 holds, then some property should hold. Since the command does not specify what should happen after, we interpret it as the condition itself holding globally.\n\n2. *Explanation dictionary* \u2013 {\"whenever\": \"globally (G)\", \"reach flag\": \"prop_1\", \"go by waste bin\": \"prop_2\", \"reach flag or go by waste bin\": \"(prop_1 or prop_2)\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 2776, "sentence": ["never", "drop", "apple", "or", "whenever", "go", "by", "waste", "basket"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "  \"never drop apple\": \"globally (not prop_1)\","}
{"id": 4056, "sentence": ["whenever", "snatch", "pear", "or", "venture", "to", "trash", "can"], "tl": ["finally", "(", "snatch(pear)", ")", "or", "venture_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch", "action_ref": "snatch", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 6444, "sentence": ["acquire", "orange", "or", "when", "possible", "let", "go", "apple"], "tl": ["acquire(orange)", "or", "finally", "(", "let_go(apple)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "let", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 5599, "sentence": ["do", "not", "let", "go", "pear", "and", "don't", "let", "go", "pear"], "tl": ["negation", "(", "let_go(pear)", ")", "and", "negation", "(", "let_go(pear)", ")"], "masked_tl": ["negation", "(", "prop_2", ")", "and", "negation", "(", "prop_2", ")"], "grounded_sentence": ["do", "not", "prop_1", "and", "don't", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (not prop_1) and (not prop_1) FINISH"}
{"id": 6982, "sentence": ["at", "some", "time", "present", "at", "flag", "or", "never", "drop", "apple"], "tl": ["finally", "(", "present_at(flag)", ")", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (globally (not prop_2)) FINISH"}
{"id": 896, "sentence": ["at", "some", "time", "present", "at", "flag", "means", "that", "whenever", "venture", "to", "house"], "tl": ["finally", "(", "present_at(flag)", ")", "imply", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "means", "that", "whenever", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F prop_1), meaning that at some point in the future, prop_1 (being at flag) holds. The phrase \"whenever venture to house\" corresponds to \"globally (prop_2 implies ...)\" where prop_2 represents \"venture to house\". Since the command says \"at some time present at flag means that whenever venture to house\", it implies that if at some time we are at flag, then whenever we venture to house, some condition holds. However, the sentence is incomplete or ambiguous. Assuming the intended meaning is: \"At some time present at flag means that whenever we venture to house, then at that time we are at flag.\" This can be formalized as: \"If eventually prop_1, then globally (prop_2 implies prop_1)\".\n\n2. *Explanation dictionary* \u2013\n{\n  \"at some time present at flag\": \"F prop_1\",\n  \"whenever venture to house\": \"G (prop_2 implies ...)\",\n  \"means that\": \"implies\"\n}\n\n3. *FINAL:* (F prop_1)"}
{"id": 6665, "sentence": ["grasp", "orange", "until", "move", "to", "trash", "can"], "tl": ["grasp(orange)", "until", "move_to(trash_can)"], "masked_tl": ["prop_1", "until", "prop_2"], "grounded_sentence": ["prop_1", "until", "move", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(U). So the formula states that \"grasp orange\" holds continuously until \"move to trash can\" becomes true.\n\n2. *Explanation dictionary* \u2013 {\"grasp orange\": \"prop_1\", \"move to trash can\": \"prop_2\", \"until\": \"U\"}\n\n3. *FINAL:* (prop_1 U prop_2)"}
{"id": 6325, "sentence": ["going", "to", "tree", "and", "when", "possible", "stop", "by", "trash", "can"], "tl": ["going_to(tree)", "and", "finally", "(", "stop_by(trash_can)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "stop", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(finally) the system should stop by the trash can (prop_2) whenever it is possible. Since \"when possible\" implies that stopping by the trash can should happen eventually if conditions allow, we use the finally operator on prop_2. The conjunction \"and\" connects these two requirements.\n\n2. *Explanation dictionary* \u2013 {\"going to tree\": \"prop_1\", \"when possible stop by trash can\": \"F prop_2\"}\n\n3. *FINAL:* (prop_1 and F prop_2)"}
{"id": 2099, "sentence": ["when", "possible", "collect", "orange", "or", "when", "possible", "reach", "tree"], "tl": ["finally", "(", "collect(orange)", ")", "or", "finally", "(", "reach(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(F prop_1) or (F prop_2)\"\n}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 267, "sentence": ["venture", "towards", "house", "or", "when", "possible", "reach", "flag"], "tl": ["venture_towards(house)", "or", "finally", "(", "reach(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "reach", "flag", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 2784, "sentence": ["whenever", "be", "near", "tree", "or", "whenever", "withold", "apple"], "tl": ["finally", "(", "be_near(tree)", ")", "or", "finally", "(", "withold(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "withold", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "withold", "action_ref": "withold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (globally(prop_1) or globally(prop_"}
{"id": 3782, "sentence": ["seize", "apple", "or", "put", "in", "apple", "bucket"], "tl": ["seize(apple)", "or", "put_in(apple_bucket)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "put", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["apple_bucket)"], "args_ref": ["apple bucket)"]}}, "prediction": "(F) operator over the disjunction.\n\n2. *Explanation dictionary* \u2013 {\"seize apple\": \"prop_1\", \"put in apple bucket\": \"prop_2\", \"seize apple or put in apple bucket\": \"prop_1 or prop_2\", \"eventually (seize apple or put in apple bucket)\": \"F (prop_1 or prop_2)\"}\n\n3. *FINAL:* F (prop_1 or prop_2)"}
{"id": 4142, "sentence": ["take", "to", "trashcan", "or", "take", "to", "trashcan"], "tl": ["take_to(trashcan)", "or", "take_to(trashcan)"], "masked_tl": ["prop_2", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "take", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "3. *FINAL:* (prop_1 or prop_1) FINISH"}
{"id": 364, "sentence": ["at", "any", "time", "track", "towards", "tree", "and", "whenever", "stop", "by", "house"], "tl": ["finally", "(", "track_towards(tree)", ")", "and", "finally", "(", "stop_by(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "whenever", "stop", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "track_towards", "action_ref": "track towards", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (globally prop_1) and (globally (prop_2 implies true)) FINISH"}
{"id": 2589, "sentence": ["whenever", "procure", "pear", "and", "when", "possible", "pick", "up", "apple"], "tl": ["finally", "(", "procure(pear)", ")", "and", "finally", "(", "pick_up(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "when", "possible", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1 \u2192 ...)\",\n  \"procure pear\": \"prop_1\",\n  \"when possible pick up apple\": \"F prop_2\",\n  \"pick up apple\": \"prop_2\"\n}\n\n3. *FINAL:* G (prop_1 \u2192 F prop_2)"}
{"id": 5690, "sentence": ["when", "possible", "venture", "to", "house", "or", "at", "some", "time", "venture", "to", "house"], "tl": ["finally", "(", "venture_to(house)", ")", "or", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["finally", "(", "prop_2", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "some", "time", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_2 implies (prop_1 or F prop_1)) FINISH"}
{"id": 6689, "sentence": ["when", "going", "to", "tree", ",", "whenever", "travel", "to", "trash", "can"], "tl": ["going_to(tree)", "imply", "finally", "(", "travel_to(trash_can)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "prop_1", ",", "whenever", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(going to tree) is true, then \"whenever travel to trash can\" means that whenever prop_2 (travel to trash can) occurs, some property should hold. Since the command is a bit ambiguous, the natural interpretation is: whenever prop_1 happens, then globally, whenever prop_2 happens, some condition holds. Without further specification, the safest is to express that whenever prop_1 happens, then globally, whenever prop_2 happens, prop_2 is true (which is tautological). More likely, the command means: whenever going to tree, then whenever travel to trash can happens, some action or condition is triggered. Since no further condition is given, the formula can be: globally, if prop_1 holds, then globally, whenever prop_2 holds, prop_2 holds (which is trivial)"}
{"id": 6539, "sentence": ["grip", "apple", "or", "repeatedly", "go", "to", "apple", "trashcan"], "tl": ["grip(apple)", "or", "globally", "(", "finally", "(", "go_to(apple_trashcan)", ")", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "or", "repeatedly", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grip", "action_ref": "grip", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple_trashcan)"], "args_ref": ["apple trashcan)"]}}, "prediction": "3. *FINAL:* (prop_1 or (globally finally prop_2)) FINISH"}
{"id": 6314, "sentence": ["at", "any", "time", "migrate", "to", "tree", "or", "at", "some", "time", "go", "to", "transh", "can"], "tl": ["finally", "(", "migrate_to(tree)", ")", "or", "finally", "(", "go_to(transh_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "some", "time", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "migrate_to", "action_ref": "migrate to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["transh_can)"], "args_ref": ["transh can)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 6555, "sentence": ["do", "not", "let", "go", "pear", "or", "at", "some", "time", "clutch", "orange"], "tl": ["negation", "(", "let_go(pear)", ")", "or", "finally", "(", "clutch(orange)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["do", "not", "prop_1", "or", "at", "some", "time", "clutch", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "clutch", "action_ref": "clutch", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) or (finally prop_2) FINISH"}
{"id": 3578, "sentence": ["drop", "by", "and", "pick", "up", "orange"], "tl": ["drop_by", "and", "pick_up(orange)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "pick", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop_by", "action_ref": "drop by", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(drop orange), and after that, eventually prop_2 (pick up orange). Using temporal logic, this is: F prop_1 and (prop_1 implies F prop_2). To combine these, we can write: F prop_1 and F prop_2, but to capture the order, we use: F (prop_1 and F prop_2).\n\n2. *Explanation dictionary* \u2013\n{\n  \"drop orange\": \"prop_1\",\n  \"pick up orange\": \"prop_2\",\n  \"eventually drop orange\": \"F prop_1\",\n  \"eventually pick up orange after drop\": \"F (prop_1 and F prop_2)\"\n}\n\n3. *FINAL:* F (prop_1 and F prop_2)"}
{"id": 1247, "sentence": ["drop", "by", "and", "hold", "orange"], "tl": ["drop_by", "and", "hold(orange)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "hold", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop_by", "action_ref": "drop by", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"and\": \"and\","}
{"id": 1514, "sentence": ["if", "whenever", "go", "by", "house", ",", "at", "any", "time", "steal", "apple"], "tl": ["finally", "(", "go_by(house)", ")", "imply", "finally", "(", "steal(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "whenever", "prop_1", ",", "at", "any", "time", "steal", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "steal", "action_ref": "steal", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1) is true, then \"at any time steal apple\" means that eventually \"steal apple\" (prop_2) must happen. So, \"whenever go by house\" maps to globally (G) prop_1, and \"at any time steal apple\" maps to finally (F) prop_2. The entire sentence is an implication: globally (prop_1) implies finally (prop_2).\n\n2. *Explanation dictionary* \u2013 {\"whenever go by house\": \"G prop_1\", \"at any time steal apple\": \"F prop_2\", \"if ... then ...\": \"(G prop_1) implies (F prop_2)\"}\n\n3. *FINAL:* (G prop_1) implies (F prop_2)"}
{"id": 5043, "sentence": ["reach", "trash", "can", "or", "whenever", "journey", "by", "house"], "tl": ["reach(trash_can)", "or", "finally", "(", "journey_by(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "journey", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (F prop_1) or (G (prop_2 implies F prop_1)) FINISH"}
{"id": 2910, "sentence": ["whenever", "make", "to", "flag", "or", "grip", "apple"], "tl": ["finally", "(", "make_to(flag)", ")", "or", "grip(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "grip", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_to", "action_ref": "make to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "grip", "action_ref": "grip", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* G ((prop_1 or prop_2) implies true) FINISH"}
{"id": 1602, "sentence": ["grab", "hold", "pear", "and", "whenever", "track", "towards", "tree"], "tl": ["grab_hold(pear)", "and", "finally", "(", "track_towards(tree)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "track", "towards", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab_hold", "action_ref": "grab hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "track_towards", "action_ref": "track towards", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(prop_1) and globally(prop_2).\n\n- \"whenever track towards tree\": This means that whenever the system is tracking towards the tree, some condition holds. Since the command does not specify what should happen when tracking towards the tree, we interpret \"whenever track towards tree\" as \"globally, if tracking towards tree (prop_3), then something.\" Since no further condition is given, we can just represent it as globally(prop_3) or globally(implies(prop_3, prop_3)) which is tautological. To keep it meaningful, we just represent \"whenever track towards tree\" as globally(prop_3)"}
{"id": 3134, "sentence": ["when", "when", "possible", "make", "contact", "with", "house", ",", "gather", "orange"], "tl": ["finally", "(", "make_contact_with(house)", ")", "imply", "gather(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["when", "when", "possible", "prop_1", ",", "gather", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "gather", "action_ref": "gather", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(F prop_1). Similarly, \"gather orange\" should also happen eventually (F prop_2). Since the command is \"when possible make contact with house, gather orange,\" it implies both actions should eventually happen, so we combine them with \"and\" inside a globally operator to ensure these conditions hold throughout.\n\n2. *Explanation dictionary* \u2013\n{\n  \"make contact with house\": \"prop_1\",\n  \"gather orange\": \"prop_2\",\n  \"when possible\": \"F\",\n  \"when possible make contact with house\": \"F prop_1\",\n  \"gather orange\": \"F prop_2\"\n}\n\n3. *FINAL:* G (F prop_1 and F prop_2)"}
{"id": 5821, "sentence": ["when", "possible", "visit", "trash", "bin", "means", "that", "reach", "house"], "tl": ["finally", "(", "visit(trash_bin)", ")", "imply", "reach(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "means", "that", "reach", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(G) to say \"always, if prop_1 then eventually prop_2.\"\n\n2. *Explanation dictionary* \u2013 {\"visit trash bin\": \"prop_1\", \"reach house\": \"prop_2\", \"when possible\": \"G (prop_1 implies F prop_2)\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 7470, "sentence": ["approach", "trash", "can", "or", "whenever", "got", "to", "house"], "tl": ["approach(trash_can)", "or", "finally", "(", "got_to(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "got", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "got_to", "action_ref": "got to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(prop_2 implies ...)\", where prop_2 represents \"got to house\". The phrase \"approach trash can or\" indicates that upon this condition, either \"approach trash can\" (prop_1) or some other condition holds. Since the command is \"approach trash can or whenever got to house\", it suggests that either \"approach trash can\" holds now or whenever \"got to house\" holds, \"approach trash can\" should hold. To capture this, we can interpret the command as: \"Globally, if got to house, then eventually approach trash can.\" Alternatively, since \"or\" is present, it can be read as \"either approach trash can now, or whenever got to house, approach trash can.\" To keep it consistent, we use: \"Globally, (approach trash can) or (got to house implies finally approach trash can)"}
{"id": 6372, "sentence": ["move", "to", "tree", "or", "when", "possible", "set", "out", "to", "house"], "tl": ["move_to(tree)", "or", "finally", "(", "set_out_to(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "set", "out", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "set_out_to", "action_ref": "set out to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "   Combining these with \"or\" gives: (F prop_1) or (prop_2 implies F prop_2)."}
{"id": 1222, "sentence": ["gather", "apple", "means", "that", "at", "any", "time", "visit", "house"], "tl": ["gather(apple)", "imply", "finally", "(", "visit(house)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "means", "that", "at", "any", "time", "visit", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "gather", "action_ref": "gather", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies prop_2) FINISH"}
{"id": 4035, "sentence": ["whenever", "obtain", "orange", "and", "capture", "orange"], "tl": ["finally", "(", "obtain(orange)", ")", "and", "capture(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "capture", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1 and prop_2)"}
{"id": 2952, "sentence": ["go", "by", "waste", "bin", "means", "that", "when", "possible", "present", "at", "flag"], "tl": ["go_by(waste_bin)", "imply", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "means", "that", "when", "possible", "present", "at", "flag", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 implies (prop_2 implies (finally prop_3))) FINISH"}
{"id": 4011, "sentence": ["at", "some", "time", "venture", "to", "house", "or", "secure", "apple"], "tl": ["finally", "(", "venture_to(house)", ")", "or", "secure(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "secure", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or prop_2) FINISH"}
{"id": 511, "sentence": ["hold", "pear", "or", "at", "some", "time", "go", "to", "home"], "tl": ["hold(pear)", "or", "finally", "(", "go_to(home)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "(finally).\n- The \"hold pear\" is not explicitly qualified by time, so we interpret it as holding pear now or at any time.\n- The overall formula expresses that either \"hold pear\" is true now, or eventually \"go to home\" will be true.\n\n2. *Explanation dictionary*:\n{\"hold pear\": \"prop_1\", \"go to home\": \"prop_2\", \"or\": \"or\", \"at some time\": \"F\"}\n\n3. *FINAL:* (prop_1 or F prop_2)"}
{"id": 6548, "sentence": ["whenever", "make", "contact", "flag", "or", "at", "some", "time", "be", "at", "house"], "tl": ["finally", "(", "make_contact(flag)", ")", "or", "finally", "(", "be_at(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "some", "time", "be", "at", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact", "action_ref": "make contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "be_at", "action_ref": "be at", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F). The entire command \"whenever ... or ...\" means globally (G) if prop_1 holds, then eventually prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"make contact flag\": \"prop_1\", \"at some time be at house\": \"F prop_2\", \"whenever ... or ...\": \"G (prop_1 implies F prop_2)\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 763, "sentence": ["if", "when", "possible", "go", "visit", "house", ",", "when", "possible", "walk", "to", "flag"], "tl": ["finally", "(", "go_visit(house)", ")", "imply", "finally", "(", "walk_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "when", "possible", "prop_1", ",", "when", "possible", "walk", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (globally (prop_1 implies finally prop_2)) and (globally (prop_3 implies finally prop_4)) FINISH"}
{"id": 2293, "sentence": ["whenever", "proceed", "to", "flag", "or", "whenever", "go", "to", "apple"], "tl": ["finally", "(", "proceed_to(flag)", ")", "or", "finally", "(", "go_to(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (globally (prop_1 implies true)) and (globally (prop_2 implies true)) FINISH"}
{"id": 516, "sentence": ["forever", "have", "apple", "and", "when", "possible", "travel", "by", "tree"], "tl": ["globally", "(", "have(apple)", ")", "and", "finally", "(", "travel_by(tree)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "and", "when", "possible", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "travel_by", "action_ref": "travel by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally(prop_1) and globally(prop_2 implies prop_3) FINISH"}
{"id": 1389, "sentence": ["at", "some", "time", "touch", "tree", "or", "whenever", "pass", "by", "waste", "receptacle"], "tl": ["finally", "(", "touch(tree)", ")", "or", "finally", "(", "pass_by(waste_receptacle)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "whenever", "pass", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["waste_receptacle)"], "args_ref": ["waste receptacle)"]}}, "prediction": "(eventually touch tree). The phrase \"whenever pass by waste receptacle\" corresponds to \"globally (prop_2 implies ...)\" where prop_2 is \"pass by waste receptacle\". Since the command is \"touch tree or whenever pass by waste receptacle\", it means either eventually touch tree, or always when passing by waste receptacle some condition holds. The command is ambiguous about what should happen when passing by waste receptacle, but since the only action is \"touch tree or whenever pass by waste receptacle\", it can be interpreted as \"either eventually touch tree, or always when passing by waste receptacle\". Since no further action is specified after \"whenever pass by waste receptacle\", the simplest interpretation is \"finally prop_1 or globally (prop_2 implies true)"}
{"id": 4587, "sentence": ["whenever", "get", "hold", "orange", "and", "go", "to", "orange"], "tl": ["finally", "(", "get_hold(orange)", ")", "and", "go_to(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 6224, "sentence": ["gather", "orange", "or", "whenever", "obtain", "orange"], "tl": ["gather(orange)", "or", "finally", "(", "obtain(orange)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "obtain", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "gather", "action_ref": "gather", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(obtain orange) is true, then \"gather orange\" (prop_2) should happen. Since \"gather orange\" should happen whenever \"obtain orange\" happens, this is expressed as globally (G) if prop_1 then eventually (F) prop_2.\n\n2. *Explanation dictionary* \u2013 {\"obtain orange\": \"prop_1\", \"gather orange\": \"prop_2\", \"whenever obtain orange\": \"G (prop_1 implies F prop_2)\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 143, "sentence": ["when", "possible", "grab", "orange", "or", "pick", "up", "fruit"], "tl": ["finally", "(", "grab(orange)", ")", "or", "pick_up(fruit)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "or", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["fruit)"], "args_ref": ["fruit)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or prop_2) FINISH"}
{"id": 5220, "sentence": ["at", "any", "time", "get", "apple", "and", "at", "any", "time", "get", "orange"], "tl": ["finally", "(", "get(apple)", ")", "and", "finally", "(", "get(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "any", "time", "get", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "get", "action_ref": "get", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "  \"and\": \"and\""}
{"id": 1409, "sentence": ["whenever", "go", "to", "trash", "bin", "or", "whenever", "venture", "to", "waste", "basket"], "tl": ["finally", "(", "go_to(trash_bin)", ")", "or", "finally", "(", "venture_to(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "venture", "to", "waste", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "3. *FINAL:* (globally(prop_1)) or (globally(prop_2)) FINISH"}
{"id": 2548, "sentence": ["move", "to", "trash", "can", "until", "at", "any", "time", "go", "by", "tree"], "tl": ["move_to(trash_can)", "until", "finally", "(", "go_by(tree)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "any", "time", "go", "by", "tree", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (prop_1 until prop_2) FINISH"}
{"id": 6461, "sentence": ["when", "possible", "obtain", "pear", "or", "whenever", "venture", "to", "flag"], "tl": ["finally", "(", "obtain(pear)", ")", "or", "finally", "(", "venture_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "whenever", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (F prop_1) or (G (prop_2 implies F prop_1)) FINISH"}
{"id": 4605, "sentence": ["when", "possible", "tax", "apple", "or", "whenever", "reach", "tree"], "tl": ["finally", "(", "tax(apple)", ")", "or", "finally", "(", "reach(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "whenever", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(finally). The phrase \"tax apple or whenever reach tree\" indicates a disjunction between \"tax apple\" and \"whenever reach tree.\" \"Tax apple\" and \"reach tree\" are propositions prop_1 and prop_2 respectively. \"Whenever reach tree\" means \"globally, if reach tree then ...\", but since it is connected with \"or\" to \"tax apple,\" it means either \"tax apple\" holds or \"whenever reach tree\" holds. The entire formula says: eventually (tax apple or globally (if reach tree then true)), but since \"whenever reach tree\" is just \"globally (reach tree implies ...)\", and no consequent is given, we interpret \"whenever reach tree\" as \"globally (reach tree implies something)\"\u2014here, since no consequent is specified, we take it as \"globally (reach tree implies true)\" which is trivially true. So the main meaningful part is \"finally (tax apple or globally (reach tree implies true))\" which simplifies to \"finally (tax apple or true)"}
{"id": 1490, "sentence": ["whenever", "go", "to", "home", "and", "when", "possible", "be", "near", "tree"], "tl": ["finally", "(", "go_to(home)", ")", "and", "finally", "(", "be_near(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "when", "possible", "be", "near", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. FINAL: globally (prop_1 implies finally prop_2) FINISH"}
{"id": 1805, "sentence": ["repeatedly", "go", "to", "waste", "basket", "or", "never", "drop", "orange"], "tl": ["globally", "(", "finally", "(", "go_to(waste_basket)", ")", ")", "or", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "never", "drop", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(not prop_2).\n- \"go to waste basket or never drop orange\" means prop_1 or G (not prop_2).\n- \"repeatedly\" means that the condition holds infinitely often, which can be expressed as globally finally (F) of the condition: G F (prop_1 or G (not prop_2)).\n\n2. *Explanation dictionary* \u2013\n{\"go to waste basket\" : \"prop_1\", \"drop orange\" : \"prop_2\", \"never drop orange\" : \"G (not prop_2)\", \"go to waste basket or never drop orange\" : \"(prop_1 or G (not prop_2))\", \"repeatedly go to waste basket or never drop orange\" : \"G F (prop_1 or G (not prop_2))"}
{"id": 6419, "sentence": ["if", "hold", "pear", ",", "whenever", "start", "going", "to", "tree"], "tl": ["hold(pear)", "imply", "finally", "(", "start_going_to(tree)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "prop_1", ",", "whenever", "start", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(G) stating that whenever prop_2 is true, prop_1 is also true, i.e., G (prop_2 \u2192 prop_1).\n\n2. *Explanation dictionary* \u2013 {\"if hold pear\": \"prop_1\", \"whenever start going to tree\": \"G (prop_2 \u2192 prop_1)\"}\n\n3. *FINAL:* G (prop_2 implies prop_1)"}
{"id": 5097, "sentence": ["whenever", "journey", "by", "house", "or", "when", "possible", "get", "to", "cup"], "tl": ["finally", "(", "journey_by(house)", ")", "or", "finally", "(", "get_to(cup)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "get", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["cup)"], "args_ref": ["cup)"]}}, "prediction": "3. *FINAL:* G((prop_1 or prop_2) implies F prop_3) FINISH"}
{"id": 1790, "sentence": ["never", "drop", "apple", "or", "approach", "tree"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "or", "approach(tree)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "prop_2"], "grounded_sentence": ["never", "prop_1", "or", "approach", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (not (prop_1 or prop_2)) FINISH"}
{"id": 6973, "sentence": ["when", "whenever", "go", "home", ",", "collect", "pear"], "tl": ["finally", "(", "go(home)", ")", "imply", "collect(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["when", "whenever", "prop_1", ",", "collect", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_1) holds, then \"collect pear\" (prop_2) should eventually happen. This is captured by globally (G) stating that if prop_1 is true, then eventually (F) prop_2 will be true.\n\n2. *Explanation dictionary* \u2013 {\"whenever go home\": \"G (prop_1 implies F prop_2)\", \"collect pear\": \"prop_2\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 1982, "sentence": ["when", "possible", "walk", "to", "flag", "until", "when", "possible", "have", "possession", "of", "apple"], "tl": ["finally", "(", "walk_to(flag)", ")", "until", "finally", "(", "have_possession_of(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "until", "when", "possible", "have", "possession", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "have_possession_of", "action_ref": "have possession of", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_2). So, the formula states that globally, if it is possible to walk to the flag (prop_1), then walk to the flag until it is possible to have possession of the apple (prop_2).\n\n2. *Explanation dictionary* \u2013 {\"when possible walk to flag\": \"prop_1\", \"when possible have possession of apple\": \"prop_2\", \"walk to flag until have possession of apple\": \"prop_1 U prop_2\"}\n\n3. *FINAL:* G (prop_1 \u2192 (prop_1 U prop_2))"}
{"id": 1487, "sentence": ["at", "some", "time", "bring", "pear", "and", "venture", "towards", "house"], "tl": ["finally", "(", "bring(pear)", ")", "and", "venture_towards(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* finally (prop_1 and prop_2) FINISH"}
{"id": 3053, "sentence": ["never", "drop", "apple", "and", "move", "towards", "trash", "can"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "and", "move_towards(trash_can)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "and", "prop_2"], "grounded_sentence": ["never", "prop_1", "and", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "move_towards", "action_ref": "move towards", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1) and globally prop_2) FINISH"}
{"id": 4997, "sentence": ["keep", "apple", "or", "when", "possible", "venture", "flag"], "tl": ["keep(apple)", "or", "finally", "(", "venture(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "venture", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "keep", "action_ref": "keep", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (globally prop_1) or (finally prop_2) FINISH"}
{"id": 5415, "sentence": ["when", "possible", "grab", "pear", "and", "whenever", "go", "to", "home"], "tl": ["finally", "(", "grab(pear)", ")", "and", "finally", "(", "go_to(home)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "3. *FINAL:* (prop_1 implies finally prop_2) and globally prop_3 FINISH"}
{"id": 5172, "sentence": ["visit", "tree", "and", "at", "some", "time", "haul", "pear"], "tl": ["visit(tree)", "and", "finally", "(", "haul(pear)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "haul", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "haul", "action_ref": "haul", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(finally) prop_2 (haul pear) will be true. The word \"and\" connects these two conditions, so the formula states that prop_1 is true now and eventually prop_2 will be true.\n\n2. *Explanation dictionary* \u2013 {\"visit tree\": \"prop_1\", \"at some time haul pear\": \"F prop_2\", \"and\": \"and\"}\n\n3. *FINAL:* (prop_1 and F prop_2)"}
{"id": 5143, "sentence": ["when", "possible", "lay", "hold", "of", "apple", "or", "forever", "hold", "on", "pear"], "tl": ["finally", "(", "lay_hold_of(apple)", ")", "or", "globally", "(", "hold_on(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "forever", "hold", "on", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "lay_hold_of", "action_ref": "lay hold of", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "hold_on", "action_ref": "hold on", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(forever). So the formula expresses that either eventually \"lay hold of apple\" happens, or \"hold on pear\" holds globally.\n\n2. *Explanation dictionary* \u2013\n{\n  \"lay hold of apple\": \"prop_1\",\n  \"hold on pear\": \"prop_2\",\n  \"eventually lay hold of apple\": \"F prop_1\",\n  \"forever hold on pear\": \"G prop_2\",\n  \"when possible lay hold of apple or forever hold on pear\": \"F prop_1 or G prop_2\"\n}\n\n3. *FINAL:* (F prop_1) or (G prop_2)"}
{"id": 5593, "sentence": ["at", "any", "time", "grab", "orange", "means", "that", "at", "any", "time", "seize", "orange"], "tl": ["finally", "(", "grab(orange)", ")", "imply", "finally", "(", "seize(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "means", "that", "at", "any", "time", "seize", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies prop_2) FINISH"}
{"id": 5049, "sentence": ["keep", "apple", "or", "at", "some", "time", "visit", "trash", "bin"], "tl": ["keep(apple)", "or", "finally", "(", "visit(trash_bin)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "visit", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "keep", "action_ref": "keep", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "3. *FINAL:* (globally(prop_1) or finally(prop_2)) FINISH"}
{"id": 3739, "sentence": ["grasp", "orange", "and", "travel", "to", "waste", "bin"], "tl": ["grasp(orange)", "and", "travel_to(waste_bin)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "travel", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "     \"and\": \"and\""}
{"id": 6480, "sentence": ["take", "to", "trash", "can", "and", "whenever", "have", "possession", "of", "apple"], "tl": ["take_to(trash_can)", "and", "finally", "(", "have_possession_of(apple)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "have", "possession", "of", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "have_possession_of", "action_ref": "have possession of", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(possession of apple) holds, then prop_1 (take to trash can) should eventually happen.\n- This is captured by globally (G) stating that if prop_2 holds, then eventually (F) prop_1 will hold.\n\n2. Explanation dictionary:\n{\"take to trash can\": \"prop_1\", \"have possession of apple\": \"prop_2\", \"whenever ...\": \"G (prop_2 implies F prop_1)\"}\n\n3. FINAL: G (prop_2 implies F prop_1)"}
{"id": 1059, "sentence": ["move", "to", "trashcan", "or", "at", "some", "time", "snag", "orange"], "tl": ["move_to(trashcan)", "or", "finally", "(", "snag(orange)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "snag", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 5507, "sentence": ["grab", "hold", "pear", "and", "do", "not", "let", "go", "pear"], "tl": ["grab_hold(pear)", "and", "negation", "(", "let_go(pear)", ")"], "masked_tl": ["prop_1", "and", "negation", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "do", "not", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab_hold", "action_ref": "grab hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(never let go). We can represent \"holding pear\" as prop_1. The command requires that prop_1 is true now and globally remains true (never let go).\n\n2. *Explanation dictionary* \u2013 {\"grab pear\": \"prop_1\", \"hold pear\": \"prop_1\", \"do not let go pear\": \"globally prop_1\"}\n\n3. *FINAL:* (prop_1 and G prop_1)"}
{"id": 4055, "sentence": ["venture", "towards", "house", "and", "never", "drop", "apple"], "tl": ["venture_towards(house)", "and", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["prop_1", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 and globally (not prop_2)) FINISH"}
{"id": 197, "sentence": ["at", "some", "time", "withhold", "apple", "or", "at", "some", "time", "venture", "to", "house"], "tl": ["finally", "(", "withhold(apple)", ")", "or", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 3741, "sentence": ["whenever", "yield", "pear", "or", "always", "hold", "onto", "orange"], "tl": ["finally", "(", "yield(pear)", ")", "or", "globally", "(", "hold_onto(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "always", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "yield", "action_ref": "yield", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(G prop_2).\n- \"yield pear or always hold onto orange\" translates to (prop_1 or G prop_2).\n- \"whenever\" indicates a globally implication, so \"whenever (prop_1 or G prop_2)\" means globally (prop_1 or G prop_2).\n\n2. *Explanation dictionary* \u2013 {\"yield pear\": \"prop_1\", \"hold onto orange\": \"prop_2\", \"always hold onto orange\": \"G prop_2\", \"yield pear or always hold onto orange\": \"(prop_1 or G prop_2)\", \"whenever yield pear or always hold onto orange\": \"G (prop_1 or G prop_2)\"}\n\n3. *FINAL:* G (prop_1 or G prop_2)"}
{"id": 2715, "sentence": ["hold", "on", "to", "pear", "and", "whenever", "get", "to", "cup"], "tl": ["hold_on_to(pear)", "and", "finally", "(", "get_to(cup)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "get", "to", "cup", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold_on_to", "action_ref": "hold on to", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["cup)"], "args_ref": ["cup)"]}}, "prediction": "3. *FINAL:* (globally prop_1) and (globally (prop_2 implies prop_1)) FINISH"}
{"id": 3824, "sentence": ["grip", "apple", "and", "never", "drop", "orange"], "tl": ["grip(apple)", "and", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["prop_1", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grip", "action_ref": "grip", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 and globally (not prop_2)) FINISH"}
{"id": 3786, "sentence": ["drop", "orange", "and", "hold", "pear"], "tl": ["drop(orange)", "and", "hold(pear)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "hold", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (prop_1 and prop_2) FINISH"}
{"id": 4350, "sentence": ["at", "some", "time", "present", "at", "flag", "or", "secure", "apple"], "tl": ["finally", "(", "present_at(flag)", ")", "or", "secure(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "secure", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or prop_2) FINISH"}
{"id": 5553, "sentence": ["when", "possible", "get", "close", "tree", "until", "at", "some", "time", "tax", "apple"], "tl": ["finally", "(", "get_close(tree)", ")", "until", "finally", "(", "tax(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "until", "at", "some", "time", "tax", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* finally (prop_1 until prop_2) FINISH"}
{"id": 4014, "sentence": ["stop", "by", "flag", "until", "whenever", "go", "to", "tree"], "tl": ["stop_by(flag)", "until", "finally", "(", "go_to(tree)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "whenever", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "  \"whenever go to tree\": \"G (prop_2 implies (prop_1 U (not prop_2)))\""}
{"id": 3875, "sentence": ["whenever", "touch", "house", "and", "at", "any", "time", "yield", "pear"], "tl": ["finally", "(", "touch(house)", ")", "and", "finally", "(", "yield(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "any", "time", "yield", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "yield", "action_ref": "yield", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(touch house) is true, something must follow. The phrase \"at any time yield pear\" means that eventually prop_2 (yield pear) must be true. Combining these, the formula states that globally, if prop_1 is true, then eventually prop_2 will be true.\n\n2. *Explanation dictionary* \u2013 {\"whenever touch house\": \"prop_1\", \"at any time yield pear\": \"F prop_2\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 4168, "sentence": ["at", "any", "time", "haul", "pear", "or", "at", "some", "time", "advance", "to", "house"], "tl": ["finally", "(", "haul(pear)", ")", "or", "finally", "(", "advance_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "some", "time", "advance", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "haul", "action_ref": "haul", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (globally(prop_1) or finally(prop_2)) FINISH"}
{"id": 5992, "sentence": ["acquire", "orange", "or", "at", "any", "time", "acquire", "pear"], "tl": ["acquire(orange)", "or", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "any", "time", "acquire", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 6678, "sentence": ["secure", "apple", "or", "whenever", "go", "by", "waste", "basket"], "tl": ["secure(apple)", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "- Combining both parts with \"or\": \"prop_1 or globally (prop_2 implies prop_1)\""}
{"id": 2439, "sentence": ["go", "by", "waste", "bin", "or", "whenever", "go", "by", "waste", "basket"], "tl": ["go_by(waste_bin)", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "go", "by", "waste", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "   prop_1 or G(prop_2 implies prop_2), which simplifies to prop_1 or true, so effectively prop_1 or prop_2."}
{"id": 6978, "sentence": ["whenever", "show", "yourself", "near", "house", "and", "never", "drop", "apple"], "tl": ["finally", "(", "show_yourself_near(house)", ")", "and", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies globally (not prop_2)) FINISH"}
{"id": 581, "sentence": ["when", "possible", "get", "orange", "or", "when", "possible", "show", "yourself", "near", "house"], "tl": ["finally", "(", "get(orange)", ")", "or", "finally", "(", "show_yourself_near(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "show", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(finally). The actions \"get orange\" and \"show yourself near house\" are represented by propositions prop_1 and prop_2 respectively. The command says: eventually get orange or eventually show yourself near house.\n\n2. *Explanation dictionary* \u2013 {\"when possible get orange\": \"F prop_1\", \"when possible show yourself near house\": \"F prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 7055, "sentence": ["never", "drop", "apple", "or", "at", "any", "time", "go", "by", "waste", "basket"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) or (finally prop_2) FINISH"}
{"id": 6807, "sentence": ["never", "let", "go", "orange", "or", "at", "some", "time", "capture", "pear"], "tl": ["globally", "(", "negation", "(", "let_go(orange)", ")", ")", "or", "finally", "(", "capture(pear)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "some", "time", "capture", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "So the formula is globally not (prop_1 or finally prop_2)."}
{"id": 300, "sentence": ["approach", "tree", "and", "repeatedly", "go", "to", "waste", "basket"], "tl": ["approach(tree)", "and", "globally", "(", "finally", "(", "go_to(waste_basket)", ")", ")"], "masked_tl": ["prop_1", "and", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "repeatedly", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(G F prop_2). The conjunction \"and\" connects \"approach tree\" and \"repeatedly go to waste basket\", so the entire formula is prop_1 and G F prop_2.\n\n2. *Explanation dictionary* \u2013 {\"approach tree\": \"prop_1\", \"go to waste basket\": \"prop_2\", \"repeatedly go to waste basket\": \"G F prop_2\", \"approach tree and repeatedly go to waste basket\": \"prop_1 and G F prop_2\"}\n\n3. *FINAL:* (prop_1 and G F prop_2)"}
{"id": 434, "sentence": ["at", "any", "time", "get", "hold", "of", "orange", "or", "when", "possible", "stand", "by", "tree"], "tl": ["finally", "(", "get_hold_of(orange)", ")", "or", "finally", "(", "stand_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "stand", "by", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold_of", "action_ref": "get hold of", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "stand_by", "action_ref": "stand by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or finally prop_2) FINISH"}
{"id": 3833, "sentence": ["at", "some", "time", "scoop", "up", "apple", "and", "at", "some", "time", "journey", "by", "house"], "tl": ["finally", "(", "scoop_up(apple)", ")", "and", "finally", "(", "journey_by(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "some", "time", "journey", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (finally prop_1) and (finally prop_2) FINISH"}
{"id": 4032, "sentence": ["whenever", "go", "to", "house", "or", "do", "not", "pick", "up", "anything"], "tl": ["finally", "(", "go_to(house)", ")", "or", "negation", "(", "finally", "(", "pick_up(anything)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "negation", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "do", "not", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["anything)"], "args_ref": ["anything)"]}}, "prediction": "3. *FINAL:* G(prop_1 or not prop_2) FINISH"}
{"id": 2880, "sentence": ["at", "any", "time", "go", "to", "transh", "can", "or", "at", "some", "time", "got", "to", "house"], "tl": ["finally", "(", "go_to(transh_can)", ")", "or", "finally", "(", "got_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "some", "time", "got", "to", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["transh_can)"], "args_ref": ["transh can)"]}, "prop_2": {"action_canon": "got_to", "action_ref": "got to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (globally prop_1) or (finally prop_2) \u2192 (G prop_1) or (F prop_2) \u2192 (G prop_1) or (F prop_2) \u2192 (G prop_1) or (F prop_2) \u2192 (G prop_1) or (F prop_2) \u2192 (G prop_1) or (F prop_2) \u2192 (G prop_1) or (F prop_2) \u2192 (G prop_1) or (F prop_2) \u2192 (G prop_1) or (F prop_2) \u2192 (G prop_1)"}
{"id": 3428, "sentence": ["move", "to", "trash", "can", "and", "when", "possible", "make", "your", "way", "flag"], "tl": ["move_to(trash_can)", "and", "finally", "(", "make_your_way(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "make", "your", "way", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(representing \"at trash can\") is true, so F prop_1.\n\n- \"when possible make your way flag\": This means that whenever it is possible to make your way to the flag (prop_2), you should eventually do so. Interpreting \"when possible\" as \"if it is possible now or in the future,\" we can say that if eventually prop_2 is reachable, then eventually prop_2 should be reached. This can be expressed as: (F prop_2) implies (F prop_2), which is tautological, so instead, we interpret \"when possible\" as \"if prop_2 is not impossible,\" so we can say: G (F prop_2 \u2192 F prop_2), which is trivial. To capture the intent, we can say: G (F prop_2 \u2192 F prop_2)"}
{"id": 1080, "sentence": ["at", "some", "time", "snag", "orange", "and", "travel", "to", "apple"], "tl": ["finally", "(", "snag(orange)", ")", "and", "travel_to(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* finally (prop_1 and prop_2) FINISH"}
{"id": 854, "sentence": ["at", "any", "time", "set", "out", "to", "house", "and", "at", "some", "time", "touch", "tree"], "tl": ["finally", "(", "set_out_to(house)", ")", "and", "finally", "(", "touch(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "touch", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "set_out_to", "action_ref": "set out to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (globally prop_1) and (finally prop_2) FINISH"}
{"id": 81, "sentence": ["forever", "have", "in", "orange", "until", "reach", "house"], "tl": ["globally", "(", "have_in(orange)", ")", "until", "reach(house)"], "masked_tl": ["globally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["forever", "prop_1", "until", "reach", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(prop_1) holds globally (always). The phrase \"until reach house\" means that this condition holds until the proposition \"reach house\" (prop_2) becomes true. So, the formula is: globally (in orange) until reach house, which is expressed as (prop_1 U prop_2).\n\n2. *Explanation dictionary* \u2013 {\"forever have in orange\": \"prop_1\", \"until reach house\": \"U prop_2\"}\n\n3. *FINAL:* (prop_1 U prop_2)"}
{"id": 3970, "sentence": ["at", "any", "time", "go", "to", "trash", "bin", "or", "at", "some", "time", "tax", "apple"], "tl": ["finally", "(", "go_to(trash_bin)", ")", "or", "finally", "(", "tax(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "some", "time", "tax", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(always) the proposition \"go to trash bin\" holds, so we use G prop_1. The phrase \"or at some time tax apple\" means that eventually (at some time) the proposition \"tax apple\" holds, so we use F prop_2. The entire command is a disjunction (or) of these two temporal statements.\n\n2. *Explanation dictionary* \u2013 {\"at any time go to trash bin\": \"G prop_1\", \"at some time tax apple\": \"F prop_2\"}\n\n3. *FINAL:* (G prop_1) or (F prop_2)"}
{"id": 5249, "sentence": ["at", "any", "time", "approach", "house", "and", "at", "some", "time", "show", "yourself", "near", "house"], "tl": ["finally", "(", "approach(house)", ")", "and", "finally", "(", "show_yourself_near(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "show", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(always) the proposition \"approach house\" (prop_1) holds. The phrase \"at some time show yourself near house\" means that eventually (finally) the proposition \"show yourself near house\" (prop_2) holds. The conjunction \"and\" connects these two temporal requirements.\n\n2. *Explanation dictionary* \u2013 {\"at any time approach house\": \"G prop_1\", \"at some time show yourself near house\": \"F prop_2\"}\n\n3. *FINAL:* (G prop_1) and (F prop_2)"}
{"id": 1579, "sentence": ["at", "some", "time", "snag", "orange", "or", "take", "to", "trashcan"], "tl": ["finally", "(", "snag(orange)", ")", "or", "take_to(trashcan)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 2750, "sentence": ["venture", "to", "trash", "can", "and", "at", "some", "time", "go", "near", "pear"], "tl": ["venture_to(trash_can)", "and", "finally", "(", "go_near(pear)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "go", "near", "pear", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(F prop_1) and (F prop_2)"}
{"id": 446, "sentence": ["when", "possible", "advance", "to", "house", "or", "at", "any", "time", "get", "close", "flag"], "tl": ["finally", "(", "advance_to(house)", ")", "or", "finally", "(", "get_close(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "get", "close", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(F prop_1) or (G F prop_2)"}
{"id": 1137, "sentence": ["travel", "to", "apple", "or", "don't", "let", "go", "pear"], "tl": ["travel_to(apple)", "or", "negation", "(", "let_go(pear)", ")"], "masked_tl": ["prop_1", "or", "negation", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "don't", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (prop_1 or (not prop_2)) FINISH"}
{"id": 5995, "sentence": ["whenever", "venture", "to", "waste", "basket", "or", "when", "possible", "procure", "orange"], "tl": ["finally", "(", "venture_to(waste_basket)", ")", "or", "finally", "(", "procure(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "procure", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(venture to waste basket) holds, something follows. The phrase \"or when possible procure orange\" suggests an alternative condition: if it is possible to procure orange (prop_2), then that should also hold eventually. Combining these, the formula states that globally, either prop_1 holds or eventually prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"whenever venture to waste basket\": \"prop_1\", \"when possible procure orange\": \"F prop_2\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 3737, "sentence": ["move", "to", "trashcan", "or", "when", "possible", "make", "to", "flag"], "tl": ["move_to(trashcan)", "or", "finally", "(", "make_to(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "make", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "make_to", "action_ref": "make to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(F) operator.\n\nThus, the formula states that either \"move to trashcan\" holds now, or eventually \"make to flag\" will hold.\n\n2. *Explanation dictionary* \u2013 {\"move to trashcan\": \"prop_1\", \"make to flag\": \"prop_2\", \"or\": \"or\", \"when possible\": \"finally\"}\n\n3. *FINAL:* (prop_1 or F prop_2)"}
{"id": 5554, "sentence": ["when", "possible", "move", "to", "flag", "or", "at", "any", "time", "walk", "near", "flag"], "tl": ["finally", "(", "move_to(flag)", ")", "or", "finally", "(", "walk_near(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "walk", "near", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "walk_near", "action_ref": "walk near", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1), then this should happen. The phrase \"or at any time walk near flag\" means that alternatively, \"walk near flag\" (prop_2) can happen at any time. So the formula states that either eventually \"move to flag\" happens when possible, or \"walk near flag\" happens globally.\n\n2. *Explanation dictionary* \u2013 {\"when possible move to flag\": \"F prop_1\", \"at any time walk near flag\": \"G prop_2\"}\n\n3. *FINAL:* (F prop_1) or (G prop_2)"}
{"id": 4578, "sentence": ["when", "repeatedly", "go", "to", "apple", "trashcan", ",", "grip", "apple"], "tl": ["globally", "(", "finally", "(", "go_to(apple_trashcan)", ")", ")", "imply", "grip(apple)"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "imply", "prop_2"], "grounded_sentence": ["when", "repeatedly", "prop_1", ",", "grip", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple_trashcan)"], "args_ref": ["apple trashcan)"]}, "prop_2": {"action_canon": "grip", "action_ref": "grip", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1) happens infinitely often, which can be expressed as \"globally finally prop_1\" (G F prop_1). The phrase \"grip apple\" (prop_2) should then hold whenever this repeated action occurs, so \"globally (G)\" we have \"if repeatedly go to apple trashcan then grip apple\", i.e., G((G F prop_1) implies prop_2).\n\n2. *Explanation dictionary* \u2013 {\"repeatedly go to apple trashcan\": \"G F prop_1\", \"grip apple\": \"prop_2\", \"when ... ,\": \"G((G F prop_1) implies prop_2)\"}\n\n3. *FINAL:* G((G F prop_1) implies prop_2)"}
{"id": 2981, "sentence": ["when", "possible", "go", "home", "and", "forever", "touch", "flag"], "tl": ["finally", "(", "go(home)", ")", "and", "globally", "(", "touch(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "forever", "touch", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(F prop_1) and (G prop_2)"}
{"id": 7387, "sentence": ["get", "to", "tree", "or", "approach", "trash", "can"], "tl": ["get_to(tree)", "or", "approach(trash_can)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "approach", "trash", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(F) operator.\n\n2. *Explanation dictionary* \u2013 {\"tree\": \"prop_1\", \"approach trash can\": \"prop_2\", \"or\": \"or\", \"get to\": \"F\"}\n\n3. *FINAL:* F (prop_1 or prop_2)"}
{"id": 3378, "sentence": ["at", "some", "time", "obtain", "orange", "and", "whenever", "stop", "by", "trash", "can"], "tl": ["finally", "(", "obtain(orange)", ")", "and", "finally", "(", "stop_by(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "whenever", "stop", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (F prop_1) and (G (prop_2 \u2192 true)) FINISH"}
{"id": 901, "sentence": ["whenever", "proceed", "to", "flag", "or", "whenever", "approach", "flag"], "tl": ["finally", "(", "proceed_to(flag)", ")", "or", "finally", "(", "approach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "approach", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 7392, "sentence": ["whenever", "go", "by", "house", "and", "pick", "up", "pear"], "tl": ["finally", "(", "go_by(house)", ")", "and", "pick_up(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 4972, "sentence": ["when", "possible", "proceed", "to", "house", "and", "when", "possible", "start", "going", "to", "tree"], "tl": ["finally", "(", "proceed_to(house)", ")", "and", "finally", "(", "start_going_to(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "start", "going", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(finally). The command has two parts connected by \"and\":\n\n- \"when possible proceed to house\" translates to \"eventually prop_1\" (prop_1 = proceed to house).\n- \"when possible start going to tree\" translates to \"eventually prop_2\" (prop_2 = start going to tree).\n\nThe entire formula is the conjunction of these two eventualities.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible proceed to house\": \"F prop_1\",\n  \"when possible start going to tree\": \"F prop_2\"\n}\n\n3. *FINAL:* (F prop_1) and (F prop_2)"}
{"id": 5217, "sentence": ["put", "in", "apple", "bucket", "and", "at", "any", "time", "travel", "to", "trash", "can"], "tl": ["put_in(apple_bucket)", "and", "finally", "(", "travel_to(trash_can)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "any", "time", "travel", "to", "trash", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["apple_bucket)"], "args_ref": ["apple bucket)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (prop_1 and finally prop_2) FINISH"}
{"id": 2456, "sentence": ["at", "any", "time", "seize", "orange", "or", "when", "possible", "acquire", "pear"], "tl": ["finally", "(", "seize(orange)", ")", "or", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "acquire", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(G), meaning the property holds always. The phrase \"seize orange or when possible acquire pear\" means that at any time, either \"seize orange\" holds or \"acquire pear\" eventually holds. We represent \"seize orange\" as prop_1 and \"acquire pear\" as prop_2. The \"or\" connects these two propositions. The phrase \"when possible\" suggests that acquiring pear should eventually happen if not seizing orange immediately, so we use \"finally\" (F) for prop_2.\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"G\", \"seize orange\": \"prop_1\", \"or\": \"or\", \"when possible acquire pear\": \"F prop_2\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 2870, "sentence": ["whenever", "let", "go", "apple", "or", "pick", "up", "fruit"], "tl": ["finally", "(", "let_go(apple)", ")", "or", "pick_up(fruit)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["fruit)"], "args_ref": ["fruit)"]}}, "prediction": "(G) condition. The condition is \"let go apple or pick up fruit,\" which is a disjunction (or) of two propositions: \"let go apple\" and \"pick up fruit.\" We assign prop_1 to \"let go apple\" and prop_2 to \"pick up fruit.\" The formula states that globally, if either prop_1 or prop_2 holds, then something follows. Since the command is just \"whenever\" followed by the condition, it implies that whenever the condition holds, it should hold (or some implicit consequence). Without further consequence, the formula is simply G (prop_1 or prop_2).\n\n2. *Explanation dictionary* \u2013 {\"let go apple\": \"prop_1\", \"pick up fruit\": \"prop_2\", \"let go apple or pick up fruit\": \"(prop_1 or prop_2)\", \"whenever let go apple or pick up fruit\": \"G (prop_1 or prop_2)\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 171, "sentence": ["when", "possible", "travel", "to", "house", "or", "whenever", "move", "past", "trash", "can"], "tl": ["finally", "(", "travel_to(house)", ")", "or", "finally", "(", "move_past(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "whenever", "move", "past", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_past", "action_ref": "move past", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (globally (prop_2 implies (finally prop_1))) FINISH"}
{"id": 5959, "sentence": ["go", "to", "bucket", "until", "when", "possible", "touch", "house"], "tl": ["go_to(bucket)", "until", "finally", "(", "touch(house)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "when", "possible", "touch", "house", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_1) U (prop_2) FINISH"}
{"id": 7182, "sentence": ["never", "let", "go", "apple", "until", "at", "some", "time", "collect", "orange"], "tl": ["globally", "(", "negation", "(", "let_go(apple)", ")", ")", "until", "finally", "(", "collect(orange)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "until", "at", "some", "time", "collect", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1) should never happen, so we use globally not prop_1: G (not prop_1). The phrase \"until at some time collect orange\" means that this restriction holds until eventually \"collect orange\" (prop_2) happens, so we use prop_1 until finally prop_2: (not prop_1) U (F prop_2).\n\n2. *Explanation dictionary* \u2013 {\"never let go apple\": \"not prop_1\", \"until at some time collect orange\": \"U (F prop_2)\"}\n\n3. *FINAL:* (not prop_1) U (F prop_2)"}
{"id": 6703, "sentence": ["at", "some", "time", "stop", "by", "house", "or", "forever", "have", "in", "orange"], "tl": ["finally", "(", "stop_by(house)", ")", "or", "globally", "(", "have_in(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "forever", "have", "in", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (globally prop_2) FINISH"}
{"id": 49, "sentence": ["at", "some", "time", "grab", "pear", "and", "whenever", "pick", "up", "peach"], "tl": ["finally", "(", "grab(pear)", ")", "and", "finally", "(", "pick_up(peach)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "whenever", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["peach)"], "args_ref": ["peach)"]}}, "prediction": "3. *FINAL:* (F prop_1) and (G (prop_2 implies prop_"}
{"id": 6078, "sentence": ["never", "drop", "orange", "and", "move", "to", "tree"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "and", "move_to(tree)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "and", "prop_2"], "grounded_sentence": ["never", "prop_1", "and", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) and (finally prop_2) FINISH"}
{"id": 3893, "sentence": ["whenever", "grab", "apple", "and", "never", "drop", "orange"], "tl": ["finally", "(", "grab(apple)", ")", "and", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* G (prop_1 implies G (not prop_2)) FINISH"}
{"id": 3432, "sentence": ["whenever", "getting", "pear", "can", "infer", "that", "at", "any", "time", "go", "to", "house"], "tl": ["finally", "(", "getting(pear)", ")", "imply", "finally", "(", "go_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "can", "infer", "that", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "getting", "action_ref": "getting", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(getting pear) holds,\n- \"can infer that at any time go to house\" means that eventually (at any future time) prop_2 (go to house) will hold.\n- Combining these, we get: globally (if prop_1 then finally prop_2).\n\n2. Explanation dictionary:\n{\"whenever getting pear\": \"prop_1\", \"at any time go to house\": \"F prop_2\"}\n\n3. FINAL: G (prop_1 implies F prop_2)"}
{"id": 2403, "sentence": ["when", "possible", "go", "by", "waste", "basket", "and", "when", "possible", "go", "by", "waste", "basket"], "tl": ["finally", "(", "go_by(waste_basket)", ")", "and", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_2", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "go", "by", "waste", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "3. *FINAL:* (globally (prop_1 implies finally prop_2)) and (globally (prop_1 implies finally prop_2)) FINISH"}
{"id": 4795, "sentence": ["at", "some", "time", "withhold", "apple", "and", "at", "some", "time", "reach", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "some", "time", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (finally prop_1) and (finally prop_2) FINISH"}
{"id": 2809, "sentence": ["at", "any", "time", "start", "going", "to", "house", "or", "when", "possible", "start", "going", "to", "house"], "tl": ["finally", "(", "start_going_to(house)", ")", "or", "finally", "(", "start_going_to(house)", ")"], "masked_tl": ["finally", "(", "prop_2", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "start", "going", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (G F prop_1) or (G (prop_2 implies F prop_1)) FINISH"}
{"id": 6951, "sentence": ["venture", "towards", "house", "or", "whenever", "go", "by", "waste", "basket"], "tl": ["venture_towards(house)", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(prop_1 or prop_2)\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 3371, "sentence": ["always", "touch", "flag", "can", "infer", "that", "whenever", "go", "to", "apple"], "tl": ["globally", "(", "touch(flag)", ")", "imply", "finally", "(", "go_to(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "can", "infer", "that", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* globally (prop_2 implies prop_1) FINISH"}
{"id": 6901, "sentence": ["when", "possible", "come", "home", "means", "that", "pick", "up", "pear"], "tl": ["finally", "(", "come(home)", ")", "imply", "pick_up(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "means", "that", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "come", "action_ref": "come", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(F). \"Come home\" is represented by prop_1. \"Pick up pear\" is represented by prop_2. The phrase \"means that\" indicates an implication. So the command means: if it is possible to come home eventually, then eventually pick up the pear. This can be expressed as: finally prop_1 implies finally prop_2.\n\n2. *Explanation dictionary* \u2013 {\"when possible\": \"F\", \"come home\": \"prop_1\", \"pick up pear\": \"prop_2\", \"means that\": \"implies\"}\n\n3. *FINAL:* (F prop_1) implies (F prop_2)"}
{"id": 2217, "sentence": ["at", "any", "time", "go", "to", "tree", "until", "take", "apple"], "tl": ["finally", "(", "go_to(tree)", ")", "until", "take(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "until", "take", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(G), meaning the property holds at all times. \"go to tree\" is represented by prop_1, and \"take apple\" by prop_2. The phrase \"go to tree until take apple\" translates to \"prop_1 until prop_2\". Combining these, the entire command is \"globally (prop_1 until prop_2)\".\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"globally\", \"go to tree\": \"prop_1\", \"take apple\": \"prop_2\", \"go to tree until take apple\": \"(prop_1 until prop_2)\"}\n\n3. *FINAL:* G (prop_1 until prop_2)"}
{"id": 1929, "sentence": ["at", "any", "time", "withhold", "apple", "and", "at", "some", "time", "present", "at", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "present", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(always) the proposition \"withhold apple\" holds, so we use G prop_1 where prop_1 represents \"withhold apple\". The phrase \"at some time present at flag\" means that eventually (at some time) the proposition \"present at flag\" holds, so we use F prop_2 where prop_2 represents \"present at flag\". The entire command is a conjunction of these two temporal requirements, so we combine them with and.\n\n2. *Explanation dictionary* \u2013 {\"at any time withhold apple\": \"G prop_1\", \"at some time present at flag\": \"F prop_2\"}\n\n3. *FINAL:* (G prop_1) and (F prop_2)"}
{"id": 6116, "sentence": ["at", "some", "time", "withhold", "apple", "and", "at", "any", "time", "present", "at", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "any", "time", "present", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(eventually withhold apple). The phrase \"and at any time present at flag\" corresponds to \"globally prop_2\" (always present at flag). The entire command is a conjunction of these two temporal properties.\n\n2. *Explanation dictionary* \u2013 {\"at some time withhold apple\": \"F prop_1\", \"at any time present at flag\": \"G prop_2\"}\n\n3. *FINAL:* (F prop_1) and (G prop_2)"}
{"id": 1794, "sentence": ["don't", "let", "go", "pear", "means", "that", "take", "pear"], "tl": ["negation", "(", "let_go(pear)", ")", "imply", "take(pear)"], "masked_tl": ["negation", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["don't", "prop_1", "means", "that", "take", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (not prop_1) implies prop_2 FINISH"}
{"id": 5394, "sentence": ["go", "to", "orange", "or", "pick", "up", "flag"], "tl": ["go_to(orange)", "or", "pick_up(flag)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 or prop_2) FINISH"}
{"id": 3055, "sentence": ["go", "to", "bucket", "and", "when", "possible", "procure", "orange"], "tl": ["go_to(bucket)", "and", "finally", "(", "procure(orange)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "procure", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (finally(prop_1) and globally(prop_2 implies finally(prop_3))) FINISH"}
{"id": 64, "sentence": ["at", "any", "time", "bring", "pear", "or", "venture", "towards", "house"], "tl": ["finally", "(", "bring(pear)", ")", "or", "venture_towards(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 136, "sentence": ["whenever", "make", "to", "flag", "or", "drop", "pear"], "tl": ["finally", "(", "make_to(flag)", ")", "or", "drop(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "drop", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_to", "action_ref": "make to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(G) condition. The event \"make to flag or drop pear\" is a disjunction of two propositions: \"make to flag\" and \"drop pear\". We assign prop_1 to \"make to flag\" and prop_2 to \"drop pear\". The command means that whenever either prop_1 or prop_2 occurs, some condition holds. Since no further condition is specified, we interpret it as \"whenever prop_1 or prop_2 happens, it is true\" (i.e., the occurrence of prop_1 or prop_2 is always possible). Thus, the formula is globally (prop_1 or prop_2).\n\n2. *Explanation dictionary* \u2013 {\"make to flag\": \"prop_1\", \"drop pear\": \"prop_2\", \"make to flag or drop pear\": \"(prop_1 or prop_2)\", \"whenever make to flag or drop pear\": \"G(prop_1 or prop_2)\"}\n\n3. *FINAL:* G(prop_1 or prop_2)"}
{"id": 5779, "sentence": ["when", "possible", "walk", "to", "flag", "until", "pick", "up", "pear"], "tl": ["finally", "(", "walk_to(flag)", ")", "until", "pick_up(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "until", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (F prop_1) implies (prop_1 U prop_2) FINISH"}
{"id": 1702, "sentence": ["if", "at", "some", "time", "secure", "pear", ",", "whenever", "take", "possession", "of", "bear"], "tl": ["finally", "(", "secure(pear)", ")", "imply", "finally", "(", "take_possession_of(bear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "at", "some", "time", "prop_1", ",", "whenever", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}}, "prediction": "3. *FINAL:* (F prop_1) implies (G (prop_2 implies F prop_1)) FINISH"}
{"id": 1502, "sentence": ["when", "possible", "going", "to", "house", "and", "move", "towards", "trash", "can"], "tl": ["finally", "(", "going_to(house)", ")", "and", "move_towards(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "move", "towards", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_towards", "action_ref": "move towards", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* G((prop_1 and prop_2) implies F prop_2) FINISH"}
{"id": 1410, "sentence": ["at", "some", "time", "seize", "pear", "or", "at", "some", "time", "grab", "apple"], "tl": ["finally", "(", "seize(pear)", ")", "or", "finally", "(", "grab(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "grab", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 5643, "sentence": ["go", "by", "waste", "bin", "and", "when", "possible", "reach", "flag"], "tl": ["go_by(waste_bin)", "and", "finally", "(", "reach(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "reach", "flag", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (finally prop_1) and (finally prop_2) FINISH"}
{"id": 1576, "sentence": ["at", "any", "time", "be", "at", "house", "means", "that", "when", "possible", "reach", "tree"], "tl": ["finally", "(", "be_at(house)", ")", "imply", "finally", "(", "reach(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "means", "that", "when", "possible", "reach", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_at", "action_ref": "be at", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(G), meaning always. \"be at house\" is represented by prop_1. \"means that\" indicates an implication (implies). \"when possible reach tree\" means that if it is possible to reach the tree, then eventually the tree is reached. We represent \"reach tree\" as prop_2, and \"when possible\" implies that if it is possible to reach the tree, then eventually prop_2 holds. Since \"possible\" is not directly represented, we interpret it as \"if prop_2 can eventually be true,\" so the formula is: globally (at house implies eventually tree).\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"globally\", \"be at house\": \"prop_1\", \"means that\": \"implies\", \"reach tree\": \"prop_2\", \"when possible reach tree\": \"finally prop_2\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 5511, "sentence": ["don't", "let", "go", "orange", "and", "come", "to", "tree"], "tl": ["negation", "(", "let_go(orange)", ")", "and", "come_to(tree)"], "masked_tl": ["negation", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["don't", "prop_1", "and", "come", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "come_to", "action_ref": "come to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (globally prop_1) and (finally prop_2) FINISH"}
{"id": 7437, "sentence": ["at", "any", "time", "capture", "pear", "or", "move", "to", "trash", "can"], "tl": ["finally", "(", "capture(pear)", ")", "or", "move_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (globally (prop_1 or prop_2)) FINISH"}
{"id": 6715, "sentence": ["whenever", "make", "contact", "with", "house", "or", "when", "possible", "go", "near", "pear"], "tl": ["finally", "(", "make_contact_with(house)", ")", "or", "finally", "(", "go_near(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "go", "near", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 2392, "sentence": ["pick", "up", "pear", "and", "when", "possible", "get", "apple"], "tl": ["pick_up(pear)", "and", "finally", "(", "get(apple)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "get", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "get", "action_ref": "get", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (F prop_1) and (G (prop_2 implies F prop_3)) FINISH"}
{"id": 2287, "sentence": ["at", "some", "time", "scoop", "up", "pear", "or", "never", "let", "go", "orange"], "tl": ["finally", "(", "scoop_up(pear)", ")", "or", "globally", "(", "negation", "(", "let_go(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "never", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or globally prop_2) FINISH"}
{"id": 782, "sentence": ["when", "possible", "approach", "flag", "and", "whenever", "obtain", "orange"], "tl": ["finally", "(", "approach(flag)", ")", "and", "finally", "(", "obtain(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "whenever", "obtain", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 implies finally prop_2) and globally (prop_3 implies true) FINISH"}
{"id": 7207, "sentence": ["at", "any", "time", "travel", "house", "or", "when", "possible", "journey", "to", "flag"], "tl": ["finally", "(", "travel(house)", ")", "or", "finally", "(", "journey_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "journey", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel", "action_ref": "travel", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(G), meaning always. The phrase \"travel house or when possible journey to flag\" indicates a disjunction (or) between two propositions: \"travel house\" (prop_1) and \"when possible journey to flag\" (prop_2). Since \"when possible\" suggests that the journey to flag should happen eventually if possible, we interpret prop_2 as something that should eventually happen, so we use \"finally\" (F) for prop_2. The entire formula states that globally, either prop_1 holds or eventually prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"globally\", \"travel house\": \"prop_1\", \"when possible journey to flag\": \"finally prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 6828, "sentence": ["whenever", "spend", "time", "at", "tree", "and", "at", "some", "time", "move", "near", "tree"], "tl": ["finally", "(", "spend_time_at(tree)", ")", "and", "finally", "(", "move_near(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "some", "time", "move", "near", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "move_near", "action_ref": "move near", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* G (prop_1 implies finally prop_2) FINISH"}
{"id": 6481, "sentence": ["whenever", "going", "to", "house", "or", "at", "any", "time", "venture", "to", "flag"], "tl": ["finally", "(", "going_to(house)", ")", "or", "finally", "(", "venture_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_2)"}
{"id": 546, "sentence": ["whenever", "reach", "flag", "or", "go", "by", "waste", "bin"], "tl": ["finally", "(", "reach(flag)", ")", "or", "go_by(waste_bin)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "(prop_1 or prop_2)\", \"whenever reach flag or go by waste bin\": \"G(prop_1 or prop_2)\"}\n\n3. *FINAL:* G(prop_1 or prop_2)"}
{"id": 1109, "sentence": ["at", "any", "time", "seize", "orange", "or", "go", "to", "bucket"], "tl": ["finally", "(", "seize(orange)", ")", "or", "go_to(bucket)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}}, "prediction": "(or) between two propositions: \"seize orange\" and \"go to bucket\". We assign prop_1 to \"seize orange\" and prop_2 to \"go to bucket\". Thus, the formula states that globally, either prop_1 or prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"G\", \"seize orange\": \"prop_1\", \"go to bucket\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 5062, "sentence": ["whenever", "get", "orange", "and", "whenever", "let", "go", "apple"], "tl": ["finally", "(", "get(orange)", ")", "and", "finally", "(", "let_go(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "whenever", "let", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "G (prop_1 \u2192 prop_1) and G (prop_2 \u2192 prop_2)"}
{"id": 6779, "sentence": ["always", "have", "in", "orange", "or", "when", "possible", "be", "in", "house's", "vicinity"], "tl": ["globally", "(", "have_in(orange)", ")", "or", "finally", "(", "be_in(house's_vicinity)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "or", "when", "possible", "be", "in", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "be_in", "action_ref": "be in", "args_canon": ["house's_vicinity)"], "args_ref": ["house's vicinity)"]}}, "prediction": "(prop_2), then be in the house's vicinity (prop_2).\n- The \"or\" connects \"have in orange\" and \"when possible be in house's vicinity\".\n- So, globally, either prop_1 holds or prop_2 holds.\n\n2. *Explanation dictionary*:\n{\"always\": \"G\", \"have in orange\": \"prop_1\", \"when possible be in house's vicinity\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 4873, "sentence": ["go", "by", "waste", "bin", "or", "never", "drop", "apple"], "tl": ["go_by(waste_bin)", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "or", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 or (globally (not prop_2))) FINISH"}
{"id": 2720, "sentence": ["hold", "pear", "or", "pick", "up", "flag"], "tl": ["hold(pear)", "or", "pick_up(flag)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "pick", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 or prop_2) FINISH"}
{"id": 2885, "sentence": ["hold", "pear", "and", "when", "possible", "get", "close", "tree"], "tl": ["hold(pear)", "and", "finally", "(", "get_close(tree)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "get", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(holding pear) should be true globally (always). The phrase \"when possible get close tree\" means that if it is possible to get close to the tree (prop_2), then eventually (finally) prop_2 (getting close to the tree) should happen. Combining these, we have \"hold pear\" globally and \"if possible, eventually get close tree\".\n\n2. *Explanation dictionary* \u2013\n{\n  \"hold pear\": \"G prop_1\",\n  \"when possible get close tree\": \"F prop_2\"\n}\n\n3. *FINAL:* (G prop_1) and (F prop_2)"}
{"id": 7316, "sentence": ["at", "some", "time", "start", "going", "to", "house", "means", "that", "repeatedly", "go", "to", "apple", "trashcan"], "tl": ["finally", "(", "start_going_to(house)", ")", "imply", "globally", "(", "finally", "(", "go_to(apple_trashcan)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "means", "that", "repeatedly", "go", "to", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple_trashcan)"], "args_ref": ["apple trashcan)"]}}, "prediction": "(F prop_1), where prop_1 represents \"start going to house.\" The phrase \"means that\" indicates an implication. The phrase \"repeatedly go to apple trashcan\" corresponds to \"globally finally prop_2\" (G F prop_2), where prop_2 represents \"go to apple trashcan.\" So the entire formula is: (F prop_1) implies (G F prop_2).\n\n2. *Explanation dictionary* \u2013 {\"at some time start going to house\": \"F prop_1\", \"repeatedly go to apple trashcan\": \"G F prop_2\", \"means that\": \"implies\"}\n\n3. *FINAL:* (F prop_1) implies (G F prop_2)"}
{"id": 4368, "sentence": ["whenever", "withhold", "apple", "or", "at", "any", "time", "go", "by", "waste", "basket"], "tl": ["finally", "(", "withhold(apple)", ")", "or", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or finally prop_2) FINISH"}
{"id": 5298, "sentence": ["at", "any", "time", "scoop", "up", "apple", "and", "at", "any", "time", "seize", "pear"], "tl": ["finally", "(", "scoop_up(apple)", ")", "and", "finally", "(", "seize(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "any", "time", "seize", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(finally) the proposition representing \"scoop up apple\" (prop_1) will be true. Similarly, \"at any time seize pear\" means eventually (finally) the proposition representing \"seize pear\" (prop_2) will be true. The conjunction \"and\" connects these two eventualities, so both must eventually happen.\n\n2. *Explanation dictionary* \u2013 {\"at any time scoop up apple\": \"F prop_1\", \"at any time seize pear\": \"F prop_2\", \"and\": \"and\"}\n\n3. *FINAL:* (F prop_1) and (F prop_2)"}
{"id": 2977, "sentence": ["at", "any", "time", "got", "to", "house", "means", "that", "at", "some", "time", "venture", "flag"], "tl": ["finally", "(", "got_to(house)", ")", "imply", "finally", "(", "venture(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "means", "that", "at", "some", "time", "venture", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "got_to", "action_ref": "got to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 5472, "sentence": ["never", "drop", "orange", "or", "acquire", "apple"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "or", "acquire(apple)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "prop_2"], "grounded_sentence": ["never", "prop_1", "or", "acquire", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* globally (not (prop_1 or prop_2)) FINISH"}
{"id": 55, "sentence": ["go", "to", "bucket", "and", "take", "to", "tree"], "tl": ["go_to(bucket)", "and", "take_to(tree)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "take", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (F prop_1) and (F (prop_2 and F prop_3))"}
{"id": 5781, "sentence": ["approach", "tree", "can", "infer", "that", "when", "possible", "make", "your", "way", "flag"], "tl": ["approach(tree)", "imply", "finally", "(", "make_your_way(flag)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "can", "infer", "that", "when", "possible", "make", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(possible), then eventually prop_2 (make your way flag).\n\n2. *Explanation dictionary* \u2013 {\"when possible\": \"F prop_1\", \"make your way flag\": \"F prop_2\", \"can infer that when possible make your way flag\": \"F prop_1 implies F prop_2\"}\n\n3. *FINAL:* (F prop_1) implies (F prop_2)"}
{"id": 4160, "sentence": ["secure", "apple", "and", "at", "some", "time", "go", "by", "waste", "basket"], "tl": ["secure(apple)", "and", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "3. *FINAL:* (prop_1 and (finally prop_2)) FINISH"}
{"id": 2320, "sentence": ["venture", "towards", "house", "and", "at", "some", "time", "go", "by", "waste", "basket"], "tl": ["venture_towards(house)", "and", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "3. *FINAL:* (prop_1 and (F prop_2)) FINISH"}
{"id": 653, "sentence": ["when", "possible", "venture", "to", "waste", "basket", "or", "at", "any", "time", "venture", "house"], "tl": ["finally", "(", "venture_to(waste_basket)", ")", "or", "finally", "(", "venture(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "venture", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 3030, "sentence": ["get", "hold", "of", "pear", "and", "whenever", "obtain", "apple"], "tl": ["get_hold_of(pear)", "and", "finally", "(", "obtain(apple)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "whenever", "obtain", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold_of", "action_ref": "get hold of", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* prop_1 and G (prop_2 implies prop_1) FINISH"}
{"id": 2982, "sentence": ["when", "walk", ",", "at", "some", "time", "journey", "by", "house"], "tl": ["walk", "imply", "finally", "(", "journey_by(house)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "prop_1", ",", "at", "some", "time", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk", "action_ref": "walk", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_1 implies (F prop_2)) FINISH"}
{"id": 5513, "sentence": ["at", "some", "time", "make", "your", "way", "flag", "or", "whenever", "make", "your", "way", "flag"], "tl": ["finally", "(", "make_your_way(flag)", ")", "or", "finally", "(", "make_your_way(flag)", ")"], "masked_tl": ["finally", "(", "prop_2", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "whenever", "make", "your", "way", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "make_your_way", "action_ref": "make your way", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(F prop_1), meaning prop_1 will be true at some point in the future. The phrase \"or whenever make your way flag\" means \"or globally prop_1\" (G prop_1), meaning prop_1 is always true. Combining these with \"or\" gives (F prop_1) or (G prop_1).\n\n2. *Explanation dictionary* \u2013 {\"at some time make your way flag\": \"F prop_1\", \"whenever make your way flag\": \"G prop_1\", \"or\": \"or\"}\n\n3. *FINAL:* (F prop_1) or (G prop_1)"}
{"id": 6844, "sentence": ["when", "possible", "travel", "to", "house", "or", "at", "any", "time", "go", "to", "flag"], "tl": ["finally", "(", "travel_to(house)", ")", "or", "finally", "(", "go_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1), then eventually (finally) travel to the house (prop_1). The phrase \"or at any time go to flag\" means that at any time, eventually go to the flag (prop_2). Combining these with \"or\" means either eventually go to the house when possible, or eventually go to the flag at any time.\n\n2. *Explanation dictionary* \u2013\n{\n  \"possible travel to house\": \"prop_1\",\n  \"go to flag\": \"prop_2\",\n  \"when possible travel to house\": \"F prop_1\",\n  \"at any time go to flag\": \"F prop_2\",\n  \"when possible travel to house or at any time go to flag\": \"F prop_1 or F prop_2\"\n}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 5432, "sentence": ["when", "possible", "go", "by", "house", "or", "never", "let", "go", "apple"], "tl": ["finally", "(", "go_by(house)", ")", "or", "globally", "(", "negation", "(", "let_go(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "never", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 implies (prop_2 or (globally (not prop_3)))) FINISH"}
{"id": 4487, "sentence": ["whenever", "contact", "house", "or", "at", "any", "time", "get", "hold", "orange"], "tl": ["finally", "(", "contact(house)", ")", "or", "finally", "(", "get_hold(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "get", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(contact house) is true,\n- \"or at any time get hold orange\" means that either the above condition holds, or eventually (at any time) prop_2 (get hold orange) will be true.\n\nSince \"whenever\" implies a globally condition, and \"or at any time\" suggests an eventuality, the formula captures that globally, if contact house occurs, or eventually get hold orange occurs.\n\n2. *Explanation dictionary* \u2013\n{\n  \"contact house\": \"prop_1\",\n  \"get hold orange\": \"prop_2\",\n  \"whenever contact house\": \"G (prop_1 \u2192 ...)\",\n  \"at any time get hold orange\": \"F prop_2\",\n  \"whenever contact house or at any time get hold orange\": \"G (prop_1) or F prop_2\"\n}\n\n3. *FINAL:* (G prop_1) or (F prop_2)"}
{"id": 4817, "sentence": ["travel", "to", "apple", "and", "at", "some", "time", "venture", "flag"], "tl": ["travel_to(apple)", "and", "finally", "(", "venture(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "some", "time", "venture", "flag", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "     \"and\": \"and\""}
{"id": 980, "sentence": ["whenever", "go", "to", "home", "until", "when", "possible", "pass", "by", "trash", "bin"], "tl": ["finally", "(", "go_to(home)", ")", "until", "finally", "(", "pass_by(trash_bin)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "until", "when", "possible", "pass", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "3. *FINAL:* G (prop_1 implies (prop_1 U prop_2)) FINISH"}
{"id": 1032, "sentence": ["at", "some", "time", "move", "near", "tree", "and", "repeatedly", "go", "to", "apple", "trashcan"], "tl": ["finally", "(", "move_near(tree)", ")", "and", "globally", "(", "finally", "(", "go_to(apple_trashcan)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "repeatedly", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_near", "action_ref": "move near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple_trashcan)"], "args_ref": ["apple trashcan)"]}}, "prediction": "  \"and\": \"and\""}
{"id": 1994, "sentence": ["at", "any", "time", "travel", "to", "flag", "and", "stop", "by", "flag"], "tl": ["finally", "(", "travel_to(flag)", ")", "and", "stop_by(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "stop", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies prop_2) FINISH"}
{"id": 6783, "sentence": ["at", "any", "time", "walk", "near", "flag", "or", "at", "any", "time", "get", "hold", "orange"], "tl": ["finally", "(", "walk_near(flag)", ")", "or", "finally", "(", "get_hold(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "any", "time", "get", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk_near", "action_ref": "walk near", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (G (prop_1 or prop_2)) FINISH"}
{"id": 6217, "sentence": ["visit", "tree", "and", "at", "any", "time", "show", "yourself", "near", "house"], "tl": ["visit(tree)", "and", "finally", "(", "show_yourself_near(house)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "any", "time", "show", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(representing \"at tree\") holds, so we use finally(prop_1). The phrase \"at any time show yourself near house\" means that globally (always) prop_2 (representing \"show yourself near house\") holds.\n\n2. *Explanation dictionary* \u2013 {\"visit tree\": \"F prop_1\", \"at any time show yourself near house\": \"G prop_2\"}\n\n3. *FINAL:* (F prop_1) and (G prop_2)"}
{"id": 6152, "sentence": ["go", "to", "orange", "bin", "or", "come", "to", "tree"], "tl": ["go_to(orange_bin)", "or", "come_to(tree)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "come", "to", "tree", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange_bin)"], "args_ref": ["orange bin)"]}, "prop_2": {"action_canon": "come_to", "action_ref": "come to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (prop_1 or prop_2) FINISH"}
{"id": 5350, "sentence": ["secure", "apple", "or", "secure", "apple"], "tl": ["secure(apple)", "or", "secure(apple)"], "masked_tl": ["prop_2", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "secure", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 or prop_1) FINISH"}
{"id": 2509, "sentence": ["when", "possible", "go", "by", "waste", "basket", "and", "at", "any", "time", "reach", "flag"], "tl": ["finally", "(", "go_by(waste_basket)", ")", "and", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "any", "time", "reach", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1), then eventually go by waste basket (prop_2).\" The phrase \"at any time reach flag\" means that reaching the flag (prop_3) should eventually happen at some point, regardless of other conditions.\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible\": \"prop_1\",\n  \"go by waste basket\": \"F prop_2\",\n  \"at any time reach flag\": \"F prop_3\"\n}\n\n3. *FINAL:* (prop_1 implies F prop_2)"}
{"id": 6656, "sentence": ["at", "some", "time", "show", "yourself", "near", "house", "or", "at", "some", "time", "pass", "by", "trash", "bin"], "tl": ["finally", "(", "show_yourself_near(house)", ")", "or", "finally", "(", "pass_by(trash_bin)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "pass", "by", "trash", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 7472, "sentence": ["snatch", "up", "pear", "and", "go", "to", "orange", "bin"], "tl": ["snatch_up(pear)", "and", "go_to(orange_bin)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch_up", "action_ref": "snatch up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange_bin)"], "args_ref": ["orange bin)"]}}, "prediction": "3. *FINAL:* (prop_1 and finally prop_2) FINISH"}
{"id": 5282, "sentence": ["put", "in", "bin", "or", "at", "any", "time", "gather", "pear"], "tl": ["put_in(bin)", "or", "finally", "(", "gather(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "any", "time", "gather", "pear", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}, "prop_2": {"action_canon": "gather", "action_ref": "gather", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(G F), meaning \"eventually at some point in the future.\" So the formula is: (put_in_bin) or (eventually gather_pear). We assign prop_1 to \"put in bin\" and prop_2 to \"gather pear.\"\n\n2. *Explanation dictionary* \u2013 {\"put in bin\": \"prop_1\", \"at any time gather pear\": \"F prop_2\"}\n\n3. *FINAL:* (prop_1 or F prop_2)"}
{"id": 6373, "sentence": ["when", "drop", "orange", ",", "pick", "up", "fruit"], "tl": ["drop(orange)", "imply", "pick_up(fruit)"], "masked_tl": ["prop_1", "imply", "prop_2"], "grounded_sentence": ["when", "prop_1", ",", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["fruit)"], "args_ref": ["fruit)"]}}, "prediction": "(prop_1) is true, then \"pick up fruit\" (prop_2) should eventually happen. This is captured by globally (G) stating that if prop_1 is true, then eventually (F) prop_2 will be true.\n\n2. *Explanation dictionary* \u2013 {\"when drop orange\": \"prop_1\", \"pick up fruit\": \"prop_2\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 5359, "sentence": ["if", "at", "some", "time", "take", "possession", "of", "bear", ",", "venture", "to", "trash", "can"], "tl": ["finally", "(", "take_possession_of(bear)", ")", "imply", "venture_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["if", "at", "some", "time", "prop_1", ",", "venture", "to", "trash", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(finally) the proposition \"take possession of bear\" (prop_1) becomes true. The phrase \"venture to trash can\" means that after that event, \"venture to trash can\" (prop_2) should happen. So, if eventually prop_1 happens, then eventually prop_2 should happen afterward. This can be expressed as: finally prop_1 implies finally prop_2.\n\n2. *Explanation dictionary* \u2013 {\"at some time take possession of bear\": \"F prop_1\", \"venture to trash can\": \"F prop_2\", \"if ... then ...\": \"F prop_1 implies F prop_2\"}\n\n3. *FINAL:* (F prop_1) implies (F prop_2)"}
{"id": 891, "sentence": ["collect", "pear", "or", "at", "any", "time", "contact", "house"], "tl": ["collect(pear)", "or", "finally", "(", "contact(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "any", "time", "contact", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "collect", "action_ref": "collect", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 2105, "sentence": ["when", "possible", "go", "visit", "house", "and", "move", "to", "trash", "can"], "tl": ["finally", "(", "go_visit(house)", ")", "and", "move_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(prop_1 and prop_2)\" to ensure that if it is possible, the actions happen eventually.\n\n2. *Explanation dictionary* \u2013\n{\n  \"go visit house\": \"prop_1\",\n  \"move to trash can\": \"prop_2\",\n  \"go visit house and move to trash can\": \"(prop_1 and prop_2)\",\n  \"when possible\": \"F\"\n}\n\n3. *FINAL:* F (prop_1 and prop_2)"}
{"id": 5548, "sentence": ["at", "any", "time", "venture", "house", "and", "whenever", "visit", "house"], "tl": ["finally", "(", "venture(house)", ")", "and", "finally", "(", "visit(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "whenever", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (G prop_1) and (G (prop_2 implies prop_1)) FINISH"}
{"id": 2348, "sentence": ["never", "drop", "apple", "and", "go", "by", "waste", "bin"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "and", "go_by(waste_bin)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "and", "prop_2"], "grounded_sentence": ["never", "prop_1", "and", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) and prop_2 FINISH"}
{"id": 4701, "sentence": ["at", "some", "time", "seize", "orange", "and", "take", "pear"], "tl": ["finally", "(", "seize(orange)", ")", "and", "take(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(finally). The actions \"seize orange\" and \"take pear\" are represented by propositions prop_1 and prop_2 respectively. The word \"and\" connects these two actions, so the formula states that eventually both prop_1 and prop_2 hold.\n\n2. *Explanation dictionary* \u2013 {\"at some time\": \"F\", \"seize orange\": \"prop_1\", \"take pear\": \"prop_2\", \"and\": \"and\"}\n\n3. *FINAL:* F (prop_1 and prop_2)"}
{"id": 3989, "sentence": ["at", "some", "time", "seize", "pear", "or", "hold", "on", "to", "pear"], "tl": ["finally", "(", "seize(pear)", ")", "or", "hold_on_to(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "hold_on_to", "action_ref": "hold on to", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or prop_2) FINISH"}
{"id": 6649, "sentence": ["whenever", "withold", "apple", "or", "at", "any", "time", "reach", "tree"], "tl": ["finally", "(", "withold(apple)", ")", "or", "finally", "(", "reach(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withold", "action_ref": "withold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 365, "sentence": ["at", "any", "time", "advance", "to", "house", "or", "at", "any", "time", "touch", "tree"], "tl": ["finally", "(", "advance_to(house)", ")", "or", "finally", "(", "touch(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "at", "any", "time", "touch", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 4126, "sentence": ["if", "when", "possible", "arrive", "at", "tree", ",", "take", "to", "trash", "can"], "tl": ["finally", "(", "arrive_at(tree)", ")", "imply", "take_to(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["if", "when", "possible", "prop_1", ",", "take", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "arrive_at", "action_ref": "arrive at", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "take_to", "action_ref": "take to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 4223, "sentence": ["never", "drop", "orange", "or", "at", "any", "time", "spend", "time", "at", "tree"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "or", "finally", "(", "spend_time_at(tree)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "any", "time", "spend", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) or (finally prop_2) FINISH"}
{"id": 3192, "sentence": ["do", "not", "let", "go", "orange", "and", "get", "to", "tree"], "tl": ["negation", "(", "let_go(orange)", ")", "and", "get_to(tree)"], "masked_tl": ["negation", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["do", "not", "prop_1", "and", "get", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (globally prop_1) and (finally prop_2) FINISH"}
{"id": 1104, "sentence": ["at", "any", "time", "go", "near", "flag", "or", "when", "possible", "go", "visit", "house"], "tl": ["finally", "(", "go_near(flag)", ")", "or", "finally", "(", "go_visit(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "go", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 3946, "sentence": ["when", "possible", "present", "at", "flag", "or", "never", "drop", "apple"], "tl": ["finally", "(", "present_at(flag)", ")", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "never", "drop", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (F prop_1) or (G (not prop_2)) FINISH"}
{"id": 4330, "sentence": ["secure", "apple", "or", "never", "drop", "apple"], "tl": ["secure(apple)", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 or globally (not prop_2)) FINISH"}
{"id": 4510, "sentence": ["when", "possible", "start", "going", "to", "house", "can", "infer", "that", "when", "possible", "grab", "flag"], "tl": ["finally", "(", "start_going_to(house)", ")", "imply", "finally", "(", "grab(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "can", "infer", "that", "when", "possible", "grab", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1), then we can infer that \"when possible grab flag\" (prop_2). The phrase \"when possible\" is interpreted as \"eventually\" (finally). So, \"when possible start going to house\" maps to F prop_1, and \"when possible grab flag\" maps to F prop_2. The command implies that whenever F prop_1 holds, then F prop_2 should also hold, so we use globally (G) and implies: G (F prop_1 \u2192 F prop_2).\n\n2. *Explanation dictionary* \u2013\n{\n  \"when possible start going to house\": \"F prop_1\",\n  \"when possible grab flag\": \"F prop_2\",\n  \"when possible start going to house implies when possible grab flag\": \"G (F prop_1 implies F prop_2)\"\n}\n\n3. *FINAL:* G (F prop_1 implies F prop_2)"}
{"id": 193, "sentence": ["at", "some", "time", "be", "near", "tree", "and", "at", "any", "time", "stop", "by", "trash", "can"], "tl": ["finally", "(", "be_near(tree)", ")", "and", "finally", "(", "stop_by(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "any", "time", "stop", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "(F prop_1), where prop_1 represents \"be near tree\". The phrase \"at any time stop by trash can\" corresponds to \"globally prop_2\" (G prop_2), where prop_2 represents \"stop by trash can\". The conjunction \"and\" connects these two temporal requirements.\n\n2. *Explanation dictionary* \u2013 {\"at some time be near tree\": \"F prop_1\", \"at any time stop by trash can\": \"G prop_2\"}\n\n3. *FINAL:* (F prop_1) and (G prop_2)"}
{"id": 5422, "sentence": ["whenever", "visit", "house", "or", "never", "drop", "orange"], "tl": ["finally", "(", "visit(house)", ")", "or", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* G (prop_1 or G (not prop_2)) FINISH"}
{"id": 6425, "sentence": ["whenever", "migrate", "to", "tree", "or", "reach", "house"], "tl": ["finally", "(", "migrate_to(tree)", ")", "or", "reach(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "reach", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "migrate_to", "action_ref": "migrate to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 4407, "sentence": ["whenever", "be", "in", "house's", "vicinity", "or", "at", "any", "time", "snag", "orange"], "tl": ["finally", "(", "be_in(house's_vicinity)", ")", "or", "finally", "(", "snag(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "snag", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_in", "action_ref": "be in", "args_canon": ["house's_vicinity)"], "args_ref": ["house's vicinity)"]}, "prop_2": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "- Combining these, the formula is: G((prop_1) \u2192 F(prop_2)) and G(F(prop_2))."}
{"id": 2820, "sentence": ["venture", "towards", "house", "or", "at", "some", "time", "present", "at", "flag"], "tl": ["venture_towards(house)", "or", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "present", "at", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 4469, "sentence": ["at", "some", "time", "go", "past", "house", "or", "repeatedly", "make", "way", "to", "house"], "tl": ["finally", "(", "go_past(house)", ")", "or", "globally", "(", "finally", "(", "make_way_to(house)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "repeatedly", "make", "way", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_past", "action_ref": "go past", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "make_way_to", "action_ref": "make way to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 5825, "sentence": ["when", "possible", "proceed", "to", "flag", "and", "at", "some", "time", "make", "contact", "with", "house"], "tl": ["finally", "(", "proceed_to(flag)", ")", "and", "finally", "(", "make_contact_with(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "some", "time", "make", "contact", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_1 implies prop_2) and (F prop_3) FINISH"}
{"id": 5358, "sentence": ["do", "not", "let", "go", "pear", "and", "at", "some", "time", "procure", "orange"], "tl": ["negation", "(", "let_go(pear)", ")", "and", "finally", "(", "procure(orange)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["do", "not", "prop_1", "and", "at", "some", "time", "procure", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (G(prop_1) and F(prop_2)) FINISH"}
{"id": 4281, "sentence": ["at", "some", "time", "getting", "pear", "and", "hold", "orange"], "tl": ["finally", "(", "getting(pear)", ")", "and", "hold(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "getting", "action_ref": "getting", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* finally (prop_1 and prop_2) FINISH"}
{"id": 7452, "sentence": ["if", "at", "some", "time", "go", "to", "trash", "receptacle", ",", "grasp", "orange"], "tl": ["finally", "(", "go_to(trash_receptacle)", ")", "imply", "grasp(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["if", "at", "some", "time", "prop_1", ",", "grasp", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 0, 1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_receptacle)"], "args_ref": ["trash receptacle)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(F) the proposition \"go to trash receptacle\" (prop_1) becomes true. The phrase \"grasp orange\" (prop_2) should then hold whenever that happens, so \"if eventually prop_1 then prop_2\" is expressed as \"F prop_1 implies prop_2\".\n\n2. *Explanation dictionary* \u2013 {\"at some time go to trash receptacle\": \"F prop_1\", \"grasp orange\": \"prop_2\", \"if ... then ...\": \"F prop_1 implies prop_2\"}\n\n3. *FINAL:* (F prop_1)"}
{"id": 2544, "sentence": ["when", "possible", "reach", "tree", "or", "whenever", "seize", "orange"], "tl": ["finally", "(", "reach(tree)", ")", "or", "finally", "(", "seize(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "whenever", "seize", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_2) happens, some condition holds. Since the command is \"when possible reach tree or whenever seize orange,\" the overall formula is a disjunction of these two temporal conditions: \"finally prop_1 or globally (prop_2 implies ... )\". However, since the command is a simple disjunction, and \"whenever seize orange\" can be interpreted as \"globally (prop_2 implies ... )\", but no further condition is specified, we interpret \"whenever seize orange\" as \"globally prop_2\" or simply \"prop_2 holds whenever it occurs\". To keep it consistent, we interpret \"whenever seize orange\" as \"globally (prop_2 implies true)\", which is just \"globally true\", so we just include \"globally prop_2\" to indicate that whenever seize orange happens, it is considered. Therefore, the formula is: (F prop_1)"}
{"id": 1277, "sentence": ["when", "possible", "visit", "flag", "and", "when", "possible", "go", "to", "trash", "bin"], "tl": ["finally", "(", "visit(flag)", ")", "and", "finally", "(", "go_to(trash_bin)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "(F prop_1)"}
{"id": 2250, "sentence": ["get", "to", "tree", "or", "always", "hold", "on", "pear"], "tl": ["get_to(tree)", "or", "globally", "(", "hold_on(pear)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "always", "hold", "on", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "hold_on", "action_ref": "hold on", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(representing \"tree\") is true, which is expressed as finally prop_1 (F prop_1).\n- \"always hold on pear\" means that prop_2 (representing \"pear\") holds globally (G prop_2).\n- The \"or\" connects these two conditions, so the overall formula is (F prop_1) or (G prop_2).\n\n2. *Explanation dictionary* \u2013\n{\"get to tree\" : \"F prop_1\", \"always hold on pear\" : \"G prop_2\", \"or\" : \"or\"}\n\n3. *FINAL:* (F prop_1) or (G prop_2)"}
{"id": 4662, "sentence": ["never", "drop", "pear", "or", "whenever", "grasp", "pear"], "tl": ["globally", "(", "negation", "(", "drop(pear)", ")", ")", "or", "finally", "(", "grasp(pear)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "whenever", "grasp", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(grasp pear) holds, then ...\". The command says \"never drop pear or whenever grasp pear\", which can be interpreted as \"either never drop pear, or whenever grasp pear\". This corresponds to the formula: (G (not prop_1)) or (G (prop_2 implies ...)). Since the command is incomplete after \"whenever grasp pear\", we interpret it as \"never drop pear or whenever grasp pear (something)\". Given only these phrases, the simplest interpretation is \"never drop pear or whenever grasp pear\", which is: (G (not prop_1)) or (G (prop_2)).\n\n2. *Explanation dictionary* \u2013\n{\n  \"never drop pear\": \"G (not prop_1)\",\n  \"drop pear\": \"prop_1\",\n  \"whenever grasp pear\": \"G (prop_2 implies ...)\",\n  \"grasp pear\": \"prop_2\",\n  \"never drop pear or whenever grasp pear\": \"(G (not prop_1))"}
{"id": 6094, "sentence": ["when", "possible", "withdraw", "pear", "or", "always", "hold", "on", "pear"], "tl": ["finally", "(", "withdraw(pear)", ")", "or", "globally", "(", "hold_on(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "always", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withdraw", "action_ref": "withdraw", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "hold_on", "action_ref": "hold on", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 5274, "sentence": ["whenever", "secure", "pear", "or", "when", "possible", "go", "visit", "house"], "tl": ["finally", "(", "secure(pear)", ")", "or", "finally", "(", "go_visit(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(interpreted as \"eventually\") \"go visit house\" holds.\n- The overall meaning is that whenever \"secure pear\" is true or \"go visit house\" is possible (eventually true), then some condition should hold. Since the command is not fully explicit about what should happen, the most natural interpretation is that whenever \"secure pear\" or \"go visit house\" is possible, then \"go visit house\" should eventually happen.\n- So, the formula expresses that globally, if \"secure pear\" holds or \"go visit house\" is possible (eventually), then \"go visit house\" will eventually happen.\n\n2. *Explanation dictionary* \u2013\n{\n  \"secure pear\": \"prop_1\",\n  \"go visit house\": \"prop_2\",\n  \"whenever ... or when possible ...\": \"G((prop_1 or F prop_2)"}
{"id": 5856, "sentence": ["repeatedly", "go", "to", "waste", "basket", "or", "at", "any", "time", "proceed", "to", "flag"], "tl": ["globally", "(", "finally", "(", "go_to(waste_basket)", ")", ")", "or", "finally", "(", "proceed_to(flag)", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "at", "any", "time", "proceed", "to", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(G F), meaning something happens infinitely often. The \"or\" connects the two possibilities. \"Go to waste basket\" and \"proceed to flag\" are represented by propositions prop_1 and prop_2 respectively.\n\n2. *Explanation dictionary* \u2013 {\"repeatedly go to waste basket\": \"G F prop_1\", \"at any time proceed to flag\": \"F prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (G F prop_1) or (F prop_2)"}
{"id": 4755, "sentence": ["never", "let", "go", "orange", "or", "when", "possible", "have", "possession", "of", "apple"], "tl": ["globally", "(", "negation", "(", "let_go(orange)", ")", ")", "or", "finally", "(", "have_possession_of(apple)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "when", "possible", "have", "possession", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "have_possession_of", "action_ref": "have possession of", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "- So, globally not prop_1 and finally prop_2: G (not prop_1) and F (prop_2)."}
{"id": 2302, "sentence": ["whenever", "venture", "to", "waste", "basket", "or", "at", "any", "time", "tax", "apple"], "tl": ["finally", "(", "venture_to(waste_basket)", ")", "or", "finally", "(", "tax(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "tax", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 4022, "sentence": ["travel", "to", "tree", "and", "when", "possible", "approach", "flag"], "tl": ["travel_to(tree)", "and", "finally", "(", "approach(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "approach", "flag", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1) and (G (prop_2 implies F prop_3)) FINISH"}
{"id": 423, "sentence": ["whenever", "contact", "flag", "or", "at", "any", "time", "move", "past", "trash", "can"], "tl": ["finally", "(", "contact(flag)", ")", "or", "finally", "(", "move_past(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "any", "time", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "move_past", "action_ref": "move past", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (prop_1 or globally prop_2) FINISH"}
{"id": 3228, "sentence": ["drop", "pear", "or", "at", "some", "time", "clutch", "orange"], "tl": ["drop(pear)", "or", "finally", "(", "clutch(orange)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "clutch", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "clutch", "action_ref": "clutch", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 3685, "sentence": ["whenever", "withdraw", "pear", "or", "at", "some", "time", "move", "near", "tree"], "tl": ["finally", "(", "withdraw(pear)", ")", "or", "finally", "(", "move_near(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "some", "time", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withdraw", "action_ref": "withdraw", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "move_near", "action_ref": "move near", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(F prop_2).\n- \"withdraw pear or at some time move near tree\" is prop_1 or F prop_2.\n- \"whenever\" indicates a globally condition, so globally (prop_1 or F prop_2).\n\n2. *Explanation dictionary* \u2013 {\"withdraw pear\": \"prop_1\", \"move near tree\": \"prop_2\", \"at some time move near tree\": \"F prop_2\", \"withdraw pear or at some time move near tree\": \"prop_1 or F prop_2\", \"whenever withdraw pear or at some time move near tree\": \"G (prop_1 or F prop_2)\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 4316, "sentence": ["when", "possible", "go", "to", "trashcan", "and", "travel", "to", "apple"], "tl": ["finally", "(", "go_to(trashcan)", ")", "and", "travel_to(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 implies (F prop_2 and F prop_3)) FINISH"}
{"id": 4727, "sentence": ["when", "possible", "present", "at", "flag", "until", "when", "possible", "reach", "flag"], "tl": ["finally", "(", "present_at(flag)", ")", "until", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "until", "when", "possible", "reach", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"until\": \"until\""}
{"id": 6051, "sentence": ["secure", "apple", "or", "venture", "towards", "house"], "tl": ["secure(apple)", "or", "venture_towards(house)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "venture", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (F (prop_1 or prop_2)) FINISH"}
{"id": 3453, "sentence": ["when", "possible", "reach", "flag", "can", "infer", "that", "when", "possible", "bring", "pear"], "tl": ["finally", "(", "reach(flag)", ")", "imply", "finally", "(", "bring(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "can", "infer", "that", "when", "possible", "bring", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* ((F prop_1) implies (F prop_2)) FINISH"}
{"id": 3222, "sentence": ["at", "any", "time", "go", "by", "waste", "basket", "or", "venture", "towards", "house"], "tl": ["finally", "(", "go_by(waste_basket)", ")", "or", "venture_towards(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "venture", "towards", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (globally (prop_1 or prop_2)) FINISH"}
{"id": 260, "sentence": ["go", "by", "waste", "bin", "until", "go", "by", "waste", "bin"], "tl": ["go_by(waste_bin)", "until", "go_by(waste_bin)"], "masked_tl": ["prop_2", "until", "prop_2"], "grounded_sentence": ["prop_1", "until", "go", "by", "waste", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "3. *FINAL:* (prop_1 until prop_1) FINISH"}
{"id": 2518, "sentence": ["at", "some", "time", "get", "hold", "apple", "or", "at", "some", "time", "seize", "orange"], "tl": ["finally", "(", "get_hold(apple)", ")", "or", "finally", "(", "seize(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "seize", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 2963, "sentence": ["forever", "moving", "or", "whenever", "venture", "flag"], "tl": ["globally", "(", "moving", ")", "or", "finally", "(", "venture(flag)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "whenever", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "moving", "action_ref": "moving", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1 or prop_2), where prop_1 represents \"moving\" and prop_2 represents \"venture flag.\"\n\n2. *Explanation dictionary* \u2013 {\"forever\": \"G\", \"moving\": \"prop_1\", \"venture flag\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 5389, "sentence": ["at", "some", "time", "go", "by", "house", "and", "whenever", "grasp", "pear"], "tl": ["finally", "(", "go_by(house)", ")", "and", "finally", "(", "grasp(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "whenever", "grasp", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(F prop_1), where prop_1 represents \"go by house\". The phrase \"whenever grasp pear\" means \"globally, if grasp pear then ...\" which translates to G (prop_2 \u2192 ...), where prop_2 represents \"grasp pear\". Since the command does not specify what should happen whenever grasp pear, we interpret \"whenever grasp pear\" as a condition that must always hold when grasp pear occurs, so we just include G prop_2 to represent that \"whenever grasp pear\" is true globally.\n\n2. *Explanation dictionary* \u2013 {\"at some time go by house\": \"F prop_1\", \"go by house\": \"prop_1\", \"whenever grasp pear\": \"G prop_2\", \"grasp pear\": \"prop_2\"}\n\n3. *FINAL:* (F prop_1) and (G prop_2)"}
{"id": 6293, "sentence": ["when", "possible", "venture", "flag", "or", "at", "any", "time", "stop", "by", "house"], "tl": ["finally", "(", "venture(flag)", ")", "or", "finally", "(", "stop_by(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "stop", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 4675, "sentence": ["travel", "to", "tree", "or", "at", "any", "time", "go", "home"], "tl": ["travel_to(tree)", "or", "finally", "(", "go(home)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "any", "time", "go", "home", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go", "action_ref": "go", "args_canon": ["home)"], "args_ref": ["home)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 3471, "sentence": ["at", "some", "time", "present", "at", "flag", "until", "at", "some", "time", "go", "by", "waste", "basket"], "tl": ["finally", "(", "present_at(flag)", ")", "until", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "until", "at", "some", "time", "go", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "(F prop_1), where prop_1 represents \"present at flag.\" The phrase \"until at some time go by waste basket\" corresponds to \"until F prop_2,\" where prop_2 represents \"go by waste basket.\" Combining these, the entire command means \"present at flag\" holds until eventually \"go by waste basket\" happens, which is expressed as (F prop_1) U (F prop_2).\n\n2. *Explanation dictionary* \u2013 {\"at some time present at flag\": \"F prop_1\", \"at some time go by waste basket\": \"F prop_2\", \"until\": \"U\"}\n\n3. *FINAL:* (F prop_1) U (F prop_2)"}
{"id": 347, "sentence": ["whenever", "show", "yourself", "near", "house", "and", "pick", "up", "orange"], "tl": ["finally", "(", "show_yourself_near(house)", ")", "and", "pick_up(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "pick", "up", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1 and prop_2) holds, something should follow. Since no explicit consequent is given, we interpret it as \"whenever the condition holds, it is true that the condition holds,\" which is tautological. More reasonably, the command likely means \"whenever you show yourself near the house, you pick up the orange,\" so \"whenever prop_1 then eventually prop_2.\" But the command says \"and,\" so both happen together. To capture \"whenever you show yourself near house and pick up orange,\" we can say globally (prop_1 and prop_2) holds. Alternatively, if the command is a trigger, \"whenever prop_1 then eventually prop_2\" is more natural. Since the command is \"whenever show yourself near house and pick up orange,\" it is likely a conjunction of two events that should always happen together. So the formula is globally (prop_1 and prop_2)"}
{"id": 3431, "sentence": ["when", "don't", "let", "go", "orange", ",", "when", "possible", "lay", "hold", "of", "apple"], "tl": ["negation", "(", "let_go(orange)", ")", "imply", "finally", "(", "lay_hold_of(apple)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "don't", "prop_1", ",", "when", "possible", "lay", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "lay_hold_of", "action_ref": "lay hold of", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(i.e., \"not prop_1\"), something should hold. The phrase \"when possible lay hold of apple\" means that eventually \"apple\" should be held (i.e., eventually prop_2). Combining these, we specify that globally, if \"orange\" is not let go, then eventually \"apple\" will be held.\n\n2. *Explanation dictionary* \u2013\n{\n  \"don't let go orange\": \"not prop_1\",\n  \"possible lay hold of apple\": \"F prop_2\",\n  \"when don't let go orange, when possible lay hold of apple\": \"G (not prop_1 implies F prop_2)\"\n}\n\n3. *FINAL:* G (not prop_1 implies F prop_2)"}
{"id": 2521, "sentence": ["capture", "orange", "or", "at", "some", "time", "secure", "pear"], "tl": ["capture(orange)", "or", "finally", "(", "secure(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "secure", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(F).\n\n2. *Explanation dictionary* \u2013\n{\"capture orange\": \"prop_1\", \"secure pear\": \"prop_2\", \"or\": \"or\", \"at some time\": \"finally (F)\"}\n\n3. *FINAL:* F (prop_1 or prop_2)"}
{"id": 3592, "sentence": ["at", "some", "time", "withhold", "apple", "and", "at", "some", "time", "reach", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "some", "time", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (finally prop_1) and (finally prop_2) FINISH"}
{"id": 3804, "sentence": ["keep", "apple", "until", "at", "any", "time", "start", "going", "to", "house"], "tl": ["keep(apple)", "until", "finally", "(", "start_going_to(house)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "at", "any", "time", "start", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "keep", "action_ref": "keep", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(representing \"apple\") should hold continuously until another condition becomes true. The phrase \"at any time start going to house\" means that eventually (at some future point) prop_2 (representing \"start going to house\") will become true. Combining these, the formula states that prop_1 holds until prop_2 occurs, and prop_2 will eventually occur.\n\n2. *Explanation dictionary* \u2013\n{\n  \"keep apple\": \"prop_1\",\n  \"at any time start going to house\": \"F prop_2\",\n  \"keep apple until at any time start going to house\": \"prop_1 U prop_2\"\n}\n\n3. *FINAL:* (prop_1 U prop_2)"}
{"id": 5352, "sentence": ["at", "any", "time", "journey", "to", "flag", "or", "forever", "hold", "onto", "orange"], "tl": ["finally", "(", "journey_to(flag)", ")", "or", "globally", "(", "hold_onto(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "forever", "hold", "onto", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(G prop_2). \"Journey to flag\" eventually happens translates to finally prop_1 (F prop_1). The \"or\" connects these two conditions. So the entire formula is globally (F prop_1 or G prop_2).\n\n2. *Explanation dictionary* \u2013\n{\n  \"at any time\": \"G\",\n  \"journey to flag\": \"prop_1\",\n  \"forever hold onto orange\": \"G prop_2\",\n  \"journey to flag or forever hold onto orange\": \"(F prop_1 or G prop_2)\"\n}\n\n3. *FINAL:* G (F prop_1 or G prop_2)"}
{"id": 6684, "sentence": ["hold", "orange", "or", "go", "to", "bucket"], "tl": ["hold(orange)", "or", "go_to(bucket)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}}, "prediction": "3. *FINAL:* (prop_1 or prop_2) FINISH"}
{"id": 3940, "sentence": ["venture", "to", "trash", "can", "or", "hold", "pear"], "tl": ["venture_to(trash_can)", "or", "hold(pear)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "hold", "pear", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 4973, "sentence": ["snatch", "up", "pear", "and", "get", "to", "tree"], "tl": ["snatch_up(pear)", "and", "get_to(tree)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "get", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snatch_up", "action_ref": "snatch up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "get_to", "action_ref": "get to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(F prop_1) and (F prop_2)"}
{"id": 6886, "sentence": ["at", "any", "time", "take", "possession", "of", "bear", "or", "when", "possible", "travel", "to", "house"], "tl": ["finally", "(", "take_possession_of(bear)", ")", "or", "finally", "(", "travel_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "travel", "to", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or finally prop_2) FINISH"}
{"id": 612, "sentence": ["do", "not", "let", "go", "pear", "or", "at", "any", "time", "venture", "flag"], "tl": ["negation", "(", "let_go(pear)", ")", "or", "finally", "(", "venture(flag)", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["do", "not", "prop_1", "or", "at", "any", "time", "venture", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* globally (not (prop_1 or prop_2)) FINISH"}
{"id": 1739, "sentence": ["at", "any", "time", "set", "out", "to", "house", "or", "go", "visit", "flag"], "tl": ["finally", "(", "set_out_to(house)", ")", "or", "go_visit(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "go", "visit", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "set_out_to", "action_ref": "set out to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(G), meaning the property must hold at all times. The phrase \"set out to house or go visit flag\" corresponds to the disjunction \"prop_1 or prop_2\", where prop_1 represents \"set out to house\" and prop_2 represents \"go visit flag\". Combining these, the formula states that globally, either prop_1 or prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"G\", \"set out to house\": \"prop_1\", \"go visit flag\": \"prop_2\", \"set out to house or go visit flag\": \"(prop_1 or prop_2)\"}\n\n3. *FINAL:* G(prop_1 or prop_2)"}
{"id": 3961, "sentence": ["at", "some", "time", "go", "to", "trashcan", "or", "keep", "apple"], "tl": ["finally", "(", "go_to(trashcan)", ")", "or", "keep(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "keep", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "keep", "action_ref": "keep", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 7433, "sentence": ["if", "always", "have", "in", "orange", ",", "at", "any", "time", "journey", "by", "flag"], "tl": ["globally", "(", "have_in(orange)", ")", "imply", "finally", "(", "journey_by(flag)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "always", "prop_1", ",", "at", "any", "time", "journey", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (globally prop_1) implies (finally prop_2) FINISH"}
{"id": 3580, "sentence": ["when", "possible", "go", "to", "trash", "can", "and", "at", "any", "time", "journey", "to", "flag"], "tl": ["finally", "(", "go_to(trash_can)", ")", "and", "finally", "(", "journey_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "any", "time", "journey", "to", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "journey_to", "action_ref": "journey to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"and\": \"and\","}
{"id": 1776, "sentence": ["at", "some", "time", "have", "pear", "or", "at", "any", "time", "start", "going", "to", "house"], "tl": ["finally", "(", "have(pear)", ")", "or", "finally", "(", "start_going_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "any", "time", "start", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(F prop_1), where prop_1 represents \"have pear\". The phrase \"or at any time start going to house\" corresponds to \"always prop_2\" (G prop_2), where prop_2 represents \"start going to house\". The entire command is the disjunction of these two temporal properties: \"eventually prop_1 or always prop_2\".\n\n2. *Explanation dictionary* \u2013 {\"at some time have pear\": \"F prop_1\", \"at any time start going to house\": \"G prop_2\"}\n\n3. *FINAL:* (F prop_1) or (G prop_2)"}
{"id": 3071, "sentence": ["secure", "apple", "or", "at", "some", "time", "withhold", "apple"], "tl": ["secure(apple)", "or", "finally", "(", "withhold(apple)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "withhold", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 53, "sentence": ["always", "touch", "flag", "or", "at", "any", "time", "go", "to", "trash", "bin"], "tl": ["globally", "(", "touch(flag)", ")", "or", "finally", "(", "go_to(trash_bin)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "or", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}}, "prediction": "3. *FINAL:* (globally prop_1) or (finally prop_2) FINISH"}
{"id": 3691, "sentence": ["at", "any", "time", "lay", "hold", "of", "apple", "or", "go", "to", "orange", "bin"], "tl": ["finally", "(", "lay_hold_of(apple)", ")", "or", "go_to(orange_bin)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "go", "to", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "lay_hold_of", "action_ref": "lay hold of", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange_bin)"], "args_ref": ["orange bin)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 4782, "sentence": ["at", "any", "time", "snag", "orange", "and", "approach", "trash", "can"], "tl": ["finally", "(", "snag(orange)", ")", "and", "approach(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "approach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "snag", "action_ref": "snag", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* globally (prop_1 and prop_2) FINISH"}
{"id": 7024, "sentence": ["at", "some", "time", "travel", "to", "trash", "can", "or", "at", "any", "time", "get", "hold", "apple"], "tl": ["finally", "(", "travel_to(trash_can)", ")", "or", "finally", "(", "get_hold(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "any", "time", "get", "hold", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "  \"or\": \"or\","}
{"id": 361, "sentence": ["at", "some", "time", "withhold", "apple", "or", "at", "some", "time", "present", "at", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "or", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "at", "some", "time", "present", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(F), indicating that something will happen eventually. The phrase \"withhold apple\" is represented by a proposition, say prop_1. The phrase \"present at flag\" is represented by another proposition, say prop_2. The command states \"at some time withhold apple or at some time present at flag,\" which translates to \"finally prop_1 or finally prop_2.\"\n\n2. *Explanation dictionary* \u2013 {\"at some time\": \"F\", \"withhold apple\": \"prop_1\", \"present at flag\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 6586, "sentence": ["move", "to", "trashcan", "or", "when", "possible", "migrate", "to", "tree"], "tl": ["move_to(trashcan)", "or", "finally", "(", "migrate_to(tree)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "migrate", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}, "prop_2": {"action_canon": "migrate_to", "action_ref": "migrate to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (prop_1 or finally prop_2) FINISH"}
{"id": 2331, "sentence": ["never", "let", "go", "or", "at", "any", "time", "go", "to", "tree"], "tl": ["globally", "(", "negation", "(", "let_go", ")", ")", "or", "finally", "(", "go_to(tree)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "any", "time", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (G (not prop_1)) or (F prop_2) FINISH"}
{"id": 6639, "sentence": ["when", "possible", "show", "yourself", "near", "house", "and", "when", "possible", "pick", "up", "apple"], "tl": ["finally", "(", "show_yourself_near(house)", ")", "and", "finally", "(", "pick_up(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "pick", "up", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(finally, F). \"show yourself near house\" is represented by prop_1. \"pick up apple\" is represented by prop_2. The command says: eventually show yourself near house, and eventually pick up apple. Both should hold globally, so the formula is the conjunction of two finally operators.\n\n2. *Explanation dictionary* \u2013 {\"when possible\": \"F\", \"show yourself near house\": \"prop_1\", \"pick up apple\": \"prop_2\"}\n\n3. *FINAL:* (F prop_1) and (F prop_2)"}
{"id": 5343, "sentence": ["reach", "house", "or", "when", "possible", "journey", "by", "flag"], "tl": ["reach(house)", "or", "finally", "(", "journey_by(flag)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "when", "possible", "journey", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "  \"or\": \"or\""}
{"id": 5509, "sentence": ["come", "to", "tree", "or", "forever", "have", "in", "orange"], "tl": ["come_to(tree)", "or", "globally", "(", "have_in(orange)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "forever", "have", "in", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "come_to", "action_ref": "come to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (globally prop_2) FINISH"}
{"id": 2727, "sentence": ["approach", "tree", "or", "whenever", "make", "way", "for", "tree"], "tl": ["approach(tree)", "or", "finally", "(", "make_way_for(tree)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "make", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "make_way_for", "action_ref": "make way for", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (prop_1 or (globally (prop_2 implies prop_1))) FINISH"}
{"id": 5477, "sentence": ["at", "any", "time", "withhold", "apple", "or", "whenever", "present", "at", "flag"], "tl": ["finally", "(", "withhold(apple)", ")", "or", "finally", "(", "present_at(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "whenever", "present", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "present_at", "action_ref": "present at", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(always) the proposition \"withhold apple\" holds. We can represent \"withhold apple\" as prop_1. The phrase \"or whenever present at flag\" means that whenever \"present at flag\" (prop_2) holds, the formula is true. Since \"or\" connects these two parts, the overall formula is \"globally prop_1 or prop_2\".\n\n2. *Explanation dictionary* \u2013 {\"at any time withhold apple\": \"G prop_1\", \"whenever present at flag\": \"prop_2\"}\n\n3. *FINAL:* (G prop_1)"}
{"id": 6082, "sentence": ["at", "some", "time", "get", "apple", "or", "take", "orange"], "tl": ["finally", "(", "get(apple)", ")", "or", "take(orange)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "take", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or prop_2) FINISH"}
{"id": 1246, "sentence": ["at", "some", "time", "make", "to", "flag", "or", "come", "to", "tree"], "tl": ["finally", "(", "make_to(flag)", ")", "or", "come_to(tree)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "come", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_to", "action_ref": "make to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "come_to", "action_ref": "come to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or prop_2) FINISH"}
{"id": 2732, "sentence": ["go", "to", "orange", "bin", "until", "whenever", "migrate", "to", "tree"], "tl": ["go_to(orange_bin)", "until", "finally", "(", "migrate_to(tree)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "whenever", "migrate", "to", "tree", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange_bin)"], "args_ref": ["orange bin)"]}, "prop_2": {"action_canon": "migrate_to", "action_ref": "migrate to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(always) condition. The phrase \"until\" indicates that the first action (go to orange bin) should continue until the second action (migrate to tree) occurs. So, the formula states that globally, prop_1 holds until prop_2 occurs.\n\n2. *Explanation dictionary* \u2013 {\"go to orange bin\": \"prop_1\", \"migrate to tree\": \"prop_2\", \"until\": \"U\", \"whenever\": \"G\"}\n\n3. *FINAL:* G (prop_1 U prop_2)"}
{"id": 2199, "sentence": ["when", "possible", "journey", "by", "flag", "and", "at", "some", "time", "spend", "time", "at", "tree"], "tl": ["finally", "(", "journey_by(flag)", ")", "and", "finally", "(", "spend_time_at(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "some", "time", "spend", "time", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "journey_by", "action_ref": "journey by", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 3938, "sentence": ["whenever", "show", "yourself", "near", "house", "and", "when", "possible", "take", "possession", "of", "bear"], "tl": ["finally", "(", "show_yourself_near(house)", ")", "and", "finally", "(", "take_possession_of(bear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "when", "possible", "take", "possession", "of", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "show_yourself_near", "action_ref": "show yourself near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}}, "prediction": "(show yourself near house) holds, then something follows.\n- \"and when possible take possession of bear\" means: if it is possible to take possession of bear, then eventually prop_2 (take possession of bear) should happen.\n- Combining these: globally, if prop_1 holds, then eventually prop_2 should hold.\n\n2. Explanation dictionary:\n{\n  \"show yourself near house\": \"prop_1\",\n  \"take possession of bear\": \"prop_2\",\n  \"whenever show yourself near house\": \"G (prop_1 implies F prop_2)\"\n}\n\n3. FINAL: G (prop_1 implies F prop_2)"}
{"id": 2541, "sentence": ["procure", "apple", "and", "pick", "up", "orange"], "tl": ["procure(apple)", "and", "pick_up(orange)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "pick", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 and prop_2) FINISH"}
{"id": 5634, "sentence": ["at", "any", "time", "go", "near", "house", "and", "at", "any", "time", "grab", "flag"], "tl": ["finally", "(", "go_near(house)", ")", "and", "finally", "(", "grab(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "any", "time", "grab", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (globally prop_1) and (globally prop_2) FINISH"}
{"id": 3909, "sentence": ["always", "have", "apple", "and", "at", "some", "time", "acquire", "pear"], "tl": ["globally", "(", "have(apple)", ")", "and", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "and", "at", "some", "time", "acquire", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(G prop_1) and (F prop_2)"}
{"id": 6198, "sentence": ["grasp", "orange", "or", "at", "some", "time", "getting", "pear"], "tl": ["grasp(orange)", "or", "finally", "(", "getting(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "getting", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "getting", "action_ref": "getting", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (F (prop_1 or prop_2)) FINISH"}
{"id": 3269, "sentence": ["whenever", "steal", "apple", "or", "go", "to", "bucket"], "tl": ["finally", "(", "steal(apple)", ")", "or", "go_to(bucket)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "steal", "action_ref": "steal", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}}, "prediction": "3. *FINAL:* globally not (prop_1 or prop_2) FINISH"}
{"id": 2095, "sentence": ["when", "possible", "secure", "pear", "or", "never", "drop", "apple"], "tl": ["finally", "(", "secure(pear)", ")", "or", "globally", "(", "negation", "(", "drop(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or globally (not prop_2)) FINISH"}
{"id": 343, "sentence": ["hold", "apple", "and", "at", "any", "time", "obtain", "apple"], "tl": ["hold(apple)", "and", "finally", "(", "obtain(apple)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "at", "any", "time", "obtain", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold", "action_ref": "hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 and finally prop_2) FINISH"}
{"id": 4393, "sentence": ["when", "possible", "withold", "apple", "or", "when", "possible", "get", "apple"], "tl": ["finally", "(", "withold(apple)", ")", "or", "finally", "(", "get(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "get", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withold", "action_ref": "withold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "get", "action_ref": "get", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(or)"}
{"id": 865, "sentence": ["at", "any", "time", "secure", "pear", "until", "visit", "tree"], "tl": ["finally", "(", "secure(pear)", ")", "until", "visit(tree)"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "until", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 until prop_2) FINISH"}
{"id": 3649, "sentence": ["whenever", "grab", "apple", "until", "at", "any", "time", "grasp", "apple"], "tl": ["finally", "(", "grab(apple)", ")", "until", "finally", "(", "grasp(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "until", "at", "any", "time", "grasp", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(grab apple) holds, something must follow. The phrase \"until at any time grasp apple\" suggests that this condition holds until at some point in the future (eventually) prop_2 (grasp apple) becomes true. So, the formula expresses that prop_1 holds until eventually prop_2 holds.\n\n2. *Explanation dictionary* \u2013 {\"whenever grab apple\": \"prop_1\", \"until at any time grasp apple\": \"prop_1 U F prop_2\"}\n\n3. *FINAL:* (prop_1 U F prop_2)"}
{"id": 627, "sentence": ["at", "any", "time", "travel", "to", "house", "and", "when", "possible", "travel", "house"], "tl": ["finally", "(", "travel_to(house)", ")", "and", "finally", "(", "travel(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "when", "possible", "travel", "house", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel", "action_ref": "travel", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* G (prop_1 and (prop_2 implies prop_1)) FINISH"}
{"id": 1569, "sentence": ["repeatedly", "go", "to", "pear", "and", "put", "in", "bin"], "tl": ["globally", "(", "finally", "(", "go_to(pear)", ")", ")", "and", "put_in(bin)"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "and", "prop_2"], "grounded_sentence": ["repeatedly", "prop_1", "and", "put", "in", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bin)"], "args_ref": ["bin)"]}}, "prediction": "(prop_1 and prop_2). \"Repeatedly\" means this should happen infinitely often, which is captured by globally finally: G F (prop_1 and prop_2).\n\n2. *Explanation dictionary* \u2013 {\"go to pear\": \"prop_1\", \"put in bin\": \"prop_2\", \"go to pear and put in bin\": \"(prop_1 and prop_2)\", \"repeatedly\": \"G F\"}\n\n3. *FINAL:* G F (prop_1 and prop_2)"}
{"id": 1040, "sentence": ["hold", "on", "to", "pear", "or", "whenever", "reach", "tree"], "tl": ["hold_on_to(pear)", "or", "finally", "(", "reach(tree)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "reach", "tree", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold_on_to", "action_ref": "hold on to", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (globally(prop_1) or globally(prop_2 implies prop_1)) FINISH"}
{"id": 568, "sentence": ["whenever", "tax", "apple", "or", "when", "possible", "go", "to", "apple"], "tl": ["finally", "(", "tax(apple)", ")", "or", "finally", "(", "go_to(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* G((prop_1 or prop_2) implies F prop_3) FINISH"}
{"id": 7086, "sentence": ["repeatedly", "go", "to", "pear", "or", "whenever", "procure", "pear"], "tl": ["globally", "(", "finally", "(", "go_to(pear)", ")", ")", "or", "finally", "(", "procure(pear)", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "whenever", "procure", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 6475, "sentence": ["do", "not", "let", "go", "pear", "and", "repeatedly", "grab", "tree"], "tl": ["negation", "(", "let_go(pear)", ")", "and", "globally", "(", "finally", "(", "grab(tree)", ")", ")"], "masked_tl": ["negation", "(", "prop_1", ")", "and", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["do", "not", "prop_1", "and", "repeatedly", "grab", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(G) prop_1, where prop_1 stands for \"holding pear\". The phrase \"repeatedly grab tree\" means that \"tree\" should be grabbed infinitely often, which can be expressed as \"globally finally\" (G F) prop_2, where prop_2 stands for \"grabbing tree\".\n\n2. *Explanation dictionary* \u2013 {\"do not let go pear\": \"G prop_1\", \"repeatedly grab tree\": \"G F prop_2\"}\n\n3. *FINAL:* (G prop_1) and (G F prop_2)"}
{"id": 3083, "sentence": ["whenever", "venture", "flag", "or", "travel", "to", "apple"], "tl": ["finally", "(", "venture(flag)", ")", "or", "travel_to(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture", "action_ref": "venture", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(G) condition. The condition is \"venture flag or travel to apple,\" which can be represented as (prop_1 or prop_2). The formula states that globally, if (venture flag or travel to apple) holds, then some property should hold. Since the command is incomplete about what should happen after, we interpret it as \"whenever (venture flag or travel to apple) happens,\" so the formula is simply G(prop_1 or prop_2).\n\n2. *Explanation dictionary* \u2013 {\"whenever\": \"G\", \"venture flag\": \"prop_1\", \"travel to apple\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G(prop_1 or prop_2)"}
{"id": 6294, "sentence": ["put", "in", "bucket", "or", "at", "any", "time", "go", "to", "tree"], "tl": ["put_in(bucket)", "or", "finally", "(", "go_to(tree)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "any", "time", "go", "to", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(F) operator on both propositions and combine them with or.\n\n2. *Explanation dictionary* \u2013 {\"put in bucket\": \"prop_1\", \"go to tree\": \"prop_2\", \"or\": \"or\", \"at any time\": \"F\"}\n\n3. *FINAL:* (F prop_1) or (F prop_2)"}
{"id": 2139, "sentence": ["whenever", "visit", "house", "or", "whenever", "start", "going", "to", "tree"], "tl": ["finally", "(", "visit(house)", ")", "or", "finally", "(", "start_going_to(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "whenever", "start", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "start_going_to", "action_ref": "start going to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (globally (prop_1)) or (globally (prop_2)) FINISH"}
{"id": 3045, "sentence": ["whenever", "contact", "house", "or", "stop", "by", "flag"], "tl": ["finally", "(", "contact(house)", ")", "or", "stop_by(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "stop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "stop_by", "action_ref": "stop by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(G) implication: globally, if (contact house or stop by flag) holds, then something follows. Since no consequent is given, we interpret the command as \"whenever (contact house or stop by flag) happens, it is true that (contact house or stop by flag) happens,\" which is tautological. Alternatively, if the command is just to express the occurrence of these events, we can write G((prop_1 or prop_2) implies (prop_1 or prop_2))"}
{"id": 186, "sentence": ["when", "possible", "withhold", "apple", "and", "when", "possible", "withhold", "apple"], "tl": ["finally", "(", "withhold(apple)", ")", "and", "finally", "(", "withhold(apple)", ")"], "masked_tl": ["finally", "(", "prop_2", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "when", "possible", "withhold", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "withhold", "action_ref": "withhold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1 \u2192 F prop_1)\"}\n\n3. *FINAL:* G (prop_1 \u2192 F prop_1) and G (prop_1 \u2192 F prop_1)"}
{"id": 3661, "sentence": ["at", "any", "time", "walk", "to", "flag", "or", "never", "let", "go", "apple"], "tl": ["finally", "(", "walk_to(flag)", ")", "or", "globally", "(", "negation", "(", "let_go(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "never", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* G (prop_1 or G (not prop_2)) FINISH"}
{"id": 5291, "sentence": ["when", "when", "possible", "let", "go", "apple", ",", "at", "some", "time", "move", "to", "flag"], "tl": ["finally", "(", "let_go(apple)", ")", "imply", "finally", "(", "move_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "when", "possible", "prop_1", ",", "at", "some", "time", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (F prop_1) implies (F prop_2 and"}
{"id": 4919, "sentence": ["never", "let", "go", "apple", "or", "approach", "tree"], "tl": ["globally", "(", "negation", "(", "let_go(apple)", ")", ")", "or", "approach(tree)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "prop_2"], "grounded_sentence": ["never", "prop_1", "or", "approach", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (not (prop_1 or prop_2)) FINISH"}
{"id": 6710, "sentence": ["at", "any", "time", "approach", "flag", "or", "put", "in", "apple", "bucket"], "tl": ["finally", "(", "approach(flag)", ")", "or", "put_in(apple_bucket)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "put", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "put_in", "action_ref": "put in", "args_canon": ["apple_bucket)"], "args_ref": ["apple bucket)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 2394, "sentence": ["when", "possible", "get", "close", "tree", "or", "at", "any", "time", "grab", "orange"], "tl": ["finally", "(", "get_close(tree)", ")", "or", "finally", "(", "grab(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "grab", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_close", "action_ref": "get close", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (globally prop_2) FINISH"}
{"id": 6256, "sentence": ["when", "possible", "be", "near", "tree", "and", "at", "some", "time", "procure", "orange"], "tl": ["finally", "(", "be_near(tree)", ")", "and", "finally", "(", "procure(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "some", "time", "procure", "orange", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(i.e., \"be near tree\" can happen), then eventually \"procure orange\" should happen. This can be captured by: if \"be near tree\" is possible (i.e., eventually true), then eventually \"procure orange\" happens. Formally: (F prop_1) implies (F prop_2).\n\n2. *Explanation dictionary* \u2013 {\"be near tree\": \"prop_1\", \"procure orange\": \"prop_2\", \"at some time procure orange\": \"F prop_2\", \"when possible be near tree\": \"F prop_1\", \"when possible be near tree and at some time procure orange\": \"(F prop_1) implies (F prop_2)\"}\n\n3. *FINAL:* (F prop_1) implies (F prop_2)"}
{"id": 1829, "sentence": ["approach", "tree", "or", "at", "some", "time", "acquire", "pear"], "tl": ["approach(tree)", "or", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "at", "some", "time", "acquire", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(finally) prop_2 (acquire pear) will be true. The \"or\" connects these two conditions, so the formula states that either prop_1 is true now or eventually prop_2 will be true.\n\n2. *Explanation dictionary* \u2013 {\"approach tree\": \"prop_1\", \"at some time acquire pear\": \"F prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* (prop_1 or F prop_2)"}
{"id": 7284, "sentence": ["always", "have", "apple", "or", "whenever", "go", "to", "flag"], "tl": ["globally", "(", "have(apple)", ")", "or", "finally", "(", "go_to(flag)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "or", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(apple) is true globally: G prop_1.\n- \"whenever go to flag\" means that whenever prop_2 (go to flag) occurs, some condition holds. Since the phrase is \"always have apple or whenever go to flag,\" it suggests that either apple is always true, or whenever go to flag happens, something else is true.\n- The phrase is ambiguous, but the most natural interpretation is: \"Either always have apple, or whenever go to flag happens, something else holds.\" Since no other condition is specified, the simplest is to say: \"Always (apple or (go to flag implies ...))\"\n- Since no further condition is given after \"whenever go to flag,\" the best is to interpret \"always have apple or whenever go to flag\" as \"always (apple or (go to flag implies true))\" which simplifies to \"always (apple or not go to flag or true)\" which is always true.\n- Alternatively, the phrase can be interpreted as \"Always (apple or whenever go to flag)"}
{"id": 6252, "sentence": ["pick", "up", "flag", "or", "always", "hold", "onto", "orange"], "tl": ["pick_up(flag)", "or", "globally", "(", "hold_onto(orange)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "always", "hold", "onto", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (finally(prop_1) or globally(prop_2)) FINISH"}
{"id": 724, "sentence": ["when", "possible", "touch", "tree", "and", "reach", "trash", "can"], "tl": ["finally", "(", "touch(tree)", ")", "and", "reach(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "reach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (finally prop_1) implies (finally prop_2) FINISH"}
{"id": 3121, "sentence": ["when", "possible", "reach", "flag", "and", "venture", "towards", "house"], "tl": ["finally", "(", "reach(flag)", ")", "and", "venture_towards(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "and", "venture", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (F prop_1) implies (F prop_1 and F prop_2) FINISH"}
{"id": 2991, "sentence": ["at", "some", "time", "go", "near", "house", "or", "keep", "apple"], "tl": ["finally", "(", "go_near(house)", ")", "or", "keep(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "keep", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "keep", "action_ref": "keep", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 784, "sentence": ["at", "some", "time", "go", "by", "waste", "basket", "and", "whenever", "reach", "flag"], "tl": ["finally", "(", "go_by(waste_basket)", ")", "and", "finally", "(", "reach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "whenever", "reach", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "reach", "action_ref": "reach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(finally) the proposition representing \"go by waste basket\" (prop_1) will be true: F prop_1. The phrase \"whenever reach flag\" means that globally (always), if \"reach flag\" (prop_2) is true, then some condition holds. Since the command does not specify what should happen whenever \"reach flag\" is true, we interpret it as a condition that whenever prop_2 holds, prop_1 should also hold at that time or in the future. To capture \"whenever reach flag,\" we use globally (G) and implies: G (prop_2 implies ...). Since the command is ambiguous about what should happen after reaching the flag, we assume that whenever the flag is reached, the robot should have gone by the waste basket at some time (possibly before or after). To express that, we can say that whenever prop_2 holds, eventually prop_1 holds: G (prop_2 implies F prop_1)"}
{"id": 3362, "sentence": ["whenever", "advance", "to", "house", "or", "at", "some", "time", "take", "possession", "of", "bear"], "tl": ["finally", "(", "advance_to(house)", ")", "or", "finally", "(", "take_possession_of(bear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "at", "some", "time", "take", "possession", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}}, "prediction": "3. *FINAL:* (globally prop_1) or (finally prop_2) FINISH"}
{"id": 1912, "sentence": ["never", "let", "go", "or", "whenever", "grab", "orange"], "tl": ["globally", "(", "negation", "(", "let_go", ")", ")", "or", "finally", "(", "grab(orange)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "whenever", "grab", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "let_go", "action_ref": "let go", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* globally (not prop_1 or prop_2) FINISH"}
{"id": 2889, "sentence": ["whenever", "go", "to", "trash", "can", "or", "take", "apple"], "tl": ["finally", "(", "go_to(trash_can)", ")", "or", "take(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "take", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "take", "action_ref": "take", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 6174, "sentence": ["forever", "have", "apple", "or", "at", "any", "time", "travel", "to", "flag"], "tl": ["globally", "(", "have(apple)", ")", "or", "finally", "(", "travel_to(flag)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "at", "any", "time", "travel", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1 or F prop_2).\n\n2. *Explanation dictionary* \u2013 {\"forever\": \"G\", \"have apple\": \"prop_1\", \"or\": \"or\", \"at any time\": \"F\", \"travel to flag\": \"prop_2\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 3048, "sentence": ["when", "possible", "grasp", "pear", "can", "infer", "that", "whenever", "go", "to", "flag"], "tl": ["finally", "(", "grasp(pear)", ")", "imply", "finally", "(", "go_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "can", "infer", "that", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 implies (G prop_2)) FINISH"}
{"id": 2998, "sentence": ["at", "some", "time", "scoop", "up", "pear", "or", "whenever", "travel", "by", "tree"], "tl": ["finally", "(", "scoop_up(pear)", ")", "or", "finally", "(", "travel_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "or", "whenever", "travel", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "travel_by", "action_ref": "travel by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (globally prop"}
{"id": 7219, "sentence": ["seize", "apple", "or", "forever", "touch", "flag"], "tl": ["seize(apple)", "or", "globally", "(", "touch(flag)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "forever", "touch", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "touch", "action_ref": "touch", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 or globally prop_2) FINISH"}
{"id": 1775, "sentence": ["at", "some", "time", "obtain", "apple", "and", "visit", "tree"], "tl": ["finally", "(", "obtain(apple)", ")", "and", "visit(tree)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 and prop_2)) FINISH"}
{"id": 7250, "sentence": ["when", "possible", "procure", "orange", "and", "at", "any", "time", "pick", "up", "peach"], "tl": ["finally", "(", "procure(orange)", ")", "and", "finally", "(", "pick_up(peach)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "and", "at", "any", "time", "pick", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "procure", "action_ref": "procure", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["peach)"], "args_ref": ["peach)"]}}, "prediction": "(finally). So \"when possible procure orange\" maps to \"finally prop_1\" where prop_1 = procure orange. The phrase \"at any time pick up peach\" means that at all times, pick up peach is possible, so \"globally prop_2\" where prop_2 = pick up peach. The conjunction \"and\" connects these two parts.\n\n2. *Explanation dictionary* \u2013 {\"when possible procure orange\": \"F prop_1\", \"procure orange\": \"prop_1\", \"at any time pick up peach\": \"G prop_2\", \"pick up peach\": \"prop_2\", \"and\": \"and\"}\n\n3. *FINAL:* (F prop_1) and (G prop_2)"}
{"id": 6054, "sentence": ["whenever", "go", "near", "pear", "and", "move", "to", "tree"], "tl": ["finally", "(", "go_near(pear)", ")", "and", "move_to(tree)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 and prop_2) FINISH"}
{"id": 2549, "sentence": ["at", "any", "time", "pass", "by", "trash", "bin", "and", "whenever", "go", "by", "tree"], "tl": ["finally", "(", "pass_by(trash_bin)", ")", "and", "finally", "(", "go_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "whenever", "go", "by", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (globally prop_1) and (globally prop_2) FINISH"}
{"id": 2487, "sentence": ["at", "any", "time", "grab", "pear", "or", "when", "possible", "shift", "to", "flag"], "tl": ["finally", "(", "grab(pear)", ")", "or", "finally", "(", "shift_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "shift", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "shift_to", "action_ref": "shift to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or finally prop_2) FINISH"}
{"id": 2918, "sentence": ["at", "any", "time", "go", "near", "pear", "and", "never", "let", "go", "apple"], "tl": ["finally", "(", "go_near(pear)", ")", "and", "globally", "(", "negation", "(", "let_go(apple)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "never", "let", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(G), meaning the property holds always. \"go near pear\" is represented by prop_1. \"never let go apple\" means \"not eventually let go apple,\" so \"never let go apple\" is \"not finally prop_2.\" The entire command is \"globally (prop_1 and not finally prop_2).\"\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"globally\", \"go near pear\": \"prop_1\", \"never let go apple\": \"not finally prop_2\"}\n\n3. *FINAL:* G (prop_1 and not F prop_2)"}
{"id": 3010, "sentence": ["when", "possible", "stand", "by", "tree", "until", "at", "any", "time", "walk", "to", "flag"], "tl": ["finally", "(", "stand_by(tree)", ")", "until", "finally", "(", "walk_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "until", "at", "any", "time", "walk", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "stand_by", "action_ref": "stand by", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "walk_to", "action_ref": "walk to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(prop_1 U prop_2)"}
{"id": 4397, "sentence": ["whenever", "proceed", "to", "tree", "or", "gather", "apple"], "tl": ["finally", "(", "proceed_to(tree)", ")", "or", "gather(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "gather", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "proceed_to", "action_ref": "proceed to", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "gather", "action_ref": "gather", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1 or prop_2)\", \"whenever proceed to tree or gather apple\": \"G(prop_1 or prop_2)\"}\n\n3. *FINAL:* G(prop_1 or prop_2)"}
{"id": 2699, "sentence": ["when", "whenever", "go", "visit", "house", ",", "move", "to", "house"], "tl": ["finally", "(", "go_visit(house)", ")", "imply", "move_to(house)"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "prop_2"], "grounded_sentence": ["when", "whenever", "prop_1", ",", "move", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 2211, "sentence": ["whenever", "make", "contact", "flag", "and", "go", "visit", "flag"], "tl": ["finally", "(", "make_contact(flag)", ")", "and", "go_visit(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "and", "go", "visit", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_contact", "action_ref": "make contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "go_visit", "action_ref": "go visit", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(\"make contact flag\" and \"go visit flag\"), some property should hold. Since the command does not specify what should happen after these conditions, we interpret it as a global implication: globally, if both \"make contact flag\" and \"go visit flag\" are true, then some condition follows. Without further specification, the simplest interpretation is that whenever both are true, that fact holds (i.e., the condition itself). So the formula is a global statement that whenever both propositions hold, they hold (a tautology). Alternatively, if the command implies that whenever \"make contact flag\" happens, then \"go visit flag\" should happen, then the formula is globally (make_contact_flag implies eventually go_visit_flag). But since the command says \"whenever make contact flag and go visit flag\", it suggests both happen together, so the formula is globally (make_contact_flag and go_visit_flag)"}
{"id": 2863, "sentence": ["hold", "on", "to", "pear", "or", "go", "to", "orange"], "tl": ["hold_on_to(pear)", "or", "go_to(orange)"], "masked_tl": ["prop_1", "or", "prop_2"], "grounded_sentence": ["prop_1", "or", "go", "to", "orange", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold_on_to", "action_ref": "hold on to", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 or prop_2)) FINISH"}
{"id": 1828, "sentence": ["at", "any", "time", "come", "home", "until", "never", "let", "go", "orange"], "tl": ["finally", "(", "come(home)", ")", "until", "globally", "(", "negation", "(", "let_go(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "until", "never", "let", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "come", "action_ref": "come", "args_canon": ["home)"], "args_ref": ["home)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(G), meaning always. \"Come home\" is represented by prop_1. \"Until\" indicates the use of the \"until\" (U) operator. \"Never let go orange\" means that \"let go orange\" (prop_2) never happens, so \"not prop_2\" holds globally. Thus, the formula states: \"Always, prop_1 holds until it is never the case that prop_2 happens,\" which is \"G (prop_1 U G (not prop_2))\".\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"G\", \"come home\": \"prop_1\", \"until\": \"U\", \"never let go orange\": \"G (not prop_2)\"}\n\n3. *FINAL:* G (prop_1 U G (not prop_2))"}
{"id": 7096, "sentence": ["when", "possible", "go", "near", "flag", "or", "move", "towards", "trash", "can"], "tl": ["finally", "(", "go_near(flag)", ")", "or", "move_towards(trash_can)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["when", "possible", "prop_1", "or", "move", "towards", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "move_towards", "action_ref": "move towards", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* finally (prop_1 or prop_2) FINISH"}
{"id": 108, "sentence": ["forever", "hold", "onto", "orange", "or", "at", "some", "time", "make", "contact", "with", "house"], "tl": ["globally", "(", "hold_onto(orange)", ")", "or", "finally", "(", "make_contact_with(house)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "at", "some", "time", "make", "contact", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "make_contact_with", "action_ref": "make contact with", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (globally(prop_1) or finally(prop_2)) FINISH"}
{"id": 1308, "sentence": ["whenever", "get", "hold", "apple", "or", "travel", "to", "waste", "bin"], "tl": ["finally", "(", "get_hold(apple)", ")", "or", "travel_to(waste_bin)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["whenever", "prop_1", "or", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}}, "prediction": "(unspecified) follows. Since no consequent is given, we can express the condition as globally, \"get hold apple or travel to waste bin\" holds. We assign prop_1 to \"get hold apple\" and prop_2 to \"travel to waste bin\". The formula is then: globally (prop_1 or prop_2).\n\n2. *Explanation dictionary* \u2013 {\"get hold apple\": \"prop_1\", \"travel to waste bin\": \"prop_2\", \"get hold apple or travel to waste bin\": \"(prop_1 or prop_2)\", \"whenever get hold apple or travel to waste bin\": \"globally (prop_1 or prop_2)"}
{"id": 1927, "sentence": ["at", "some", "time", "track", "towards", "tree", "and", "grip", "apple"], "tl": ["finally", "(", "track_towards(tree)", ")", "and", "grip(apple)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "grip", "apple", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "track_towards", "action_ref": "track towards", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "grip", "action_ref": "grip", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (finally (prop_1 and prop_2)) FINISH"}
{"id": 4155, "sentence": ["at", "some", "time", "going", "to", "house", "and", "at", "some", "time", "be", "near", "tree"], "tl": ["finally", "(", "going_to(house)", ")", "and", "finally", "(", "be_near(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "at", "some", "time", "be", "near", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "going_to", "action_ref": "going to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* (finally prop_1) and (finally prop_2) FINISH"}
{"id": 1341, "sentence": ["at", "some", "time", "steal", "apple", "and", "when", "possible", "move", "to", "flag"], "tl": ["finally", "(", "steal(apple)", ")", "and", "finally", "(", "move_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "some", "time", "prop_1", "and", "when", "possible", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "steal", "action_ref": "steal", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (F prop_1) and (G ("}
{"id": 3625, "sentence": ["when", "possible", "bring", "pear", "until", "whenever", "go", "by", "waste", "basket"], "tl": ["finally", "(", "bring(pear)", ")", "until", "finally", "(", "go_by(waste_basket)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "until", "whenever", "go", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}}, "prediction": "3. *FINAL:* G(prop_1 implies (prop_2 U prop_3)) FINISH"}
{"id": 5755, "sentence": ["go", "to", "orange", "and", "don't", "pick", "up", "anything"], "tl": ["go_to(orange)", "and", "negation", "(", "finally", "(", "pick_up(anything)", ")", ")"], "masked_tl": ["prop_1", "and", "negation", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["prop_1", "and", "don't", "pick", "up", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["anything)"], "args_ref": ["anything)"]}}, "prediction": "3. *FINAL:* (F prop_1) and (G not prop_2) FINISH"}
{"id": 5496, "sentence": ["never", "drop", "orange", "or", "at", "some", "time", "seize", "pear"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "or", "finally", "(", "seize(pear)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "or", "at", "some", "time", "seize", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "seize", "action_ref": "seize", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "- Combining these with \"or\": (G (not prop_1)) or (F prop_2)."}
{"id": 1455, "sentence": ["never", "drop", "orange", "and", "when", "possible", "acquire", "pear"], "tl": ["globally", "(", "negation", "(", "drop(orange)", ")", ")", "and", "finally", "(", "acquire(pear)", ")"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["never", "prop_1", "and", "when", "possible", "acquire", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (globally (not prop_1)) and (globally (prop_2 implies finally prop_3)) FINISH"}
{"id": 3985, "sentence": ["whenever", "contact", "flag", "and", "at", "any", "time", "move", "to", "flag"], "tl": ["finally", "(", "contact(flag)", ")", "and", "finally", "(", "move_to(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "any", "time", "move", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(contact_flag implies ...)\" meaning at all times, if contact_flag is true, then the following must hold. The phrase \"at any time move to flag\" means eventually moving to the flag, so \"finally move_to_flag\". Combining these, whenever contact_flag holds, eventually move_to_flag must hold.\n\n2. *Explanation dictionary* \u2013 {\"whenever contact flag\": \"G (prop_1 implies ...)\", \"contact flag\": \"prop_1\", \"at any time move to flag\": \"F prop_2\", \"move to flag\": \"prop_2\"}\n\n3. *FINAL:* G (prop_1 implies F prop_2)"}
{"id": 6755, "sentence": ["when", "possible", "get", "pear", "or", "at", "any", "time", "approach", "flag"], "tl": ["finally", "(", "get(pear)", ")", "or", "finally", "(", "approach(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "any", "time", "approach", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "get", "action_ref": "get", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "approach", "action_ref": "approach", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (finally prop_1) or (finally prop_2) FINISH"}
{"id": 1505, "sentence": ["at", "any", "time", "move", "forward", "trash", "can", "or", "whenever", "getting", "pear"], "tl": ["finally", "(", "move_forward(trash_can)", ")", "or", "finally", "(", "getting(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "whenever", "getting", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_forward", "action_ref": "move forward", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "getting", "action_ref": "getting", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (globally prop_1) or (globally (prop_2 implies prop_1)) FINISH"}
{"id": 5479, "sentence": ["at", "any", "time", "grasp", "pear", "and", "at", "some", "time", "tax", "apple"], "tl": ["finally", "(", "grasp(pear)", ")", "and", "finally", "(", "tax(apple)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "at", "some", "time", "tax", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "grasp", "action_ref": "grasp", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "tax", "action_ref": "tax", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* globally(prop_1) and finally(prop_2) FINISH"}
{"id": 718, "sentence": ["forever", "have", "apple", "or", "at", "some", "time", "grab", "apple"], "tl": ["globally", "(", "have(apple)", ")", "or", "finally", "(", "grab(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "at", "some", "time", "grab", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(prop_1) holds now, or \"at some time grab apple\" means eventually (F) \"grab apple\" (prop_2) holds. So the formula is G (prop_1 or F prop_2).\n\n2. *Explanation dictionary* \u2013 {\"forever\": \"G\", \"have apple\": \"prop_1\", \"grab apple\": \"prop_2\", \"at some time grab apple\": \"F prop_2\", \"have apple or at some time grab apple\": \"(prop_1 or F prop_2)\"}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 5860, "sentence": ["go", "to", "bucket", "or", "whenever", "stand", "by", "tree"], "tl": ["go_to(bucket)", "or", "finally", "(", "stand_by(tree)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "stand", "by", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["bucket)"], "args_ref": ["bucket)"]}, "prop_2": {"action_canon": "stand_by", "action_ref": "stand by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(F prop_1) or (F prop_2)"}
{"id": 1334, "sentence": ["at", "any", "time", "go", "to", "trash", "can", "or", "pick", "up", "flag"], "tl": ["finally", "(", "go_to(trash_can)", ")", "or", "pick_up(flag)"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "pick", "up", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}, "prop_2": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 6752, "sentence": ["forever", "move", "or", "whenever", "obtain", "apple"], "tl": ["globally", "(", "move", ")", "or", "finally", "(", "obtain(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "whenever", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move", "action_ref": "move", "args_canon": [], "args_ref": []}, "prop_2": {"action_canon": "obtain", "action_ref": "obtain", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(move or obtain apple)\".\n\n2. *Explanation dictionary* \u2013 {\"forever\": \"G\", \"move\": \"prop_1\", \"obtain apple\": \"prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G (prop_1 or prop_2)"}
{"id": 3716, "sentence": ["when", "possible", "be", "near", "tree", "or", "at", "some", "time", "go", "past", "flag"], "tl": ["finally", "(", "be_near(tree)", ")", "or", "finally", "(", "go_past(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "some", "time", "go", "past", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_near", "action_ref": "be near", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "go_past", "action_ref": "go past", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "(finally). \"Be near tree or at some time go past flag\" means either \"be near tree\" now or \"at some time go past flag\". So the formula expresses that eventually, either prop_1 (near tree) holds, or eventually prop_2 (go past flag) holds.\n\n2. *Explanation dictionary* \u2013 {\"when possible\": \"F\", \"be near tree\": \"prop_1\", \"go past flag\": \"prop_2\", \"or\": \"or\", \"at some time\": \"F\"}\n\n3. *FINAL:* F (prop_1 or F prop_2)"}
{"id": 3935, "sentence": ["whenever", "go", "past", "flag", "or", "always", "hold", "onto", "orange"], "tl": ["finally", "(", "go_past(flag)", ")", "or", "globally", "(", "hold_onto(orange)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "always", "hold", "onto", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_past", "action_ref": "go past", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "hold_onto", "action_ref": "hold onto", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "(prop_1 implies ...)\" where prop_1 represents \"go past flag\". The phrase \"or always hold onto orange\" means that either the condition \"go past flag\" triggers something, or \"always hold onto orange\" is true. \"Always hold onto orange\" translates to \"globally prop_2\" where prop_2 represents \"hold onto orange\". Combining these with \"or\" gives the formula: (globally (prop_1 implies ...)) or (globally prop_2). Since the command is \"whenever go past flag or always hold onto orange\", it can be interpreted as \"globally (go past flag) or globally (hold onto orange)\". But \"whenever\" is a temporal implication, so the formula is: globally (prop_1) or globally (prop_2)"}
{"id": 2090, "sentence": ["whenever", "withdraw", "pear", "or", "never", "drop", "orange"], "tl": ["finally", "(", "withdraw(pear)", ")", "or", "globally", "(", "negation", "(", "drop(orange)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "negation", "(", "prop_2", ")", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "never", "drop", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "withdraw", "action_ref": "withdraw", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "{\"withdraw pear\": \"prop_1\", \"drop orange\": \"prop_2\", \"never drop orange\": \"globally (not prop_2)\", \"withdraw pear or never drop orange\": \"(prop_1 or globally (not prop_2))\", \"whenever withdraw pear or never drop orange\": \"globally (prop_1 or globally (not prop_2))\"}"}
{"id": 2789, "sentence": ["drop", "orange", "or", "whenever", "contact", "house"], "tl": ["drop(orange)", "or", "finally", "(", "contact(house)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "contact", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "contact", "action_ref": "contact", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "(G) operator enforcing an implication: globally, if prop_1 then prop_2.\n\n2. *Explanation dictionary* \u2013 {\"contact house\": \"prop_1\", \"drop orange\": \"prop_2\", \"whenever\": \"globally (implies)\"}\n\n3. *FINAL:* G (prop_1 implies prop_2)"}
{"id": 6669, "sentence": ["pick", "up", "pear", "or", "forever", "have", "apple"], "tl": ["pick_up(pear)", "or", "globally", "(", "have(apple)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "forever", "have", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pick_up", "action_ref": "pick up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (prop_1 or globally prop_2) FINISH"}
{"id": 5928, "sentence": ["when", "venture", "towards", "house", ",", "at", "some", "time", "venture", "to", "house"], "tl": ["venture_towards(house)", "imply", "finally", "(", "venture_to(house)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "prop_1", ",", "at", "some", "time", "venture", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_towards", "action_ref": "venture towards", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (finally prop_1) implies (finally prop_2) FINISH"}
{"id": 2621, "sentence": ["when", "possible", "scoop", "up", "pear", "or", "when", "possible", "capture", "pear"], "tl": ["finally", "(", "scoop_up(pear)", ")", "or", "finally", "(", "capture(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "when", "possible", "capture", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "scoop_up", "action_ref": "scoop up", "args_canon": ["pear)"], "args_ref": ["pear)"]}, "prop_2": {"action_canon": "capture", "action_ref": "capture", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (F (prop_1 or prop_2)) FINISH"}
{"id": 6192, "sentence": ["whenever", "venture", "to", "house", "until", "whenever", "bring", "pear"], "tl": ["finally", "(", "venture_to(house)", ")", "until", "finally", "(", "bring(pear)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "until", "whenever", "bring", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "venture_to", "action_ref": "venture to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* G (prop_1 implies (not prop_2 until prop_2)) FINISH"}
{"id": 4044, "sentence": ["visit", "tree", "until", "acquire", "apple"], "tl": ["visit(tree)", "until", "acquire(apple)"], "masked_tl": ["prop_1", "until", "prop_2"], "grounded_sentence": ["prop_1", "until", "acquire", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "visit", "action_ref": "visit", "args_canon": ["tree)"], "args_ref": ["tree)"]}, "prop_2": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(U). So the formula states that \"visit tree\" holds continuously until \"acquire apple\" becomes true.\n\n2. *Explanation dictionary* \u2013 {\"visit tree\": \"prop_1\", \"acquire apple\": \"prop_2\", \"until\": \"U\"}\n\n3. *FINAL:* (prop_1 U prop_2)"}
{"id": 352, "sentence": ["when", "never", "drop", "apple", ",", "secure", "apple"], "tl": ["globally", "(", "negation", "(", "drop(apple)", ")", ")", "imply", "secure(apple)"], "masked_tl": ["globally", "(", "negation", "(", "prop_1", ")", ")", "imply", "prop_2"], "grounded_sentence": ["when", "never", "prop_1", ",", "secure", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* ( (globally (not prop_1)) implies (finally prop_2) ) FINISH"}
{"id": 3088, "sentence": ["always", "have", "apple", "and", "at", "some", "time", "get", "hold", "apple"], "tl": ["globally", "(", "have(apple)", ")", "and", "finally", "(", "get_hold(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["always", "prop_1", "and", "at", "some", "time", "get", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have", "action_ref": "have", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "get_hold", "action_ref": "get hold", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "3. *FINAL:* (globally prop_1) and (finally prop_2) FINISH"}
{"id": 5000, "sentence": ["when", "possible", "pass", "by", "house", "or", "at", "some", "time", "travel", "to", "trash", "can"], "tl": ["finally", "(", "pass_by(house)", ")", "or", "finally", "(", "travel_to(trash_can)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "at", "some", "time", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "pass_by", "action_ref": "pass by", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["trash_can)"], "args_ref": ["trash can)"]}}, "prediction": "3. *FINAL:* (finally (prop_1)) implies (finally (prop_2)) FINISH"}
{"id": 6725, "sentence": ["at", "any", "time", "be", "in", "house's", "vicinity", "or", "repeatedly", "grab", "tree"], "tl": ["finally", "(", "be_in(house's_vicinity)", ")", "or", "globally", "(", "finally", "(", "grab(tree)", ")", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "globally", "(", "finally", "(", "prop_2", ")", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "repeatedly", "grab", "tree", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_in", "action_ref": "be in", "args_canon": ["house's_vicinity)"], "args_ref": ["house's vicinity)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(or) between two conditions: \"be in house's vicinity\" and \"repeatedly grab tree\". \"Be in house's vicinity\" is represented by a proposition, say prop_1. \"Repeatedly grab tree\" means that \"grab tree\" (prop_2) happens infinitely often, which can be expressed as \"globally finally prop_2\" (G F prop_2).\n\n2. *Explanation dictionary* \u2013 {\"at any time\": \"G\", \"be in house's vicinity\": \"prop_1\", \"repeatedly grab tree\": \"G F prop_2\", \"or\": \"or\"}\n\n3. *FINAL:* G (prop_1 or G F prop_2)"}
{"id": 700, "sentence": ["repeatedly", "make", "way", "to", "house", "or", "do", "not", "let", "go", "pear"], "tl": ["globally", "(", "finally", "(", "make_way_to(house)", ")", ")", "or", "negation", "(", "let_go(pear)", ")"], "masked_tl": ["globally", "(", "finally", "(", "prop_1", ")", ")", "or", "negation", "(", "prop_2", ")"], "grounded_sentence": ["repeatedly", "prop_1", "or", "do", "not", "let", "go", "pear", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_way_to", "action_ref": "make way to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "let_go", "action_ref": "let go", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 2285, "sentence": ["at", "any", "time", "go", "to", "trash", "bin", "or", "when", "possible", "go", "near", "flag"], "tl": ["finally", "(", "go_to(trash_bin)", ")", "or", "finally", "(", "go_near(flag)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["at", "any", "time", "prop_1", "or", "when", "possible", "go", "near", "flag", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trash_bin)"], "args_ref": ["trash bin)"]}, "prop_2": {"action_canon": "go_near", "action_ref": "go near", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* globally (prop_1 or prop_2) FINISH"}
{"id": 2384, "sentence": ["acquire", "apple", "or", "whenever", "grab", "pear"], "tl": ["acquire(apple)", "or", "finally", "(", "grab(pear)", ")"], "masked_tl": ["prop_1", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "whenever", "grab", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "acquire", "action_ref": "acquire", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "grab", "action_ref": "grab", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "  \"acquire apple or whenever grab pear\": \"(finally prop_1) or (globally (prop_2 implies finally prop_1))\""}
{"id": 1833, "sentence": ["at", "any", "time", "take", "possession", "of", "bear", "and", "hold", "on", "to", "pear"], "tl": ["finally", "(", "take_possession_of(bear)", ")", "and", "hold_on_to(pear)"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "prop_2"], "grounded_sentence": ["at", "any", "time", "prop_1", "and", "hold", "on", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 0, 1, 1, 1, 1, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "take_possession_of", "action_ref": "take possession of", "args_canon": ["bear)"], "args_ref": ["bear)"]}, "prop_2": {"action_canon": "hold_on_to", "action_ref": "hold on to", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "3. *FINAL:* (globally (prop_1 and prop_2)) FINISH"}
{"id": 5763, "sentence": ["secure", "apple", "until", "whenever", "bring", "pear"], "tl": ["secure(apple)", "until", "finally", "(", "bring(pear)", ")"], "masked_tl": ["prop_1", "until", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "until", "whenever", "bring", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "bring", "action_ref": "bring", "args_canon": ["pear)"], "args_ref": ["pear)"]}}, "prediction": "(prop_2) happens, the condition \"secure apple\" (prop_1) must hold until that event. So, \"whenever bring pear\" translates to a globally (G) condition that \"secure apple\" holds until \"bring pear\" occurs. The \"until\" operator (U) is used to express that \"secure apple\" holds continuously until \"bring pear\" happens.\n\n2. *Explanation dictionary* \u2013 {\"secure apple\": \"prop_1\", \"bring pear\": \"prop_2\", \"secure apple until bring pear\": \"prop_1 U prop_2\", \"whenever bring pear\": \"G (prop_1 U prop_2)\"}\n\n3. *FINAL:* G (prop_1 U prop_2)"}
{"id": 4451, "sentence": ["when", "possible", "advance", "to", "house", "or", "whenever", "travel", "to", "house"], "tl": ["finally", "(", "advance_to(house)", ")", "or", "finally", "(", "travel_to(house)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["when", "possible", "prop_1", "or", "whenever", "travel", "to", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "advance_to", "action_ref": "advance to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["house)"], "args_ref": ["house)"]}}, "prediction": "3. *FINAL:* (prop_1 implies finally prop_2) or globally (prop_3 implies finally prop_2) FINISH"}
{"id": 5902, "sentence": ["whenever", "be", "in", "house's", "vicinity", "or", "when", "possible", "go", "to", "trashcan"], "tl": ["finally", "(", "be_in(house's_vicinity)", ")", "or", "finally", "(", "go_to(trashcan)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "or", "when", "possible", "go", "to", "trashcan", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "be_in", "action_ref": "be in", "args_canon": ["house's_vicinity)"], "args_ref": ["house's vicinity)"]}, "prop_2": {"action_canon": "go_to", "action_ref": "go to", "args_canon": ["trashcan)"], "args_ref": ["trashcan)"]}}, "prediction": "3. *FINAL:* G((prop_1 or prop_2) implies F prop_3) FINISH"}
{"id": 115, "sentence": ["go", "by", "waste", "bin", "and", "secure", "apple"], "tl": ["go_by(waste_bin)", "and", "secure(apple)"], "masked_tl": ["prop_1", "and", "prop_2"], "grounded_sentence": ["prop_1", "and", "secure", "apple", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 1, 0, 2, 2], "prop_dict": {"prop_1": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["waste_bin)"], "args_ref": ["waste bin)"]}, "prop_2": {"action_canon": "secure", "action_ref": "secure", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "     \"and\": \"and\""}
{"id": 6544, "sentence": ["if", "move", "to", "house", ",", "at", "some", "time", "travel", "by", "tree"], "tl": ["move_to(house)", "imply", "finally", "(", "travel_by(tree)", ")"], "masked_tl": ["prop_1", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "prop_1", ",", "at", "some", "time", "travel", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "move_to", "action_ref": "move to", "args_canon": ["house)"], "args_ref": ["house)"]}, "prop_2": {"action_canon": "travel_by", "action_ref": "travel by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 2901, "sentence": ["drop", "orange", "and", "when", "possible", "go", "by", "flag"], "tl": ["drop(orange)", "and", "finally", "(", "go_by(flag)", ")"], "masked_tl": ["prop_1", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "and", "when", "possible", "go", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "drop", "action_ref": "drop", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "go_by", "action_ref": "go by", "args_canon": ["flag)"], "args_ref": ["flag)"]}}, "prediction": "3. *FINAL:* (prop_1 and finally prop_2) FINISH"}
{"id": 6550, "sentence": ["forever", "have", "in", "orange", "or", "when", "possible", "lay", "hold", "of", "apple"], "tl": ["globally", "(", "have_in(orange)", ")", "or", "finally", "(", "lay_hold_of(apple)", ")"], "masked_tl": ["globally", "(", "prop_1", ")", "or", "finally", "(", "prop_2", ")"], "grounded_sentence": ["forever", "prop_1", "or", "when", "possible", "lay", "hold", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}, "prop_2": {"action_canon": "lay_hold_of", "action_ref": "lay hold of", "args_canon": ["apple)"], "args_ref": ["apple)"]}}, "prediction": "(F) for the possibility of laying hold of apple. Thus, the formula states that always (G), either prop_1 holds or eventually prop_2 holds.\n\n2. *Explanation dictionary* \u2013\n{\n  \"forever\": \"G\",\n  \"have in orange\": \"prop_1\",\n  \"lay hold of apple\": \"prop_2\",\n  \"or when possible\": \"or F prop_2\"\n}\n\n3. *FINAL:* G (prop_1 or F prop_2)"}
{"id": 6731, "sentence": ["whenever", "walk", "near", "flag", "and", "at", "any", "time", "travel", "by", "tree"], "tl": ["finally", "(", "walk_near(flag)", ")", "and", "finally", "(", "travel_by(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "and", "finally", "(", "prop_2", ")"], "grounded_sentence": ["whenever", "prop_1", "and", "at", "any", "time", "travel", "by", "prop_2"], "lifted_sentence_prop_ids": [0, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "walk_near", "action_ref": "walk near", "args_canon": ["flag)"], "args_ref": ["flag)"]}, "prop_2": {"action_canon": "travel_by", "action_ref": "travel by", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "(prop_1 implies F prop_2)"}
{"id": 2706, "sentence": ["if", "whenever", "make", "way", "waste", "basket", ",", "at", "any", "time", "spend", "time", "at", "tree"], "tl": ["finally", "(", "make_way(waste_basket)", ")", "imply", "finally", "(", "spend_time_at(tree)", ")"], "masked_tl": ["finally", "(", "prop_1", ")", "imply", "finally", "(", "prop_2", ")"], "grounded_sentence": ["if", "whenever", "prop_1", ",", "at", "any", "time", "spend", "time", "at", "prop_2"], "lifted_sentence_prop_ids": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "make_way", "action_ref": "make way", "args_canon": ["waste_basket)"], "args_ref": ["waste basket)"]}, "prop_2": {"action_canon": "spend_time_at", "action_ref": "spend time at", "args_canon": ["tree)"], "args_ref": ["tree)"]}}, "prediction": "3. *FINAL:* globally (prop_1 implies finally prop_2) FINISH"}
{"id": 3470, "sentence": ["travel", "to", "apple", "or", "always", "have", "in", "orange"], "tl": ["travel_to(apple)", "or", "globally", "(", "have_in(orange)", ")"], "masked_tl": ["prop_1", "or", "globally", "(", "prop_2", ")"], "grounded_sentence": ["prop_1", "or", "always", "have", "in", "prop_2"], "lifted_sentence_prop_ids": [1, 1, 1, 0, 0, 2, 2, 2], "prop_dict": {"prop_1": {"action_canon": "travel_to", "action_ref": "travel to", "args_canon": ["apple)"], "args_ref": ["apple)"]}, "prop_2": {"action_canon": "have_in", "action_ref": "have in", "args_canon": ["orange)"], "args_ref": ["orange)"]}}, "prediction": "3. *FINAL:* (prop_1 or globally prop_2) FINISH"}
